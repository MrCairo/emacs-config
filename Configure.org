#+title: Mitch's Emacs Configuration File
#+author: Mitch Fisher
#+date: 2024-04-20
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes
#+auto_tangle: t

* Welcome!

This ORG file will configure the *init.el* file based upon all of the *emacs-lisp* source blocks. The emacs-lisp source blocks are defined in an organized order. While these blocks cn generally be moved around, there are some order dependencies. So it's generally best that this order be preserved to prevent any compile-time issues.


* README:
-----

- While this configuration includes support for several languages - and I mean support for syntax highlighting and, to some extent, debugging - this configuration caters to be a Python develpment environment.
  
- The C/C++ debugger for these type of programs are done via LSP/LLDB and [[RealGUD][RealGUD]]. The chosen =debug-adapter= custom variable doesn't apply. The reason for this is that the DAP/LSP/LLDB interaction doesn't work properly on my =Apple Silicon= mac. Until GDB supports =ARM= instruction sets then this (=RealGUD=) will remain as the only best way to support a more integrated debugging experience.
  
- Python can use either =dap= or =dape= which is the reasoning behind the =debug-adapter= custom variable.
  
- If auto-tangling doesn't work because of a problem in the generated ~init.el~ file, then tangling can be done manually by either using ~(C-c C-v t)~ or by calling the =org-babel-tangle= M-x command.
  
- When starting this Configuration for the very first time, set the =use-package-always-ensure= variable to =t=. This will force all packages to be installed even if deferred. Make sure to set this value back to =nil= after everything is loaded otherwize Emacs startup time will be impacted. This can be found in the [[Bootstrap straight][Bootstrap straight]] section.

- Take a look a the [[Custom enable flags][Custom Variables]] and [[Custom groups][Groups]] section to see what options exist. It's important to note that these variables need to be adhered to. Another thing to note is that the various =enable*= flags are not used as =:if= option in =use-package= statement. Instead, a lisp conditional statement is used so that the package is actually never loaded or installed. This improves overall startup performance.
   
-----


* Early Setup

**** Lispy Header
This is the standard format of a =lisp= header that should appear for all =lisp= scripts. It also indicates that the ~init.el~ file is generated from this ~Configure.org~ file.

#+begin_src emacs-lisp
  ;;; init.el --- My customized emacs init file -- lexical-binding: t --
  ;;;
  ;;; Commentary:

  ;; This file bootstraps the configuration which is created from tangling
  ;; Configuration.org into this init.el file.
  ;;
  ;; So, DO NOT MODIFY.  THIS FILE IS GENERATED
  ;; Edit the Configure.org file, save (auto-tangle) and this file will be
  ;; generated.  Plus, there are a lot of comments that are in the Configure.org
  ;; file that are not exported as part of this source.  The comments provide more
  ;; detail for certain modes as well as other important details.  If there is a
  ;; question as to why something is a certain way or how a package may work,
  ;; the Configure.org file may contain those answers.

  ;;; Code:

  ;; Produce backtraces when errors occur: can be helpful to diagnose startup issues
  ;; (setq debug-on-error t)
  ;;

#+end_src

** Bootstrap straight

=Straight= is an alternative package manager that installs packages through Git checkouts instead of downloading tarballs from one of the package archives. Doing so allows installing forked packages, altering local package checkouts, and locking packages to exact versions for reproducable setups.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
          "straight/repos/straight.el/bootstrap.el"
          (or (bound-and-true-p straight-base-dir)
              user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
         (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (setq straight-use-package-by-default t
        use-package-verbose t)

  (straight-use-package 'use-package)

  (setq use-package-compute-statistics t
      use-package-verbose t
      use-package-always-ensure nil
      use-package-always-demand nil
      use-package-always-defer nil)

  (use-package el-patch)

  ;; Load org early on in the init process
  ;; (use-package org :straight t)
  ;; Make sure that we set the read buffer above the default 4k
  (setq read-process-output-max (* 1024 1024))

  #+end_src


* Custom Variables and Groups

Set various variables to =t= to turn on a specific feature or =nil= to disable it. Changing any of these values will require a restart of ~emacs~ since these values are inspected only during startup.

*Note:* There are no thorough dependency check done if any of these values is enabled or disabled. There has been some effort, for example, to enable a keymap if ~dap~ or ~dape~ is enabled. But if something enabled requires some not obvious package to be installed, this isn't checked.

Other variables are also defined here that define other emacs behaviors and defaults.

*** Customization groups

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Define my customization groups

  (defgroup mrf-custom nil
      "Customization toggles for my personal Emacs installation."
      :group 'Local)

  (defgroup mrf-custom-toggles nil
      "A set of toggles that enable or disable  specific packages."
      :group 'mrf-custom)

  (defgroup mrf-custom-choices nil
      "Customization from a selection of specific features."
      :group 'mrf-custom)

  (defgroup mrf-custom-fonts nil
      "Customization of fonts and sizes."
      :group 'mrf-custom)

  (defgroup mrf-custom-theming nil
      "Custom theming values."
      :group 'mrf-custom)

#+end_src

*** File Locations and Variables

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defcustom display-dashboard-at-start t
      "If set to t, the `dashboard' package will be displayed first.
    Otherwise, the `dashboard' will be available but in the buffer
     ,*dashboard*."
      :type 'boolean
      :group 'mrf-custom)

  (defcustom custom-docs-dir "~/Documents/Emacs-Related"
      "A directory used to store documents and customized data."
      :type 'string
      :group 'mrf-custom)

  (defcustom working-files-directory
      (expand-file-name
  	  (concat "emacs-working-files_" emacs-version) custom-docs-dir)
      "The directory where to store Emacs working files."
      :type 'string
      :group 'mrf-custom)

  (defcustom custom-org-fill-column 150
      "The fill column width for Org mode text.
  Note that the text is also centered on the screen so that should
  be taken into consideration when providing a width."
      :type 'natnum
      :group 'mrf-custom)

#+end_src

*** Custom Package Toggles

Thes values toggle the availability of specific packages. Only boolean type values are part of this group.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Feature Toggles

  (defcustom enable-gb-dev nil
      "If set to t, the z80-mode and other GameBoy related packages
      will be enabled."
      :type 'boolean
      :group 'mrf-custom-toggles)

  (defcustom enable-ts nil
      "Set to t to enable TypeScript handling."
      :type 'boolean
      :group 'mrf-custom-toggles)

  (defcustom enable-corfu nil
      "Setting to t enables Corfu instead of Ivy.
      Corfu is an alternative to the command completion package, IVY which also will
      include Swiper and Company.  If this value is set to nil then Ivy is used."
      :type 'boolean
      :group 'mrf-custom-toggles)

  (defcustom enable-vundo t
      "Set to t to enable `vundo' which is an alternative to Emacs undo.
      Setting this value to nil will activate the alternate `undo-tree' package."
      :type 'boolean
      :group 'mrf-custom-toggles)

  (defcustom enable-centaur-tabs nil
      "Set to t to enable `centaur-tabs' which uses tabs to represent open buffer."
      :type 'boolean
      :group 'mrf-custom)

  (defcustom enable-neotree nil
      "Set to t to enable the `neotree' package."
      :type 'boolean
      :group 'mrf-custom-toggles)

  (defcustom enable-golden-ratio nil
      "Set to t to enable `golden-ratio-mode' which resizes the active buffer
      window to the dimensions of a golden-rectangle "
      :type 'boolean
      :group 'mrf-custom)

#+end_src

*** Feature selections
These are features that basically have multiple-choice options instead of being a typical binary t or nil. 

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defcustom completion-handler 'comphand-vertico
      "Select the default minibuffer completion handler.

  Vertico provides a performant and minimalistic vertical completion UI based on
  the default completion system.

  Ivy is a generic completion mechanism for Emacs. While it operates similarly to
  other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
  smaller, simpler, and smoother to use yet highly customizable.  The Ivy package
  also includes Counsel. Counsel provides completion versions of common Emacs
  commands that are customised to make the best use of Ivy.  Swiper is an
  alternative to isearch that uses Ivy to show an overview of all matches."
      :type '(choice (const :tag "Use the Vertico completion system." comphand-vertico)
                 (const :tag "Use Ivy, Counsel, Swiper completion systems" comphand-ivy-counsel))
      :group 'mrf-custom-selections)

  (defcustom debug-adapter 'enable-dape
      "Select the debug adapter to use for debugging applications.  dap-mode is an
  Emacs client/library for Debug Adapter Protocol is a wire protocol for
  communication between client and Debug Server. It’s similar to the LSP but
  provides integration with debug server.

  dape (Debug Adapter Protocol for Emacs) is similar to dap-mode but is
  implemented entirely in Emacs Lisp. There are no other external dependencies
  with DAPE. DAPE supports most popular languages, however, not as many as
  dap-mode."
      :type '(choice (const :tag "Debug Adapter Protocol (DAP)" enable-dap-mode)
                 (const :tag "Debug Adapter Protocol for Emacs (DAPE)" enable-dape))
      :group 'mrf-custom-selections)

  (defcustom custom-ide 'custom-ide-eglot-lsp
      "Select which IDE will be used for Python development.

  Elpy is an Emacs package to bring powerful Python editing to Emacs. It
  combines and configures a number of other packages, both written in Emacs
  Lisp as well as Python. Elpy is fully documented at
  https://elpy.readthedocs.io/en/latest/index.html.

  Elgot/LSP Eglot is the Emacs client for the Language Server Protocol
  (LSP). Eglot provides infrastructure and a set of commands for enriching the
  source code editing capabilities of Emacs via LSP. Eglot itself is
  completely language-agnostic, but it can support any programming language
  for which there is a language server and an Emacs major mode.

  Anaconda-mode is another IDE for Python very much like Elpy. It is not as
  configurable but has a host of great feaures that just work."
      :type '(choice (const :tag "Elpy: Emacs Lisp Python Environment" custom-ide-elpy)
                 (const :tag "Eglot/Language Server Protocol" custom-ide-eglot-lsp)
  		   (const :tag "Python Anaconda-mode for Emacs" custom-ide-anaconda))
      :group 'mrf-custom-choices)

#+end_src

*** Theme Specific Values
This is a curated selection of themes that I personally like. Most of them are dark mode but there are a few light versions. New themes can be added here or done via the =customize= interface. If a new theme is added to this list, it's important to ensure that the theme is actually included (see [[Color Theming][Color Theming]] section)

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Theming related

  (defcustom theme-list '("palenight-deeper-blue"
                             "ef-symbiosis"
                             "ef-maris-light"
                             "ef-maris-dark"
                             "ef-kassio"
  			   "ef-bio"
                             "sanityinc-tomorrow-bright"
                             "ef-melissa-dark"
                             "darktooth-dark"
                             "material"
                             "deeper-blue")
      "My personal list of themes to cycle through indexed by `theme-selector'.
  If additional themes are added, they must be previously installed."
      :group 'mrf-custom-theming
      :type '(repeat string))

  (defcustom default-terminal-theme "sanityinc-tomorrow-bright"
      "The default theme used for a terminal invocation of Emacs."
      :group 'mrf-custom-theming
      :type 'string)

  (defcustom theme-selector 0
      "The index into the list of custom themes."
      :group 'mrf-custom-theming
      :type 'natnum)

  ;;; Font related
  (defcustom default-font-family "Hack"
      "The font family used as the default font."
      :type 'string
      :group 'mrf-custom-fonts)

  (defcustom mono-spaced-font-family "Hack"
      "The font family used as the mono-spaced font."
      :type 'string
      :group 'mrf-custom-fonts)

  (defcustom variable-pitch-font-family "SF Pro"
      "The font family used as the default proportional font."
      :type 'string
      :group 'mrf-custom-fonts)

  (defcustom small-mono-font-size 150
      "The small font size in pixels."
      :type 'natnum
      :group 'mrf-custom-fonts)

  (defcustom medium-mono-font-size 170
      "The medium font size in pixels."
      :type 'natnum
      :group 'mrf-custom-fonts)

  (defcustom large-mono-font-size 190
      "The large font size in pixels."
      :type 'natnum
      :group 'mrf-custom-fonts)

  (defcustom x-large-mono-font-size 220
      "The extra-large font size in pixels."
      :type 'natnum
      :group 'mrf-custom-fonts)

  (defcustom small-variable-font-size 170
      "The small font size in pixels."
      :type 'natnum
      :group 'mrf-custom-fonts)

  (defcustom medium-variable-font-size 190
      "The small font size in pixels."
      :type 'natnum
      :group 'mrf-custom-fonts)

  (defcustom large-variable-font-size 210
      "The small font size in pixels."
      :type 'natnum
      :group 'mrf-custom-fonts)

  (defcustom x-large-variable-font-size 240
      "The small font size in pixels."
      :type 'natnum
      :group 'mrf-custom-fonts)

  (defcustom custom-default-font-size 170
      "A place to store the most current (face-attribute 'default :height).  This
  is specifically for the mono-spaced and default font. The variable type-face
  font size is computed + 20 of this value."
      :type 'natnum
      :group 'mrf-custom-fonts)

#+end_src

** Global Defaults

#+begin_src emacs-lisp

  ;;; --------------------------------------------------------------------------

  (setq-default
      window-resize-pixelwise t ;; enable smooth resizing
      window-resize-pixelwise t
      frame-resize-pixelwise t
      dired-dwim-target t       ;; try to guess target directory
      truncate-partial-width-windows 1 ;; truncate lines in partial-width windows
      auto-save-default nil     ;; disable auto save
      backup-inhibited t        ;; disable backup (No ~ tilde files)
      global-auto-revert-mode 1 ;; Refresh buffer if file has changed
      global-auto-revert-non-file-buffers t
      history-length 25         ;; Reasonable buffer length
      inhibit-startup-message t ;; Hide the startup message
      inhibit-startup-screent t
      lisp-indent-offset '4     ;; emacs lisp tab size
      visible-bell t            ;; Set up the visible bell
      truncate-lines 1          ;; long lines of text do not wrap
      fill-column 80            ;; Default line limit for fills
      ;; Triggers project for directories with any of the following files:
      project-vc-extra-root-markers '(".dir-locals.el"
  				    "requirements.txt"
  				    "Gemfile"
  				    "package.json")
      )

  ;; (global-display-line-numbers-mode 1) ;; Line numbers appear everywhere
  (save-place-mode 1)                  ;; Remember where we were last editing a file.
  (savehist-mode t)
  (show-paren-mode 1)
  (tool-bar-mode -1)                   ;; Hide the toolbar
  (global-prettify-symbols-mode 1)     ;; Display pretty symbols (i.e. λ = lambda)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  ;; Allow access from emacsclient
  (add-hook 'after-init-hook
      (lambda ()
          (require 'server)
          (unless (server-running-p)
              (server-start))))

  (when (fboundp 'pixel-scroll-precision-mode)
      (pixel-scroll-precision-mode))

  (use-package page-break-lines
      :config
      (global-page-break-lines-mode))

  (use-package default-text-scale
      :hook (after-init . default-text-scale-mode))

#+end_src

*** Anzu

anzu.el is an Emacs port of anzu.vim. anzu.el provides a minor mode which displays current match and total matches information in the mode-line in various search modes.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package anzu
      :custom
      (anzu-mode-lighter "")                    
      (anzu-deactivate-region t)                
      (anzu-search-threshold 1000)              
      (anzu-replace-threshold 50)               
      (anzu-replace-to-string-separator " => ")
      :config
      (global-anzu-mode +1)
      (set-face-attribute 'anzu-mode-line nil
          :foreground "yellow" :weight 'bold)
      (define-key isearch-mode-map
  	[remap isearch-query-replace]  #'anzu-isearch-query-replace)
      (define-key isearch-mode-map
  	[remap isearch-query-replace-regexp] #'anzu-isearch-query-replace-regexp))

#+end_src

** Emacs Config Directory

By default, the =user-emacs-directory= points to the .emacs.d* directory from which the =init.el= is used when Emacs starts. What this means is that any package that writes to this directory will be writing files to this initialization directory. Since we want to keep this directory clean, we set this directory to something external. A new variable, =emacs-config-directory= is set to now point to the starting Emacs condfiguration directory.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Set a variable that represents the actual emacs configuration directory.
  ;;; This is being done so that the user-emacs-directory which normally points
  ;;; to the .emacs.d directory can be re-assigned so that customized files don't
  ;;; pollute the configuration directory. This is where things like YASnippet
  ;;; snippets are saved and also additional color themese are stored.

  (defvar emacs-config-directory user-emacs-directory)

  ;;; Different emacs configuration installs with have their own configuration
  ;;; directory.
  (make-directory working-files-directory t)  ;; Continues to work even if dir exists

  ;;; Point the user-emacs-directory to the new working directory
  (setq user-emacs-directory working-files-directory)
  (message (concat ">>> Setting emacs-working-files directory to: " user-emacs-directory))

  ;;; Put any emacs cusomized variables in a special file
  (setq custom-file (expand-file-name "customized-vars.el" working-files-directory))
  (load custom-file 'noerror 'nomessage)

#+end_src

** Custom Theme List and Selection

This bit of code contains a list of themes that I like personally and then allows them to be switched between themselves. The index of ~theme-selector~ is what is set in order to access a theme via the ~mrf/load-theme-from-selector()~ function.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;;
  ;; 1. The function `mrf/load-theme-from-selector' is called from the
  ;;    "C-= =" Keybinding (just search for it).
  ;;
  ;; 2. Once the new theme is loaded via the `theme-selector', the previous
  ;;    theme is unloaded (or disabled) the function(s) defined in the
  ;;    `disable-theme-functions' hook are called (defined in the load-theme.el
  ;;    package).
  ;;
  ;; 3. The function `mrf/cycle-theme-selector' is called by the hook. This
  ;;    function increments the theme-selector by 1, cycling the value to 0
  ;;    if beyond the `theme-list' bounds.
  ;;
  (setq-default loaded-theme (nth theme-selector theme-list))
  (add-to-list 'savehist-additional-variables 'loaded-theme)
  (add-to-list 'savehist-additional-variables 'custom-default-font-size)
  (add-to-list 'savehist-additional-variables 'theme-selector)

#+end_src

*** Cycle Theme Function

This is the main function that allows cycling (up or down) through the list of themes defined in the ~theme-list~.  This function is normally called by the ~disable-theme-functions~ hook. Before calling this function, set the variable ~theme-cycle-step~ to either a 1 or -1 depending upon which direction in the ~theme-list~ array to select the next element from. The resulting index will cycle to the end or the beginning of the list if the computed index goes beyond element 0 or the length of ~theme-list~. The parameter =theme= is passed to this function when a theme becomes disabled (via the ~disable-theme~ function) and represents the theme that has become disabled.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/cycle-theme-selector (&rest theme)
      "Cycle the `theme-selector' by 1, resetting to 0 if beyond array bounds."
      (interactive)
      (let ((step theme-cycle-step) (result 0))

          (if (not step) (setq step 1)) ;; If nil, default to step of 1
     
          (when step
              (setq result (+ step theme-selector))
              (when (< result 0)
                  (setq result (- (length theme-list) 1)))
              (when (> result (- (length theme-list) 1))
                  (setq result 0)))
          
          (message (format ">>> Current theme %S" theme))
          (setq-default theme-selector result)))

  ;; This is used to trigger the cycling of the theme-selector
  ;; It is called when a theme is disabled. The theme is disabled from the
  ;; `mrf/load-theme-from-selector' function.
  (add-hook 'disable-theme-functions #'mrf/cycle-theme-selector)

#+end_src

*** Load Theme Function

This function simply loads the theme from the theme-list indexed by the ~theme-selector~ variable. Note the advice for ~load-theme~ that deactivates the current theme before activating the new theme. This is done to reset all the colors, a clean slate, before the new theme is activated.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/load-theme-from-selector (&optional step)
      "Load the theme in `theme-list' indexed by `theme-selector'."
      (interactive)
      (if step
          (setq theme-cycle-step step)
        (setq theme-cycle-step 1))
      (when loaded-theme
          (disable-theme (intern loaded-theme)))
      (setq loaded-theme (nth theme-selector theme-list))
      (message (concat ">>> Loading theme "
                   (format "%d: %S" theme-selector loaded-theme)))
      (load-theme (intern loaded-theme) t)
      (when (equal (fboundp 'mrf/org-font-setup) t)
          (mrf/org-font-setup))
      (set-face-foreground 'line-number "SkyBlue4"))

  (defun mrf/print-custom-theme-name ()
      "Print the current loaded theme from the `theme-list' on the modeline."
      (interactive)
      (message (format "Custom theme is %S" loaded-theme)))

  ;; Quick Helper Functions
  (defun next-theme ()
      "Go to the next theme in the list."
      (interactive)
      (mrf/load-theme-from-selector 1))

  (defun previous-theme ()
      "Go to the next theme in the list."
      (interactive)
      (mrf/load-theme-from-selector -1))

  (defun which-theme ()
      "Go to the next theme in the list."
      (interactive)
      (mrf/print-custom-theme-name))


  ;; Go to NEXT theme
  (global-set-key (kbd "C-c C-=") 'next-theme)
  ;; Go to PREVIOUS theme
  (global-set-key (kbd "C-c C--") 'previous-theme)
  ;; Print current theme
  (global-set-key (kbd "C-c C-?") 'which-theme)

#+end_src


This is just a test area to see what colors look like in this =org= mode.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; Normally not used but it's here so it's easy to change the block colors.
  (defun mrf/customize-org-block-colors ()
      (defface org-block-begin-line
  	'((t (:underline "#1D2C39" :foreground "#676E95" :background "#1D2C39")))
  	"Face used for the line delimiting the begin of source blocks.")

      (defface org-block-end-line
  	'((t (:overline "#1D2C39" :foreground "#676E95" :background "#1D2C39")))
  	"Face used for the line delimiting the end of source blocks."))

#+end_src


* Early Setup
** Use Shell Path
Because in macOS, Emacs could be started outside of a shell (like an application on the Dock), this code is used to migrate the <current user's shell path to Emacs ~exec-path~.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; Use shell path

  (defun set-exec-path-from-shell-PATH ()
     ;;; Set up Emacs' `exec-path' and PATH environment variable to match"
     ;;; that used by the user's shell.
     ;;; This is particularly useful under Mac OS X and macOS, where GUI
     ;;; apps are not started from a shell."
     (interactive)
     (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" ""
                               (shell-command-to-string "$SHELL --login -c 'echo $PATH'"))))
        (setenv "PATH" path-from-shell)
        (setq exec-path (split-string path-from-shell path-separator))
        (add-to-list 'exec-path "/opt/homebrew/bin")
        (add-to-list 'exec-path "/usr/local/bin")
        (add-to-list 'exec-path "/opt/homebrew/opt/openjdk/bin")
        (add-to-list 'exec-path "/opt/homebrew/opt/node@20/bin/node")
        (setq-default insert-directory-program "gls"
           dired-use-ls-dired t
           ;; Needed to fix an issue on Mac which causes dired to fail
           dired-listing-switches "-al --group-directories-first")))

#+end_src

** Include ~lisp~ directory
This directory is expected to be in the ~emacs-config-direcory~ dir. This can be used to store custom lisp (or non-elpa/melpa) files that can'tbe found by =require.el= or =straight-use-package=.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (add-to-list 'load-path (expand-file-name "lisp" emacs-config-directory))

#+end_src

** Frame Setup
It's nice to know that Emacs is somewhat working. To help this along, we set the Frame (window size fonts) early in the loading process.

*** Define the various font size constants

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; Frame (view) setup including fonts.
  ;; You will most likely need to adjust this font size for your system!

  (setq-default mrf/small-font-size 150)
  (setq-default mrf/small-variable-font-size 170)

  (setq-default mrf/medium-font-size 170)
  (setq-default mrf/medium-variable-font-size 190)

  (setq-default mrf/large-font-size 190)
  (setq-default mrf/large-variable-font-size 210)

  (setq-default mrf/x-large-font-size 220)
  (setq-default mrf/x-large-variable-font-size 240)

  ;; (setq-default custom-default-font-size mrf/medium-font-size)
  (setq-default mrf/default-variable-font-size (+ custom-default-font-size 20))
  ;; (setq-default mrf/set-frame-maximized t)  ;; or f

  ;; Make frame transparency overridable
  ;; (setq-default mrf/frame-transparency '(90 . 90))

  (setq frame-resize-pixelwise t)

#+end_src

*** Functions to set the frame size
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; Functions to set the frame size

  (defun mrf/frame-recenter (&optional frame)
     "Center FRAME on the screen.  FRAME can be a frame name, a terminal name,
    or a frame.  If FRAME is omitted or nil, use currently selected frame."
     (interactive)
     ;; (set-frame-size (selected-frame) 250 120)
     (unless (eq 'maximised (frame-parameter nil 'fullscreen))
        (progn
         (let ((width (nth 3 (assq 'geometry (car (display-monitor-attributes-list)))))
                 (height (nth 4 (assq 'geometry (car (display-monitor-attributes-list))))))
            (cond (( > width 3000) (mrf/update-large-display))
                  (( > width 2000) (mrf/update-built-in-display))
                  (t (mrf/set-frame-alpha-maximized)))
            )
         )
        )
     )

  (defun mrf/update-large-display ()
     (modify-frame-parameters
        frame '((user-position . t)
                (top . 0.0)
                (left . 0.70)
                (width . (text-pixels . 2800))
                (height . (text-pixels . 1650))) ;; 1800
        )
     )

  (defun mrf/update-built-in-display ()
     (modify-frame-parameters
        frame '((user-position . t)
                (top . 0.0)
                (left . 0.90)
                (width . (text-pixels . 1800))
                (height . (text-pixels . 1170)));; 1329
        )
     )


  ;; Set frame transparency
  (defun mrf/set-frame-alpha-maximized ()
     "Function to set the alpha and also maximize the frame."
     ;; (set-frame-parameter (selected-frame) 'alpha mrf/frame-transparency)
     (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
     (add-to-list 'default-frame-alist '(fullscreen . maximized)))

  ;; default window width and height
  (defun mrf/custom-set-frame-size ()
     "Simple function to set the default frame width/height."
     ;; (set-frame-parameter (selected-frame) 'alpha mrf/frame-transparency)
     (setq swidth (nth 3 (assq 'geometry (car (display-monitor-attributes-list)))))
     (setq sheight (nth 4 (assq 'geometry (car (display-monitor-attributes-list)))))

     (add-to-list 'default-frame-alist '(fullscreen . maximized))
     (mrf/frame-recenter)
     )
  
#+end_src

*** Default fonts and sizes

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; Default fonts

  (defun mrf/update-face-attribute ()
    "Set the font faces."
    ;; ====================================
    (set-face-attribute 'default nil
                        ;; :font "Hack"
                        ;; :font "Fira Code Retina"
                        ;; :font "Menlo"
                        :family default-font-family
                        :height custom-default-font-size
                        :weight 'medium)

    ;; Set the fixed pitch face
    (set-face-attribute 'fixed-pitch nil
                        ;; :font "Lantinghei TC Demibold"
                        :family mono-spaced-font-family
                        ;; :font "Fira Code Retina"
                        :height custom-default-font-size
                        :weight 'medium)

    ;; Set the variable pitch face
    (set-face-attribute 'variable-pitch nil
                        :family variable-pitch-font-family
                        :height (+ custom-default-font-size 20)
                        :weight 'medium))

  ;; (mrf/update-face-attribute)
  ;; (add-hook 'window-setup-hook #'mrf/frame-recenter)
  ;; (add-hook 'after-init-hook #'mrf/frame-recenter)
  
  ;; This is done so that the Emacs window is sized early in the init phase along with the default font size.
  ;; Startup works without this but it's nice to see the window expand early...
  (when (display-graphic-p)
     (mrf/update-face-attribute)
     (unless (daemonp)
        (mrf/frame-recenter)))

#+end_src

*** Theme font change hook

The functions in the list =after-setting-font-hook= are called whenever the frame's font changes. In order to save this value, we capture it and store it in the =custom-default-font-size= custom variable. This variable is saved whenver Emacs exists. Then, when Emacs is started again, the default and fixed-pitch font height values are set to =custom-default-font-size=. The variable pitch font is computed as ~(+ custom-default-font-size 20)~

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/default-font-height-change ()
      (setq-default custom-default-font-size (face-attribute 'default :height))
      (mrf/update-face-attribute)
      (mrf/frame-recenter))
  
  (add-hook 'after-setting-font-hook 'mrf/default-font-height-change)

#+end_src

*** Theme font change hook

The functions in the list =after-setting-font-hook= are called whenever the frame's font changes. In order to save this value, we capture it and store it in the =custom-default-font-size= custom variable. This variable is saved whenver Emacs exists. Then, when Emacs is started again, the default and fixed-pitch font height values are set to =custom-default-font-size=. The variable pitch font is computed as ~(+ custom-default-font-size 20)~

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/default-font-height-change ()
      (setq-default custom-default-font-size (face-attribute 'default :height))
      (mrf/update-face-attribute)
      (mrf/frame-recenter))
  
  (add-hook 'after-setting-font-hook 'mrf/default-font-height-change)

#+end_src

** Must Install Packages
*** Diminish
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package diminish
      :straight (diminish :type git :flavor melpa :host github :repo "myrjola/diminish.el"))

  (defun mrf/set-diminish ()
     (diminish 'projectile-mode "PrM")
     (diminish 'anaconda-mode)
     (diminish 'tree-sitter-mode "ts")
     (diminish 'ts-fold-mode)
     (diminish 'counsel-mode)
     (diminish 'golden-ratio-mode)
     (diminish 'company-box-mode)
     (diminish 'company-mode))

  ;; Need to run late in the startup process
  (add-hook 'after-init-hook 'mrf/set-diminish)

  ;; (use-package pabbrev)
#+end_src

*** Auto-complete
Auto-Complete is an intelligent auto-completion extension for Emacs. It extends the standard Emacs completion interface and provides an environment that allows users to concentrate more on their own work.

Features:

- Visual interface
- Reduce overhead of completion by using statistic method
- Extensibility
  
#+begin_src emacs-lisp :tangle no
  ;;; --------------------------------------------------------------------------
  ;; Auto Complete

  (use-package auto-complete)

  (defvar ac-directory (unless (file-exists-p "auto-complete")
                        (make-directory "auto-complete")))
  (add-to-list 'load-path ac-directory)

  (global-auto-complete-mode 1)
  (setq-default ac-sources '(ac-source-pycomplete
                             ac-source-yasnippet
                             ac-source-abbrev
                             ac-source-dictionary
                             ac-source-words-in-same-mode-buffers))

  (ac-set-trigger-key "TAB")
  (ac-set-trigger-key "<tab>")


  ;; from http://blog.deadpansincerity.com/2011/05/setting-up-emacs-as-a-javascript-editing-environment-for-fun-and-profit/
  ;; Start auto-completion after 2 characters of a word
  (setq ac-auto-start 2)
  ;; case sensitivity is important when finding matches
  (setq ac-ignore-case nil)
  
#+end_src

*** "spacious-padding"

This package provides a global minor mode to increase the spacing/padding of Emacs windows and frames. The idea is to make editing and reading feel more comfortable.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package spacious-padding
      :hook (after-init . spacious-padding-mode)
      :custom
      (spacious-padding-widths
  	'( :internal-border-width 15
             :header-line-width 4
             :mode-line-width 6
  	   :fringe-width 10
             :tab-width 4
             :right-divider-width 30
             :scroll-bar-width 8)))

  ;; Read the doc string of `spacious-padding-subtle-mode-line' as it
  ;; is very flexible and provides several examples.
  ;; (setq spacious-padding-subtle-mode-line
  ;;       `( :mode-line-active 'default
  ;;          :mode-line-inactive vertical-border))
#+end_src


* Common & Global
** Miscellaneous Settings
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (column-number-mode)

  (use-package page-break-lines
      :config
      (global-page-break-lines-mode))

  (use-package rainbow-delimiters
      :config
      (rainbow-delimiters-mode))

  (use-package dash
      :disabled
      :straight (dash
  		  :type git
  		  :flavor melpa
  		  :files ("dash.el" "dash.texi" "dash-pkg.el")
  		  :host github
  		  :repo "magnars/dash.el"))

  (defun mrf/set-fill-column-interactively (num)
      "Asks for the fill column."
      (interactive "nfill-column: ")
      (set-fill-column num))

  (defun mrf/set-org-fill-column-interactively (num)
      "Asks for the fill column for Org mode."
      (interactive "norg-fill-column: ")
      (setq custom-org-fill-column num)
      (mrf/org-mode-visual-fill)
      (redraw-display))

#+end_src

** Mac Specific
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; Macintosh specific configurations.

  (defconst *is-a-mac* (eq system-type 'darwin))
  (when (eq system-type 'darwin)
     (setq mac-option-key-is-meta nil
           mac-command-key-is-meta t
           mac-command-modifier 'meta
           mac-option-modifier 'super))
  
#+end_src

** Prompt Indicator / minibuffer
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; Prompt indicator/Minibuffer

  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
  
#+end_src

** Global key-binding
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (bind-key "C-c ]" 'indent-region prog-mode-map)
  (bind-key "C-c }" 'indent-region prog-mode-map)
  (bind-key "C-x C-j" 'dired-jump)

  (use-package evil-nerd-commenter
      :bind ("M-/" . evilnc-comment-or-uncomment-lines))

  ;;
  ;; A little better than just the typical "C-x o"
  ;; windmove is a built-in Emacs package.
  ;;
  (global-set-key (kbd "C-c <left>")  'windmove-left)
  (global-set-key (kbd "C-c <right>") 'windmove-right)
  (global-set-key (kbd "C-c <up>")    'windmove-up)
  (global-set-key (kbd "C-c <down>")  'windmove-down)

  ;;
  ;; Ctl-mouse to adjust/scale fonts will be disabled.
  ;; I personally like this since it was all to easy to accidentally
  ;; change the size of the font.
  ;;
  (global-unset-key (kbd "C-<mouse-4>"))
  (global-unset-key (kbd "C-<mouse-5>"))
  (global-unset-key (kbd "C-<wheel-down>"))
  (global-unset-key (kbd "C-<wheel-up>"))

#+end_src

** Hydra
This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra. Once you summon the Hydra through the prefixed binding (the body + any one head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head, arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his original purpose, calling his proper command. This makes the Hydra very seamless, it's like a minor mode that disables itself auto-magically.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package hydra)
  
#+end_src

** Which Key
[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run.  This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Which Key Helper

  (use-package which-key
     :diminish which-key-mode
     :custom (which-key-idle-delay 1)
     :config
     (which-key-mode)
     (which-key-setup-side-window-right))

#+end_src

** Eldoc
This package displays ElDoc documentations in a childframe. The childframe is selectable and scrollable with mouse, even though the cursor is hidden.

#+begin_src emacs-lisp

  (use-package eldoc
      :config
      (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
      (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
      (add-hook 'ielm-mode-hook 'eldoc-mode))
  
  (use-package eldoc-box
      :after eldoc
      :diminish DocBox
      :config
      (global-eldoc-mode t))
      
#+end_src

** Automatic Package Updates

The auto-package-update package helps us keep our Emacs packages up to date!  It will prompt you after a certain number of days either at startup or at a specific time of day to remind you to update your packages.

You can also use =M-x auto-package-update-now= to update right now!

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Automatic Package Updates

  (use-package auto-package-update
      :defer t
      :ensure t
      :custom
      (auto-package-update-interval 7)
      (auto-package-update-prompt-before-update t)
      (auto-package-update-hide-results t)
      :config
      (auto-package-update-maybe)
      (auto-package-update-at-time "09:00"))

#+end_src


* YASnippet

These are useful snippets of code that are commonly used in various languages. You can even create your own.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; YASnippets

  (use-package yasnippet
      :defer t
      :bind (:map yas-minor-mode-map
                ("<C-'>" . yas-expand))
      :config
      (message ">>> YASnippet Configured")
      (setq yas-global-mode t)
      (setq yas-minor-mode t)
      (define-key yas-minor-mode-map (kbd "<tab>") nil)
      (add-to-list #'yas-snippet-dirs (expand-file-name "Snippets" custom-docs-dir))
      (yas-reload-all)
      (setq yas-prompt-functions '(yas-ido-prompt))
      (defun help/yas-after-exit-snippet-hook-fn ()
  	(prettify-symbols-mode))
      (add-hook 'yas-after-exit-snippet-hook #'help/yas-after-exit-snippet-hook-fn))

#+end_src

** Yasnippet Snippets

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package yasnippet-snippets
    :after yasnippet
    :config
    (message ">>> YASnippet-Snippets Configured"))

#+end_src


* Color Theming

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (add-to-list 'custom-theme-load-path (expand-file-name "Themes" custom-docs-dir))

  (use-package ef-themes :ensure t)
  (use-package modus-themes :ensure t)
  (use-package material-theme :ensure t)
  (use-package color-theme-modern :ensure t)
  (use-package color-theme-sanityinc-tomorrow :ensure t)
  (use-package darktooth-theme :ensure t)
  (use-package zenburn-theme :ensure t)

  #+end_src

** Load a theme
Selec a theme (or themes) to load. The last one specified is the one that is used as the current theme.

** Modus (and other protesilaos) Themes

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/customize-modus-theme ()
      (message "Applying modus customization")
      (setq modus-themes-common-palette-overrides
  	'((bg-mode-line-active bg-blue-intense)
               (fg-mode-line-active fg-main)
               (border-mode-line-active blue-intense))))

  (add-hook 'after-init-hook 'mrf/customize-modus-theme)

  (defun mrf/customize-ef-theme ()
      (setq ef-themes-common-palette-overrides
  	'(  (bg-mode-line bg-blue-intense)
  	     (fg-mode-line fg-main)
  	     (border-mode-line-active blue-intense))))

  (add-hook 'after-init-hook 'mrf/customize-ef-theme)

  #+end_src

** Cycle Through Themes
Function and code to cycle through some selcted themes.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defvar loaded-theme nil
     "The text representation of the loaded custom theme.")

  (defun mrf/print-custom-theme-name ()
     (message (format "Custom theme is %S" loaded-theme)))

  (bind-keys
      ("C-= =" . mrf/load-theme-from-selector)
      ("C-= ?" . mrf/print-custom-theme-name))

#+end_src

** Selected theme
This includes the theme to use in both graphical and non-graphical.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; (add-hook 'emacs-startup-hook #'(mrf/load-theme-from-selector))
  ;; (mrf/load-theme-from-selector)
  ;; For terminal mode we choose Material theme
  (if (not (display-graphic-p))
      (progn
  	(defun load-terminal-theme ()
  	    (load-theme (intern default-terminal-theme) t))
  	(add-hook 'after-init-hook 'load-terminal-theme))
    (mrf/load-theme-from-selector))

#+end_src


* Treemacs
Treemacs is a file and project explorer similar to NeoTree or vim’s NerdTree, but largely inspired by the Project Explorer in Eclipse. It shows the file system outlines of your projects in a simple tree layout allowing quick navigation and exploration, while also possessing basic file management utilities.

** Winum
Window numbers for Emacs: Navigate your windows and frames using numbers. This is not only handy but used by Treemacs.
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Window Number

  (use-package winum
     :straight (winum :type git :flavor melpa :host github :repo "deb0ch/emacs-winum"))
  (winum-mode)
  
#+end_src

** Treemacs Config

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Treemacs

  (use-package treemacs
    :defer t
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (progn
      (setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
            treemacs-deferred-git-apply-delay        0.5
            treemacs-directory-name-transformer      #'identity
            treemacs-display-in-side-window          t
            treemacs-eldoc-display                   'simple
            treemacs-file-event-delay                2000
            treemacs-file-extension-regex            treemacs-last-period-regex-value
            treemacs-file-follow-delay               0.2
            treemacs-file-name-transformer           #'identity
            treemacs-follow-after-init               t
            treemacs-expand-after-init               t
            treemacs-find-workspace-method           'find-for-file-or-pick-first
            treemacs-git-command-pipe                ""
            treemacs-goto-tag-strategy               'refetch-index
            treemacs-header-scroll-indicators        '(nil . "^^^^^^")
            treemacs-hide-dot-git-directory          t
            treemacs-indentation                     2
            treemacs-indentation-string              " "
            treemacs-is-never-other-window           nil
            treemacs-max-git-entries                 5000
            treemacs-missing-project-action          'ask
            treemacs-move-forward-on-expand          nil
            treemacs-no-png-images                   nil
            treemacs-no-delete-other-windows         t
            treemacs-project-follow-cleanup          nil
            treemacs-persist-file                    (expand-file-name
                                                        ".cache/treemacs-persist"
                                                        user-emacs-directory)
            treemacs-position                        'left
            treemacs-read-string-input               'from-child-frame
            treemacs-recenter-distance               0.1
            treemacs-recenter-after-file-follow      nil
            treemacs-recenter-after-tag-follow       nil
            treemacs-recenter-after-project-jump     'always
            treemacs-recenter-after-project-expand   'on-distance
            treemacs-litter-directories              '("/node_modules"
                                                         "/.venv"
                                                         "/.cask"
                                                         "/__pycache__")
            treemacs-project-follow-into-home        nil
            treemacs-show-cursor                     nil
            treemacs-show-hidden-files               t
            treemacs-silent-filewatch                nil
            treemacs-silent-refresh                  nil
            treemacs-sorting                         'alphabetic-asc
            treemacs-select-when-already-in-treemacs 'move-back
            treemacs-space-between-root-nodes        t
            treemacs-tag-follow-cleanup              t
            treemacs-tag-follow-delay                1.5
            treemacs-text-scale                      nil
            treemacs-user-mode-line-format           nil
            treemacs-user-header-line-format         nil
            treemacs-wide-toggle-width               70
            treemacs-width                           38
            treemacs-width-increment                 1
            treemacs-width-is-initially-locked       t
            treemacs-workspace-switch-cleanup        nil
         )

      ;; The default width and height of the icons is 22 pixels. If you are
      ;; using a Hi-DPI display, uncomment this to double the icon size.
      ;;(treemacs-resize-icons 44)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode 'always)
      (when treemacs-python-executable
        (treemacs-git-commit-diff-mode t))

      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
         (`(t . t)
          (treemacs-git-mode 'deferred))
         (`(t . _)
          (treemacs-git-mode 'simple)))
       (treemacs-hide-gitignored-files-mode nil))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t d"   . treemacs-select-directory)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))
  
#+end_src

*** Treemacs Projectile
#+begin_src emacs-lisp :tangle no
  ;;; --------------------------------------------------------------------------

  (use-package treemacs-projectile
    :after (treemacs projectile))
  
#+end_src

*** Treemacs magit
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package treemacs-magit
    :after (treemacs magit)
     )
#+end_src

*** Treemacs dired
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package treemacs-icons-dired
     :hook (dired-mode . treemacs-icons-dired-enable-once)
     )
#+end_src

*** Treemacs Persp
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; (use-package treemacs-perspective
  ;;    :disabled
  ;;    :straight (treemacs-perspective :type git :flavor melpa
  ;;            :files ("src/extra/treemacs-perspective.el" "treemacs-perspective-pkg.el")
  ;;            :host github :repo "Alexander-Miller/treemacs")
  ;;    :after (treemacs persp-mode) ;;or perspective vs. persp-mode
  ;;    :config (treemacs-set-scope-type 'Perspectives))


  (use-package treemacs-persp ;;treemacs-perspective if you use perspective.el vs. persp-mode
     :straight (treemacs-persp :type git :flavor melpa
                :files ("src/extra/treemacs-persp.el" "treemacs-persp-pkg.el")
                :host github :repo "Alexander-Miller/treemacs")
     :after (treemacs persp-mode) ;;or perspective vs. persp-mode
     :config (treemacs-set-scope-type 'Perspectives))
#+end_src

*** Treemacs tab-bar
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
    :after (treemacs)
    :config (treemacs-set-scope-type 'Tabs))
#+end_src

*** Treemacs all-the-icons
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package treemacs-all-the-icons
      :defer t
   :if (display-graphic-p))

 #+end_src
 

* Integrated Dev Environments
The following are configured for Python development and provide an IDE type experience.  It's worth noting that Eglot/LSP can be configured for other languages. The others are Python specific. Use the =configure= system to select which one is used (=Mrf Custom Selection=).
*** Features
- context-sensitive code completion
- jump to definitions
- find references
- view documentation
- virtual environment
- eldoc mode

** EGlot
  Elgot/LSP Eglot is the Emacs client for the Language Server Protocol
  (LSP). Eglot provides infrastructure and a set of commands for enriching the
  source code editing capabilities of Emacs via LSP. Eglot itself is completely
  language-agnostic, but it can support any programming language for which there
  is a language server and an Emacs major mode.
  
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Emacs Polyglot is the Emacs LSP client that stays out of your way:

  (defvar mrf/clangd-path (executable-find "clangd")
      "Clangd executable path.")

  (defun mrf/projectile-proj-find-function (dir)
      "Find the project `DIR' function for Projectile.
  Thanks @wyuenho on GitHub"
      (let ((root (projectile-project-root dir)))
          (and root (cons 'transient root))))

  (when (equal custom-ide 'custom-ide-eglot-lsp)
      (use-package eglot
          :defer t
          :after company
          :init
          (setq company-backends
              (cons 'company-capf
                  (remove 'company-capf company-backends)))
          :hook
          (lisp-mode . eglot-ensure)
          (c-mode . eglot-ensure)
          (c++-mode . eglot-ensure)
          (python-mode . eglot-ensure)
          (prog-mode . eglot-ensure)
          (rust-mode-hook . eglot-ensure)
          :config
          (which-key-add-key-based-replacements "C-c g r" "find-symbol-reference")
          (which-key-add-key-based-replacements "C-c g o" "find-defitions-other-window")
          (which-key-add-key-based-replacements "C-c g g" "find-defitions")
          (which-key-add-key-based-replacements "C-c g ?" "eldoc-definition")
          ;; (add-hook 'eglot-managed-mode-hook #'eldoc-box-hover-at-point-mode t)
          (add-to-list 'eglot-server-programs '((c-mode c++-mode) "clangd"))
          (add-to-list 'eglot-server-programs '(python-mode . ("pylsp")))
          (add-to-list 'eglot-server-programs
              '((rust-ts-mode rust-mode) .
                   ("rust-analyzer" :initializationOptions (:check (:command "clippy")))))
          (setq-default eglot-workspace-configuration
              '((:pylsp . (:configurationSources ["flake8"]
                              :plugins (:pycodestyle (:enabled :json-false)
                                           :mccabe (:enabled :json-false)
                                           :pyflakes (:enabled :json-false)
                                           :flake8 (:enabled :json-false
                                                       :maxLineLength 88)
                                           :pydocstyle (:enabled t
                                                           :convention "numpy")
                                           :yapf (:enabled :json-false)
                                           :autopep8 (:enabled :json-false)
                                           :black (:enabled t
                                                      :line_length 88
                                                      :cache_config t))))))
          ))

#+end_src

** Language Server Protocol

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Language Server Protocol

  (when (equal custom-ide 'custom-ide-eglot-lsp)
      (eval-when-compile (defvar lsp-enable-which-key-integration)))

  (defun mrf/lsp-mode-setup ()
      "Custom LSP setup function."
      (when (equal custom-ide 'custom-ide-eglot-lsp)
          (message "Set up LSP header-line and other vars")
          (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
          (setq lsp-clangd-binary-path "/usr/bin/clangd")'
          (lsp-headerline-breadcrumb-mode)))

  (when (equal custom-ide 'custom-ide-eglot-lsp)
      (use-package lsp-mode
          :defer t
          :commands (lsp lsp-deferred)
          :hook (lsp-mode . mrf/lsp-mode-setup)
          :init
          (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
          :config
          (lsp-enable-which-key-integration t)))

  (when (equal custom-ide 'custom-ide-eglot-lsp)
      (use-package lsp-ui
          :after lsp
          :config (setq lsp-ui-sideline-enable t
                      lsp-ui-sideline-show-hover t
                      lsp-ui-sideline-delay 0.5
                      lsp-ui-sideline-ignore-duplicates t
                      lsp-ui-doc-delay 3
                      lsp-ui-doc-position 'top
                      lsp-ui-doc-alignment 'frame
                      lsp-ui-doc-header nil
                      lsp-ui-doc-show-with-cursor t
                      lsp-ui-doc-include-signature t
                      lsp-ui-doc-use-childframe t)
          :commands lsp-ui-mode
          :bind (:map lsp-ui-mode-map
                    ("C-c l d" . lsp-ui-doc-focus-frame))
          :custom
          (lsp-ui-doc-position 'bottom)
          :hook (lsp-mode . lsp-ui-mode)))

  (when (equal custom-ide 'custom-ide-eglot-lsp)
      (use-package lsp-treemacs
          :after lsp
          :bind (:map prog-mode-map
                    ("C-c t" . treemacs))
          :config
          (lsp-treemacs-sync-mode 1)))

  (when (and (equal custom-ide 'custom-ide-eglot-lsp)
           (equal completion-handler 'comphand-ivy-counsel))
      (use-package lsp-ivy
          :after lsp ivy))

#+end_src

** LSP Bridge
The goal of lsp-bridge is use multi-thread technology to implement the fastest LSP client in the Emacs ecosystem.

Advantages of lsp-bridge:

+ Blazingly fast: Offload LSP request and data analysis to an external process,  preventing Emacs from getting stuck due to delays or large data triggering  garbage collection.
   
+ Remote Completion: Built-in support for remote server code completion, with various login methods such as passwords and public keys, supports tramp protocol and jump server
  
+ Out of the box: Ready to use immediately after installation, no additional configuration required, no need to tweak with completion frontend, completion backend and multi-backend mix
  
+ Multi-server fusion: A simple JSON is all you need to combine multiple LSP Servers into one file that provides services for example Python which offers code completion with Pyright and diagnostic and formatting capabilities with Ruff
  
+ Flexible Customization: Customizing LSP server options is as simple as using a JSON file, allowing different projects to have different JSON configurations with just a few lines of rules

#+begin_src emacs-lisp :tangle no
  ;;; --------------------------------------------------------------------------

  (when (equal custom-ide 'custom-ide-lsp-bridge)
      (use-package markdown-mode)
      (use-package lsp-bridge
  	:straight '(lsp-bridge :type git :host github :repo "manateelazycat/lsp-bridge"
  		       :files (:defaults "*.el" "*.py" "acm" "core" "langserver" "multiserver" "resources")
  		       :build (:not compile))
  	:custom
  	(lsp-bridge-python-lsp-server "pylsp")
  	:config
  	(global-lsp-bridge-mode)))

#+end_src


** Anaconda-mode

Anaconda-mode provides Code navigation, documentation lookup and completion for Python.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal custom-ide 'custom-ide-anaconda)
     (use-package anaconda-mode
         :bind (:map python-mode-map
    		 ("C-c g o" . anaconda-mode-find-definitions-other-frame)
    		 ("C-c g g" . anaconda-mode-find-definitions)
  		 ("C-c C-x" . next-error))        
         :config
         (which-key-add-key-based-replacements "C-c g o" "find-defitions-other-window")
         (which-key-add-key-based-replacements "C-c g g" "find-defitions")
         (require 'pyvenv)
         :hook
         (python-mode-hook . anaconda-eldoc-mode)))

#+end_src

** ELPY
Elpy is an Emacs package to bring powerful Python editing to Emacs.  It combines and configures a number of other packages, both written in Emacs Lisp as well as Python.  Elpy is fully documented at [[https://elpy.readthedocs.io/en/latest/index.html][read the docs]].

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal custom-ide 'custom-ide-elpy)
      (use-package elpy
          :after python
          :custom
          (elpy-rpc-python-command "python3")
          (display-fill-column-indicator-mode 1)
  	(highlight-indentation-mode nil)
  	:bind (:map python-mode-map
  		  ("C-c g a" . elpy-goto-assignment)
  		  ("C-c g o" . elpy-goto-definition-other-window)
  		  ("C-c g g" . elpy-goto-definition)
  		  ("C-c g ?" . elpy-doc))
  	:config
  	(message "elpy loaded")
  	(use-package jedi)
  	(which-key-add-key-based-replacements "C-c g a" "goto-assignment")
  	(which-key-add-key-based-replacements "C-c g o" "find-defitions-other-window")
  	(which-key-add-key-based-replacements "C-c g g" "find-defitions")
  	(which-key-add-key-based-replacements "C-c g ?" "eldoc-definition")
  	(elpy-enable))
      ;; Enable Flycheck
      (use-package flycheck
  	:after elpy
  	:straight (flycheck :type git :flavor melpa
                        :host github
                        :repo "flycheck/flycheck")
  	:config
  	(setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  	:hook (elpy-mode . flycheck-mode)))

#+end_src


* Debugging
** Debug Adapter Protocol for Emacs (DAPE)
#+begin_src emacs-lisp
    ;;; ------------------------------------------------------------------------
    ;;; Alternate fork to handle possible performance bug(s)
  (use-package jsonrpc
      :straight (jsonrpc :type git :host github :repo "emacs-straight/jsonrpc" :files ("*" (:exclude ".git"))))

  (when (equal debug-adapter 'enable-dape)
      (use-package dape
          :after jsonrpc
          :defer t
          ;; :defer t
          ;; To use window configuration like gud (gdb-mi)
          ;; :init
          ;; (setq dape-buffer-window-arrangement 'gud)
          :custom
          (dape-buffer-window-arrangement 'right)  ;; Info buffers to the right
          ;; To not display info and/or buffers on startup
          ;; (remove-hook 'dape-on-start-hooks 'dape-info)
          (remove-hook 'dape-on-start-hooks 'dape-repl)

          ;; To display info and/or repl buffers on stopped
          ;; (add-hook 'dape-on-stopped-hooks 'dape-info)
          ;; (add-hook 'dape-on-stopped-hooks 'dape-repl)

          ;; By default dape uses gdb keybinding prefix
          ;; If you do not want to use any prefix, set it to nil.
          ;; (setq dape-key-prefix "\C-x\C-a")

          ;; Kill compile buffer on build success
          ;; (add-hook 'dape-compile-compile-hooks 'kill-buffer)

          ;; Save buffers on startup, useful for interpreted languages
          ;; (add-hook 'dape-on-start-hooks
          ;;           (defun dape--save-on-start ()
          ;;             (save-some-buffers t t)))

          :config
          ;; Projectile users
          ;; (setq dape-cwd-fn 'projectile-project-root)
          ;; :straight (dape :type git
          ;;           :host github :repo "emacs-straight/dape"
          ;;           :files ("*" (:exclude ".git")))
          (message "DAPE Configured")))

#+end_src

** Debug Adapter Protocol (DAP)

Provides a common protocol for debugging different systems. This is configured for Python

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Debug Adapter Protocol      
  (when (equal debug-adapter 'enable-dap-mode)
      (use-package dap-mode
          ;; Uncomment the config below if you want all UI panes to be hidden by default!
          ;; :custom
          ;; (lsp-enable-dap-auto-configure nil)
          :commands dap-debug
          :custom
          (dap-auto-configure-features '(sessions locals breakpoints expressions repl controls tooltip))
          :config
          (dap-ui-mode 1)
          (message "DAP mode loaded and configured.")))

 #+end_src
** Dape for TypeScript

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (setq mrf/vscode-js-debug-dir (file-name-concat user-emacs-directory "dape/vscode-js-debug"))

  (defun mrf/install-vscode-js-debug ()
     "Run installation procedure to install JS debugging support"
     (interactive)
     (mkdir mrf/vscode-js-debug-dir t)
     (let ((default-directory (expand-file-name mrf/vscode-js-debug-dir)))
         
        (vc-git-clone "https://github.com/microsoft/vscode-js-debug.git" "." nil)
        (message "git repository created")
        (call-process "npm" nil "*snam-install*" t "install")
        (message "npm dependencies installed")
        (call-process "npx" nil "*snam-install*" t "gulp" "dapDebugServer")
        (message "vscode-js-debug installed")))
  
#+end_src

*** Run This Only Once!

This is meant to be evaluated and run once. Calling this function will clone the vscode-js-debug framework. This is a DAP-based JavaScript debugger. It debugs Node.js, Chrome, Edge, WebView2, VS Code extensions, and more. It has been the default JavaScript debugger in Visual Studio Code since 1.46, and is gradually rolling out in Visual Studio proper.

#+begin_src emacs-lisp :tangle no 
  ;;; --------------------------------------------------------------------------

  (mrf/install-vscode-js-debug)
  
#+end_src

#+RESULTS:
: vscode-js-debug installed

** DAPE Hydra

#+begin_src emacs-lisp :results none
  ;;; --------------------------------------------------------------------------
  
  (defun mrf/dape-end-debug-session ()
     "End the debug session."
     (interactive)
     (dape-quit))

  (defun mrf/dape-delete-all-debug-sessions ()
     "End the debug session and delete all breakpoints."
     (interactive)
     (dape-breakpoint-remove-all)
     (mrf/dape-end-debug-session))

  (defhydra dape-hydra (:color pink :hint nil :foreign-keys run)
     "
    ^Stepping^          ^Switch^                 ^Breakpoints^          ^Debug^                     ^Eval
    ^^^^^^^^----------------------------------------------------------------------------------------------------------------
    _._: Next           _st_: Thread            _bb_: Toggle           _dd_: Debug                 _ee_: Eval Expression
    _/_: Step in        _si_: Info              _bd_: Delete           _dw_: Watch dwim
    _,_: Step out       _sf_: Stack Frame       _ba_: Add              _dx_: end session
    _c_: Continue       _su_: Up stack frame    _bc_: Set condition    _dX_: end all sessions
    _r_: Restart frame  _sd_: Down stack frame  _bl_: Set log message
    _Q_: Disconnect     _sR_: Session Repl
                        _sU_: Info Update

  "
           ("n" dape-next)
           ("i" dape-step-in)
           ("o" dape-step-out)
           ("." dape-next)
           ("/" dape-step-in)
           ("," dape-step-out)
           ("c" dape-continue)
           ("r" dape-restart)
           ("si" dape-info)
           ("st" dape-select-thread)
           ("sf" dape-select-stack)
           ("su" dape-stack-select-up)
           ("sU" dape-info-update)
           ("sd" dape-stack-select-down)
           ("sR" dape-repl)
           ("bb" dape-breakpoint-toggle)
           ("ba" dape--breakpoint-place)
           ("bd" dape-breakpoint-remove-at-point)
           ("bc" dape-breakpoint-expression)
           ("bl" dape-breakpoint-log)
           ("dd" dape)
           ("dw" dape-watch-dwim)
           ("ee" dape-evaluate-expression)
           ("dx" mrf/dape-end-debug-session)
           ("dX" mrf/dape-delete-all-debug-sessions)
           ("x" nil "exit Hydra" :color yellow)
           ("q" mrf/dape-end-debug-session "quit" :color blue)
           ("Q" mrf/dape-delete-all-debug-sessions :color red))  

 #+end_src

** DAP for C/C++
#+begin_src emacs-lisp :tangle no
  ;;; --------------------------------------------------------------------------

  (setq dap-lldb-debug-program
      "/Users/strider/Developer/plain_unix/llvm-project/build/bin/lldb-dap")

  (defun mrf/populate-lldb-start-file-args (conf)
      "Populate CONF with the required arguments."
      (-> conf
          (dap--put-if-absent :dap-server-path dap-lldb-debug-program)
          (dap--put-if-absent :type "lldb-dap")
          (dap--put-if-absent :cwd default-directory)
          (dap--put-if-absent :program (funcall dap-lldb-debugged-program-function))
          (dap--put-if-absent :name "LLDB Debug")))

  (when (equal debug-adapter 'enable-dap-mode)
      (use-package dap-cpptools
          :after dap-mode
          :straight (dap-lldb :type git :host github :repo "emacs-lsp/dap-mode"))

      (use-package dap-lldb
          :straight (dap-lldb :type git :host github :repo "emacs-lsp/dap-mode")
          :after dap-mode
          :config
          (dap-register-debug-provider "lldb-dap" 'mrf/populate-lldb-start-file-args)
          (dap-register-debug-template "LLDB DAP :: Run from project directory"
              (list :type "lldb-dap"
                  :name "LLDB using DAP"
                  :program "a.out"
                  :request "launch"))))
#+end_src

** DAP for Python

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; DAP for Python

  (when (equal debug-adapter 'enable-dap-mode)
      (use-package dap-python
  	:straight (dap-python :type git :host github :repo "emacs-lsp/dap-mode")
  	:after (dap-mode)
  	:config
  	(setq dap-python-executable "python3") ;; Otherwise it looks for 'python' else error.
  	(setq dap-python-debugger 'debugpy)
  	(dap-register-debug-template "Python :: Run file from project directory"
              (list :type "python"
  		:args ""
  		:cwd nil
  		:module nil
  		:program nil
  		:request "launch"))
  	(dap-register-debug-template "Python :: Run file (buffer)"
              (list :type "python"
  		:args ""
  		:cwd nil
  		:module nil
  		:program nil
  		:request "launch"
  		:name "Python :: Run file (buffer)"))))

#+end_src

** DAP Template for NodeJS
#+begin_src emacs-lisp :tangle no
  ;;; --------------------------------------------------------------------------
  ;;; DAP for NodeJS

  (defun my-setup-dap-node ()
      "Require dap-node feature and run dap-node-setup if VSCode module isn't already installed"
      (require 'dap-node)
      (unless (file-exists-p dap-node-debug-path) (dap-node-setup)))

  (when (equal debug-adapter 'enable-dap-mode)
      (use-package dap-node
          :defer t
          :straight (dap-node :type git
                        :flavor melpa
                        :files (:defaults "icons" "dap-mode-pkg.el")
                        :host github
                        :repo "emacs-lsp/dap-mode")
          :after (dap-mode)
          :config
          (require 'dap-firefox)
          (dap-register-debug-template
              "Launch index.ts"
              (list :type "node"
  		:request "launch"
  		:program "${workspaceFolder}/index.ts"
  		:dap-compilation "npx tsc index.ts --outdir dist --sourceMap true"
  		:outFiles (list "${workspaceFolder}/dist/**/*.js")
  		:name "Launch index.ts"))
          ;; (dap-register-debug-template
          ;;    "Launch index.ts"
          ;;    (list :type "node"
          ;;    :request "launch"
          ;;    :program "${workspaceFolder}/index.ts"
          ;;    :dap-compilation "npx tsc index.ts --outdir dist --sourceMap true"
          ;;    :outFiles (list "${workspaceFolder}/dist/**/*.js")
          ;;    :name "Launch index.ts"))
          )
      (add-hook 'typescript-mode-hook 'my-setup-dap-node)
      (add-hook 'js2-mode-hook 'my-setup-dap-node))
#+end_src

** DAP Hydra

#+begin_src emacs-lisp :results none
  ;;; --------------------------------------------------------------------------

  (defun mrf/end-debug-session ()
     "End the debug session and delete project Python buffers."
     (interactive)
     (kill-matching-buffers "\*Python :: Run file [from|\(buffer]*" nil :NO-ASK)
     (kill-matching-buffers "\*Python: Current File*" nil :NO-ASK)
     (kill-matching-buffers "\*dap-ui-*" nil :NO-ASK)
     (dap-disconnect (dap--cur-session)))

  (defun mrf/delete-all-debug-sessions ()
     "End the debug session and delete project Python buffers and all breakpoints."
     (interactive)
     (dap-breakpoint-delete-all)
     (mrf/end-debug-session))

  (defun mrf/begin-debug-session ()
     "Begin a debug session with several dap windows enabled."
     (interactive)
     (dap-ui-show-many-windows)
     (dap-debug))

  (defhydra dap-hydra (:color pink :hint nil :foreign-keys run)
     "
    ^Stepping^          ^Switch^                 ^Breakpoints^          ^Debug^                     ^Eval
    ^^^^^^^^----------------------------------------------------------------------------------------------------------------
    _._: Next           _ss_: Session            _bb_: Toggle           _dd_: Debug                 _ee_: Eval
    _/_: Step in        _st_: Thread             _bd_: Delete           _dr_: Debug recent          _er_: Eval region
    _,_: Step out       _sf_: Stack frame        _ba_: Add              _dl_: Debug last            _es_: Eval thing at point
    _c_: Continue       _su_: Up stack frame     _bc_: Set condition    _de_: Edit debug template   _ea_: Add expression.
    _r_: Restart frame  _sd_: Down stack frame   _bh_: Set hit count    _ds_: Debug restart
    _Q_: Disconnect     _sl_: List locals        _bl_: Set log message  _dx_: end session
                      _sb_: List breakpoints                          _dX_: end all sessions
                      _sS_: List sessions
                      _sR_: Session Repl
  "
      ("n" dap-next)    ("i" dap-step-in)    ("o" dap-step-out)   ("." dap-next)
      ("/" dap-step-in) ("," dap-step-out)   ("c" dap-continue)   ("r" dap-restart-frame)
      
      ("ss" dap-switch-session) ("st" dap-switch-thread)    ("sf" dap-switch-stack-frame)
      ("su" dap-up-stack-frame) ("sd" dap-down-stack-frame) ("sl" dap-ui-locals)
      ("sb" dap-ui-breakpoints) ("sR" dap-ui-repl)          ("sS" dap-ui-sessions)
      
      ("bb" dap-breakpoint-toggle)    ("ba" dap-breakpoint-add)           ("bd" dap-breakpoint-delete)
      ("bc" dap-breakpoint-condition) ("bh" dap-breakpoint-hit-condition) ("bl" dap-breakpoint-log-message)
      
      ("dd" dap-debug)      ("dr" dap-debug-recent) ("ds" dap-debug-restart)
      ("dl" dap-debug-last) ("de" dap-debug-edit-template)
      
      ("ee" dap-eval) ("ea" dap-ui-expressions-add) ("er" dap-eval-region) ("es" dap-eval-thing-at-point)
      
      ("dx" mrf/end-debug-session) ("dX" mrf/delete-all-debug-sessions)
      
      ("x" nil "exit Hydra" :color yellow) ("q" mrf/end-debug-session "quit" :color blue)
      ("Q" mrf/delete-all-debug-sessions :color red))  

 #+end_src


* Completion Systems
Here are a series of completion systems that are available for Emacs.

** IVY Mode
Ivy is an excellent completion framework for Emacs.  It provides a minimal yet powerful selection menu that appears when you open files, switch buffers, and for many other tasks in Emacs.  Counsel is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide useful commands for each of the default completion commands.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;;; Swiper and IVY mode

  (when (equal completion-handler 'comphand-ivy-counsel)
      (use-package ivy
  	:diminish I
  	:bind (("C-s" . swiper)
  		  :map ivy-minibuffer-map
            ;;; ("TAB" . ivy-alt-done)
  		  ("C-l" . ivy-alt-done)
  		  ("C-j" . ivy-next-line)
  		  ("C-k" . ivy-previous-line)
  		  :map ivy-switch-buffer-map
  		  ("C-k" . ivy-previous-line)
  		  ("C-l" . ivy-done)
  		  ("C-d" . ivy-switch-buffer-kill)
  		  :map ivy-reverse-i-search-map
  		  ("C-k" . ivy-previous-line)
  		  ("C-d" . ivy-reverse-i-search-kill))
  	:custom (ivy-use-virtual-buffers t)
  	:config
  	(ivy-mode 1))

      (use-package ivy-rich
  	:after ivy
  	:init
  	(ivy-rich-mode 1)
  	:config
  	(setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line))

      (use-package ivy-yasnippet
  	:straight (ivy-yasnippet :type git
  		      :flavor melpa :host github
  		      :repo "mkcms/ivy-yasnippet")))

#+end_src

*** Swiper
Swiper is an alternative to isearch that uses Ivy to show an overview of all matches.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal completion-handler 'comphand-ivy-counsel)
      (use-package swiper))

#+end_src

*** Counsel

~ivy-mode~ ensures that any Emacs command using completing-read-function uses ivy for completion.
Counsel takes this further, providing versions of common Emacs commands that are customised to make the best use of Ivy. For example, ~counsel-find-file~ has some additional keybindings. Pressing =DEL= will move you to the parent directory.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal completion-handler 'comphand-ivy-counsel)
      (use-package counsel
  	:straight t
  	:bind (("C-M-j" . 'counsel-switch-buffer)
  		  :map minibuffer-local-map
  		  ("C-r" . 'counsel-minibuffer-history))
  	:custom
  	(counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  	:config
  	(counsel-mode 1)))

#+end_src

*** Ivy Prescient
~prescient.el~ is a library which sorts and filters lists of candidates, such as appear when you use a package like =Ivy= or =Company=.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal completion-handler 'comphand-ivy-counsel)
      (use-package ivy-prescient
  	:after counsel
  	:custom
  	(ivy-prescient-enable-filtering nil)
  	:config
  	(prescient-persist-mode 1)
  	(ivy-prescient-mode 1)))

#+end_src

** Corfu
Corfu enhances in-buffer completion with a small completion popup. The current candidates are shown in a popup below or above the point. The candidates can be selected by moving up and down. Corfu is the minimalistic in-buffer completion counterpart of the Vertico minibuffer UI.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;;;; Code Completion
  (when enable-corfu
      (use-package corfu
  	;; Optional customizations
  	:custom
  	(corfu-cycle t)                 ; Allows cycling through candidates
  	(corfu-auto t)                  ; Enable auto completion
  	(corfu-auto-prefix 2)
  	(corfu-auto-delay 0.8)
  	(corfu-popupinfo-delay '(0.5 . 0.2))
  	(corfu-preview-current 'insert) ; insert previewed candidate
  	(corfu-preselect 'prompt)
  	(corfu-on-exact-match nil)      ; Don't auto expand tempel snippets
  	;; Optionally use TAB for cycling, default is `corfu-complete'.
  	:bind (:map corfu-map
  		  ("M-SPC"      . corfu-insert-separator)
  		  ("TAB"        . corfu-next)
  		  ([tab]        . corfu-next)
  		  ("S-TAB"      . corfu-previous)
  		  ([backtab]    . corfu-previous)
  		  ("S-<return>" . corfu-insert)
  		  ("RET"        . nil))
  	:init
  	(global-corfu-mode)
  	(corfu-history-mode)
  	(corfu-popupinfo-mode) ; Popup completion info
  	:config
  	(add-hook 'eshell-mode-hook
  	    (lambda () (setq-local corfu-quit-at-boundary t
                        corfu-quit-no-match t
                        corfu-auto nil)
  		(corfu-mode))))
      (use-package corfu-prescient
  	:after corfu)
      )

#+end_src


* Tree-sitter
Tree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source file and efficiently update the syntax tree as the source file is edited. Tree-sitter aims to be:

- General enough to parse any programming language
- Fast enough to parse on every keystroke in a text editor
- Robust enough to provide useful results even in the presence of syntax errors
- Dependency-free so that the runtime library (which is written in pure C) can be embedded in any application
  
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/tree-sitter-setup ()
     (tree-sitter-hl-mode t)
     (ts-fold-mode t))

  (use-package tree-sitter
     :init
     (message ">>> Loading tree-sitter")
     ;; :after (lsp-mode)
     :config
     ;; Activate tree-sitter globally (minor mode registered on every buffer)
     (global-tree-sitter-mode)
     :hook
     (tree-sitter-after-on . mrf/tree-sitter-setup)
     (typescript-mode . lsp-deferred)
     (c-mode . lsp-deferred)
     (c++-mode . lsp-deferred)
     (js2-mode . lsp-deferred))

  (use-package tree-sitter-langs)

  (use-package ts-fold
     :straight (ts-fold :type git
                :host github
                :repo "emacs-tree-sitter/ts-fold")
      :bind (("C-<tab>" . ts-fold-toggle)
  	   ("C-c f"   . ts-fold-open-all)))

#+end_src


* Other Language Support
** Typescript
This is a basic configuration for the TypeScript language so that =.ts= files activate =typescript-ts-mode= when opened.  We're also adding a hook to =typescript-mode-hook= to call =lsp-deferred= so that we activate =lsp-mode= to get LSP features every time we edit TypeScript code.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal debug-adapter 'enable-dap-mode)
      (use-package typescript-ts-mode
  	;; :after (dap-mode)
  	:mode "\\.ts\\'"
  	:hook
  	(typescript-ts-mode . lsp-deferred)
  	(js2-mode . lsp-deferred)
  	(rust-mode . lsp-deferred)
  	:bind (:map typescript-mode-map
  		  ("C-c ." . dap-hydra/body))
  	:config
  	(setq typescript-indent-level 4)
  	(dap-node-setup)))

  (when (equal debug-adapter 'enable-dape)
      (use-package typescript-ts-mode
  	:after (dape-mode)
  	:mode ("\\.ts\\'")
  	:hook
  	(typescript-ts-mode . lsp-deferred)
  	(js2-mode . lsp-deferred)
  	(rust-mode . lsp-deferred)
  	:bind (:map typescript-mode-map
  		  ("C-c ." . dape-hydra/body))
  	:config
  	(setq typescript-indent-level 4)))

  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))

#+end_src

** NodeJS
#+begin_src emacs-lisp :tangle no 
  ;;; --------------------------------------------------------------------------

  (defun mrf/load-js-file-hook ()
      (message "Running JS file hook")
      (js2-mode)
      
      (when (equal debug-adapter 'enable-dap-mode)
  	(dap-mode)
  	(dap-firefox-setup))
      
      (when (equal debug-adapter 'enable-dape)
  	(dape))

      (highlight-indentation-mode nil)
      (dap-firefox-setup))

  (use-package nodejs-repl)

  (defun mrf/nvm-which ()
      (let ((output (shell-command-to-string "source ~/.nvm/nvm.sh; nvm which")))
  	(cadr (split-string output "[\n]+" t))))

  (setq nodejs-repl-command #'mrf/nvm-which)

#+end_src

** JavaScript
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package js2-mode
     :hook (js-mode . js2-minor-mode)
      :bind (:map js2-mode-map
                ("{" . paredit-open-curly)
  	      ("}" . paredit-close-curly-and-newline))
     :mode ("\\.js\\'" "\\.mjs\\'")
     :custom (js2-highlight-level 3))

  (use-package ac-js2
     :hook (js2-mode . ac-js2-mode))

  (add-to-list 'auto-mode-alist '("\\.json$" . js-mode))

#+end_src

** C/C++
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/load-c-file-hook ()
      (message "Running C/C++ file hook")
      (c-mode)
      (unless (featurep 'realgud))
  	(use-package realgud)
      (highlight-indentation-mode nil)
      (display-fill-column-indicator-mode t))

  (defun code-compile ()
      "Look for a Makefile and compiles the code with gcc/cpp."
      (interactive)
      (unless (file-exists-p "Makefile")
  	(set (make-local-variable 'compile-command)
  	    (let ((file (file-name-nondirectory buffer-file-name)))
  		(format "%s -o %s %s"
  		    (if  (equal (file-name-extension file) "cpp") "g++" "gcc" )
  		    (file-name-sans-extension file)
  		    file)))
  	(compile compile-command)))

  (global-set-key [f9] 'code-compile)
  (add-to-list 'auto-mode-alist '("\\.c\\'" . mrf/load-c-file-hook))

#+end_src

** Additional Languages
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; (use-package graphql-mode)
  (use-package js2-mode :defer t)
  (use-package rust-mode :defer t)
  (use-package swift-mode :defer t)
  
#+end_src

** Flycheck
This is more support for a language rather than a langage itself

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package flycheck
      :defer t
      :config
      (global-flycheck-mode))

  (use-package flycheck-package
      :after flycheck)

  (eval-after-load 'flycheck
    '(flycheck-package-setup))

  (defun mrf/before-save ()
    "Force the check of the current python file being saved."
    (when (eq major-mode 'python-mode) ;; Python Only
       (flycheck-mode 0)
       (flycheck-mode t)
       (message "deleting trailing whitespace enabled")
       (delete-trailing-whitespace)))

  (add-hook 'before-save-hook 'mrf/before-save)
#+end_src


* Python
** IMPORTANT
Before any work can begin in python, make sure that the right packages are installed.

#+begin_src shell :results output silent

  pip3 install --upgrade pip
  pip3 install "python-lsp-server[all]"
  pip3 install debugpy
  
#+end_src

In addition to that, it is important that =autopep8=, which is a script, can reach python or python3. For my configuration, =autopep8= looks for python this like this:

: #!/Library/Frameworks/Python.framework/Versions/Current/bin/python3 :

*Note:* If this python path doesn't exist, you will see the very annoying

: file-missing "Doing vfork" "No such file or directory" :
message

** Specialized python-mode Keymaps
The following are keymaps that are used by by the custom-ide and for python-mode

#+begin_src emacs-lisp

  (defun mrf/set-custom-ide-python-keymaps ()
      (message "<<< Set python-mode keymaps based upon IDE.")
      (cond
          ((equal custom-ide 'custom-ide-eglot-lsp)
              (unless (featurep 'lsp)
                  (lsp-deferred))
              (unless (featurep 'eglot)
                  (eglot))
              (bind-keys :map python-mode-map
                  ("C-c g r" . lsp-find-references)
                  ("C-c g o" . xref-find-definitions-other-window)
                  ("C-c g g" . xref-find-definitions)
                  ("C-c g ?" . eldoc-doc-buffer))
              (message (format ">>> set python-mode-map for %s" custom-ide)))
          ;; Activate LSP and EGLOT *if* selected as custom-ide
          ((equal custom-ide 'custom-ide-elpy)
              (elpy-enable)
              (bind-keys :map python-mode-map
                  ("C-c g a" . elpy-goto-assignment)
                  ("C-c g o" . elpy-goto-definition-other-window)
                  ("C-c g g" . elpy-goto-definition)
                  ("C-c g ?" . elpy-doc))
              (message (format ">>> setting python-mode-map for %s" custom-ide)))
          ((equal custom-ide 'custom-ide-lsp-bridge)
              (bind-keys :map python-mode-map
                  ("C-c g a" . lsp-bridge-find-reference)
                  ("C-c g o" . lsp-bridge-find-def-other-window)
                  ("C-c g g" . lsp-bridge-find-def)
                  ("C-c g i" . lsp-bridge-find-impl)
                  ("C-c g r" . lsp-bridge-rename)
                  ("C-c g ?" . lsp-bridge-popup-documentation))
  	    (message (format ">>> set python-mode-map for %s" custom-ide)))
  	))


#+end_src

** Standard setup
This is the standard python mode setup.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/load-python-file-hook ()
      (python-mode)
      ;; (unless (featurep 'jedi)
      ;; 	(use-package jedi
      ;; 	    :config
      ;; 	    (jedi:setup)))
      (setq highlight-indentation-mode -1)
      (setq display-fill-column-indicator-mode t))

  (defun mrf/python-mode-triggered ()
      (message ">>> mrf/python-mode-triggered")
      ;; (eldoc-box-hover-at-point-mode t) ;; Using Mitch Key for this
      (if (equal debug-adapter 'enable-dap-mode)
  	(unless (featurep 'dap-mode)
  	    (dap-mode))
  	(if (not (featurep 'dape))
              (use-package dape :demand t)))
      (mrf/set-custom-ide-python-keymaps)
      (set-fill-column 80))

  (use-package python-mode
      :defer t
      :hook (python-mode . mrf/python-mode-triggered) )

  (add-to-list 'auto-mode-alist '("\\.py\\'" . mrf/load-python-file-hook))

  (use-package blacken
      :after python) ;Format Python file upon save.

  (if (boundp 'python-shell-completion-native-disabled-interpreters)
      (add-to-list 'python-shell-completion-native-disabled-interpreters "python3")
      (setq python-shell-completion-native-disabled-interpreters '("python3")))

#+end_src

** Auto-pep 8
autopep8 automatically formats Python code to conform to the `PEP 8` style guide.  It uses the pycodestyle_ utility to determine what parts of the code needs to be formatted.  autopep8 is capable of fixing most of the formatting issues_ that can be reported by pycodestyle. Refer to the [[IMPORTANT][IMPORTANT]] section above for possible issues when autopep8 is installed.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package py-autopep8
     :after (python-mode python)
     :hook ((python-mode) . py-autopep8-mode))
  
#+end_src

** Python Keybinding
**** Helpful Macros
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; This is a helpful macro that is used to put double quotes around a word.
  (defalias 'quote-word
     (kmacro "\" M-d \" <left> C-y"))

  (defalias 'quote-region
     (kmacro "C-w \" \" <left> C-y <right>"))

  (eval-after-load "python"
      #'(bind-keys :map python-mode-map
  	  ("C-c C-q" . quote-region)
  	  ("C-c q"   . quote-word)
  	  ("C-c |"   . display-fill-column-indicator-mode)))
    
#+end_src

**** Debuggers
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal debug-adapter 'enable-dap-mode)
      ;; (dolist (m (list python-mode-map typescript-ts-mode-map c-mode-map c++-mode-map))
      (use-package dap
  	:defer t
  	:bind (:map prog-mode-map
  		  ("C-c ." . dap-hydra/body))))

  (when (equal debug-adapter 'enable-dape)
      ;; (dolist (m (list python-mode-map typescript-ts-mode-map c-mode-map c++-mode-map))
      (use-package dape
  	:defer t
  	:bind (:map prog-mode-map
  		  ("C-c ." . dape-hydra/body))))

#+end_src

** Python Virtual Environment Support
We use Pyvenv-auto is a package that automatically changes to the Python virtual environment based upon the project's directory.  pyvenv-auto looks at the root director of the project for a =.venv= or =venv= (and a few others)

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package pyvenv-auto
     :after python
     :config (message ">>> Starting pyvenv-auto")
     :hook (python-mode . pyvenv-auto-run))
  
#+end_src

** Pydoc
#Pydoc, the Python documentation navigation package
#+begin_src emacs-lisp

  (use-package pydoc
      :straight (pydoc :type git :flavor melpa
  		    :host github :repo "statmobile/pydoc")
      :after python
      :custom
      (pydoc-python-command "python3")
      (pydoc-pip-version-command "pip3 --version")
      )

#+end_src


* RealGUD
Since Realgud is options (in our configuratrion), we add it's keybindings conditionally. *Note* that these keybindings are still compatible with =dap-mode= keybindings.
#+begin_src emacs-lisp :tangle no

  ;;; --------------------------------------------------------------------------

  (use-package realgud
      :after c-mode
      :defer t)

  (use-package realgud-lldb
      :after realgud
      :straight (realgud-lldb
  		  :type git
  		  :flavor melpa
  		  :files (:defaults ("lldb" "lldb/*.el") "realgud-lldb-pkg.el")
  		  :host github
  		  :repo "realgud/realgud-lldb"))

#+end_src

** REALGud Keybindings
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (package-installed-p 'realgud)
      (use-package cc-mode
  	:bind (:map c-mode-map
  		  ("C-c , j" . realgud:cmd-jump)
  		  ("C-c , k" . realgud:cmd-kill)
  		  ("C-c , s" . realgud:cmd-step)
  		  ("C-c , n" . realgud:cmd-next)
  		  ("C-c , q" . realgud:cmd-quit)
  		  ("C-c , F" . realgud:window-bt)
  		  ("C-c , U" . realgud:cmd-until)
  		  ("C-c , X" . realgud:cmd-clear)
  		  ("C-c , !" . realgud:cmd-shell)
  		  ("C-c , b" . realgud:cmd-break)
  		  ("C-c , f" . realgud:cmd-finish)
  		  ("C-c , D" . realgud:cmd-delete)
  		  ("C-c , +" . realgud:cmd-enable)
  		  ("C-c , R" . realgud:cmd-restart)
  		  ("C-c , -" . realgud:cmd-disable)
  		  ("C-c , B" . realgud:window-brkpt)
  		  ("C-c , c" . realgud:cmd-continue)
  		  ("C-c , e" . realgud:cmd-eval-dwim)
  		  ("C-c , Q" . realgud:cmd-terminate)
  		  ("C-c , T" . realgud:cmd-backtrace)
  		  ("C-c , h" . realgud:cmd-until-here)
  		  ("C-c , u" . realgud:cmd-older-frame)
  		  ("C-c , 4" . realgud:cmd-goto-loc-hist-4)
  		  ("C-c , 5" . realgud:cmd-goto-loc-hist-5)
  		  ("C-c , 6" . realgud:cmd-goto-loc-hist-6)
  		  ("C-c , 7" . realgud:cmd-goto-loc-hist-7)
  		  ("C-c , 8" . realgud:cmd-goto-loc-hist-8)
  		  ("C-c , 9" . realgud:cmd-goto-loc-hist-9)
  		  ("C-c , d" . realgud:cmd-newer-frame)
  		  ("C-c , RET" . realgud:cmd-repeat-last)
  		  ("C-c , E" . realgud:cmd-eval-at-point)
  		  ("C-c , I" . realgud:cmdbuf-info-describe)
  		  ("C-c , C-i" . realgud:cmd-info-breakpoints))))

#+end_src


* GameBoy Development
RGBDS is a compiler that has been around quite a long time (since 1997). It supports Z80 and the LR35902 assembler syntaxes that are used in the development of Game Boy and Game Boy color games.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when enable-gb-dev
      (use-package z80-mode
  	:straight (z80-mode
                        :type git
                        :host github
                        :repo "SuperDisk/z80-mode"))

      (use-package mwim
  	:straight (mwim
                        :type git
                        :flavor melpa
                        :host github
                        :repo "alezost/mwim.el"))

      (use-package rgbds-mode
  	:after mwim
  	:straight (rgbds-mode
                        :type git :host github
                        :repo "japanoise/rgbds-mode")))

#+end_src



* Company Mode
[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than =completion-at-point= which is more reminiscent of what you would expect from an IDE.  We add a simple configuration to make the keybindings a little more useful (=TAB= now completes the selection and initiates completion at the current location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with icons and better overall presentation.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal custom-ide 'custom-ide-eglot-lsp)
      (use-package company
  	:after lsp-mode
  	:hook (lsp-mode . company-mode)
  	:bind (:map company-active-map
  		  ("<tab>" . company-complete-selection))
  	      (:map lsp-mode-map
  		  ("<tab>" . company-indent-or-complete-common))))

  (when (equal custom-ide 'custom-ide-elpy)
      (use-package company
  	:after elpy
  	:hook (elpy-mode . company-mode)
  	:bind (:map company-active-map
  		  ("<tab>" . company-complete-selection))
                (:map elpy-mode-map
  		  ("<tab>" . company-indent-or-complete-common))))

  (when (equal custom-ide 'custom-ide-anaconda)
      (use-package company
  	:after anaconda-mode
  	:hook (anaconda-mode . company-mode)
  	:bind (:map company-active-map
  		  ("<tab>" . company-complete-selection))
  	      (:map elpy-mode-map
  		  ("<tab>" . company-indent-or-complete-common))))

  ;; Don't use company at all if lsp-bridge is active.
  ;; lsp-bridge already provides similar functionality.
  (unless (equal custom-ide 'custom-ide-lsp-bridge)
      (use-package company
  	:custom
  	(company-minimum-prefix-length 1)
  	(company-idle-delay 0.0)
  	:hook (after-init . global-company-mode)))
          ;; :config
          ;; (add-to-list 'company-backends 'company-yasnippet))

#+end_src

** Company Packages
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (featurep 'company)
      (use-package company-box
  	:diminish cb
  	:hook (company-mode . company-box-mode))

      (when (equal custom-ide 'custom-ide-elpy)
  	(use-package company-jedi
  	    :after python
  	    :config
  	    (jedi:setup)
  	    (defun my/company-jedi-python-mode-hook ()
  		(add-to-list 'company-backends 'company-jedi))
  	    (add-hook 'python-mode-hook 'my/company-jedi-python-mode-hook)))

      (when (equal custom-ide 'custom-ide-anaconda)
  	(use-package company-anaconda
  	    :after anaconda
  	    :hook (python-mode . anaconda-mode))
  	(eval-after-load "company"
  	    '(add-to-list 'company-backends 'company-anaconda))))
  
#+end_src


* Projectile

[[https://projectile.mx/][Projectile]] is a project management library for Emacs which makes it a lot easier to navigate around code projects for various languages.  Many packages integrate with Projectile so it's a good idea to have it installed even if you don't use its commands directly.

#+begin_src emacs-lisp :tangle no
  ;;; --------------------------------------------------------------------------

  (use-package projectile
    :diminish Proj
    :config (projectile-mode)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    (when (file-directory-p "~/Developer")
      (setq projectile-project-search-path '("~/Developer")))
    (setq projectile-switch-project-action #'projectile-dired))

  (when (equal completion-handler 'comphand-ivy-counsel)
      (use-package counsel-projectile
  	:after projectile
  	:config
  	(setq projectile-completion-system 'ivy)
  	(counsel-projectile-mode)))

#+end_src



* Magit

[[https://magit.vc/][Magit]] is the best Git interface I've ever used.  Common Git operations are easy to execute quickly using Magit's command panel system.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package magit
     :defer t
     :commands (magit-status magit-get-current-branch)
  ;; :custom
  ;;  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
     )

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started

  (use-package forge
    :after magit)
  
#+end_src


* Org Mode

Org Mode is one of the hallmark features of Emacs.  It is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package [[https://orgmode.org/][Orgmode]].

The =mrf/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

*NOTE:* Most of the code below has been taken from the [[https://systemcrafters.net][System Crafters]] site run by David Wilson. Please visit that site for lots of great stuff!

** Theme Override Values

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/org-theme-override-values ()
      (defface org-block-begin-line
  	'((t (:underline "#1D2C39" :foreground "SlateGray" :background "#1D2C39")))
  	"Face used for the line delimiting the begin of source blocks.")

      (defface org-block
  	'((t (:background "#242635" :extend t)))
  	"Face used for the source block background.")

      (defface org-block-end-line
  	'((t (:overline "#1D2C39" :foreground "SlateGray" :background "#1D2C39")))
  	"Face used for the line delimiting the end of source blocks.")
      
      (defface org-modern-horizontal-rule
  	'((t (:strike-through "green" :weight bold)))
  	"Face used for the Horizontal like (-----)"))

#+end_src

** Font setup

This function sets up the fonts faces that are used within org-mode.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/org-font-setup ()
    "Setup org mode fonts."
      (require 'org-faces)

      (font-lock-add-keywords
  	'org-mode
  	'(("^ *\\([-]\\) "
                (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
      ;; (setq org-src-fontify-natively t)

            ;; Set faces for heading levels
      (dolist (face '((org-level-1 . 1.5)
                         (org-level-2 . 1.25)
                         (org-level-3 . 1.1)
                         (org-level-4 . 1.1)
                         (org-level-5 . 1.1)
                         (org-level-6 . 1.1)
                         (org-level-7 . 1.1)
                         (org-level-8 . 1.1)))
  	(set-face-attribute (car face) nil :font "SF Pro" :weight 'regular :height (cdr face)))

      ;; Ensure that anything that should be fixed-pitch in Org files appears that way
      (set-face-attribute 'org-block nil    :foreground 'unspecified :inherit 'fixed-pitch)
      (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
      (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
      (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
      (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
      (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
      (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
      (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
      (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
      (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
      (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))

#+end_src

** Setup

This section contains the basic configuration for =org-mode= plus the configuration for Org agendas and capture templates.

#+begin_src  emacs-lisp
  ;; -----------------------------------------------------------------

  (defun mrf/org-mode-setup ()
      (org-indent-mode)
      (variable-pitch-mode 1)
      (visual-line-mode 1)
      (setq org-ellipsis " ▾")
      (setq org-agenda-start-with-log-mode t)
      (setq org-log-done 'time)
      (setq org-log-into-drawer t)
      ;; (use-package org-habit)
      ;; (add-to-list 'org-modules 'org-habit)
      ;; (setq org-habit-graph-column 60)
      (setq org-todo-keywords
  	'((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
               (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)"
  		 "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))
      (setq org-refile-targets
  	'(("Archive.org" :maxlevel . 1)
               ("Tasks.org" :maxlevel . 1))))

#+end_src

*** Function to setup the agenda

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/org-setup-agenda ()
     (setq org-agenda-custom-commands
        '(("d" "Dashboard"
             ((agenda "" ((org-deadline-warning-days 7)))
                (todo "NEXT"
                   ((org-agenda-overriding-header "Next Tasks")))
                (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

            ("n" "Next Tasks"
               ((todo "NEXT"
                   ((org-agenda-overriding-header "Next Tasks")))))

            ("W" "Work Tasks" tags-todo "+work-email")

            ;; Low-effort next actions
            ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
               ((org-agenda-overriding-header "Low Effort Tasks")
                (org-agenda-max-todos 20)
                (org-agenda-files org-agenda-files)))

            ("w" "Workflow Status"
               ((todo "WAIT"
                   ((org-agenda-overriding-header "Waiting on External")
                      (org-agenda-files org-agenda-files)))
                (todo "REVIEW"
                     ((org-agenda-overriding-header "In Review")
                        (org-agenda-files org-agenda-files)))
                (todo "PLAN"
                     ((org-agenda-overriding-header "In Planning")
                        (org-agenda-todo-list-sublevels nil)
                        (org-agenda-files org-agenda-files)))
                (todo "BACKLOG"
                     ((org-agenda-overriding-header "Project Backlog")
                        (org-agenda-todo-list-sublevels nil)
                        (org-agenda-files org-agenda-files)))
                (todo "READY"
                     ((org-agenda-overriding-header "Ready for Work")
                        (org-agenda-files org-agenda-files)))
                (todo "ACTIVE"
                     ((org-agenda-overriding-header "Active Projects")
                        (org-agenda-files org-agenda-files)))
                (todo "COMPLETED"
                     ((org-agenda-overriding-header "Completed Projects")
                        (org-agenda-files org-agenda-files)))
                (todo "CANC"
                     ((org-agenda-overriding-header "Cancelled Projects")
                        (org-agenda-files org-agenda-files)))))))
     ) ;; mrf/org-setup-agenda
  
#+end_src

*** The capture-templates function

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun mrf/org-setup-capture-templates ()
     (setq org-capture-templates
        `(("t" "Tasks / Projects")
            ("tt" "Task" entry (file+olp "~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org" "Inbox")
               "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

            ("j" "Journal Entries")
            ("jj" "Journal" entry
               (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
               "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
               ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
               :clock-in :clock-resume
               :empty-lines 1)
            ("jm" "Meeting" entry
               (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
               "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
               :clock-in :clock-resume
               :empty-lines 1)

            ("w" "Workflows")
            ("we" "Checking Email" entry (file+olp+datetree
                                    "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
               "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

            ("m" "Metrics Capture")
            ("mw" "Weight" table-line (file+headline
                                       "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org"
                                       "Weight")
               "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t))))
     
#+end_src

** The main 'Org' package
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (mrf/org-theme-override-values)

  (use-package org
      :defer t
      :commands (org-capture org-agenda)
      :hook (org-mode . mrf/org-mode-setup)
      :bind (:map org-mode-map
  	      ("C-c e" . org-edit-src-code))
      :config
      (message ">>> Loading orgmode")
      (setq org-hide-emphasis-markers t)
      ;; Save Org buffers after refiling!
      (advice-add 'org-refile :after 'org-save-all-org-buffers)
      (setq org-tag-alist
  	'((:startgroup)
  					; Put mutually exclusive tags here
               (:endgroup)
               ("@errand" . ?E)
               ("@home" . ?H)
               ("@work" . ?W)
               ("agenda" . ?a)
               ("planning" . ?p)
               ("publish" . ?P)
               ("batch" . ?b)
               ("note" . ?n)
               ("idea" . ?i)))
      ;; Configure custom agenda views
      (mrf/org-setup-agenda)
      (mrf/org-setup-capture-templates)
      ;; If not already, enable yasnippet
      (yas-global-mode t)
      (define-key global-map (kbd "C-c j")
  	(lambda () (interactive) (org-capture nil "jj")))
      (mrf/org-font-setup))

#+end_src

** Org Modern
#+begin_src emacs-lisp

  ;;; --------------------------------------------------------------------------

  (use-package org-modern
      :after org
      :hook (org-mode . org-modern-mode))

  ;; Add frame borders and window dividers
  (modify-all-frames-parameters
      '((right-divider-width . 40)
  	 (internal-border-width . 40)))
  (dolist (face '(window-divider
                     window-divider-first-pixel
                     window-divider-last-pixel))
      (face-spec-reset-face face)
      (set-face-foreground face (face-attribute 'default :background)))
  (set-face-background 'fringe (face-attribute 'default :background))

  (setq
      ;; Edit settings
      org-auto-align-tags nil
      org-tags-column 0
      org-catch-invisible-edits 'show-and-error
      org-special-ctrl-a/e t
      org-insert-heading-respect-content t

      ;; Org styling, hide markup etc.
      org-hide-emphasis-markers t
      org-pretty-entities t
      org-ellipsis "…"

      ;; Agenda styling
      org-agenda-tags-column 0
      org-agenda-block-separator ?─
      org-agenda-time-grid
      '((daily today require-timed)
  	 (800 1000 1200 1400 1600 1800 2000)
  	 " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
      org-agenda-current-time-string
      "◀── now ─────────────────────────────────────────────────")

  (global-org-modern-mode)

#+end_src

** Better Bullets
[[https://github.com/sabof/org-bullets][org-bullets]] replaces the heading stars in =org-mode= buffers with nicer looking characters that you can control.  Another option for this is [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]].

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package org-bullets
     :after org
      :hook (org-mode . org-bullets-mode)
      :custom
      (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

** Visual Fill
We use [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] to center =org-mode= buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document.  This is really a matter of personal preference so you can remove the block below if you don't like the behavior.

#+begin_src emacs-lisp 
  ;;; --------------------------------------------------------------------------

  (defun mrf/org-mode-visual-fill ()
    (setq visual-fill-column-width custom-org-fill-column
          visual-fill-column-center-text nil)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . mrf/org-mode-visual-fill))

#+end_src

** Export Code
To execute or export code in =org-mode= code blocks, you'll need to set up =org-babel-load-languages= for each language you'd like to use.  [[https://orgmode.org/worg/org-contrib/babel/languages.html][Babel]] documents all of the languages that you can use with =org-babel=.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (with-eval-after-load 'org    
      (org-babel-do-load-languages
  	'org-babel-load-languages
  	'((emacs-lisp . t)
  	     (js . t)
  	     (shell . t)
  	     (python . t)))

      (push '("conf-unix" . conf-unix) org-src-lang-modes))
#+end_src

** Structure Templates
Org Mode's structure templates feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block.  You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language as it is known by Org Babel.

This snippet adds a hook to =org-mode= buffers so that =mrf/org-babel-tangle-config= gets executed each time such a buffer gets saved.  This function checks to see if the file being saved is the Emacs.org file you're looking at right now, and if so, automatically exports the configuration here to the associated output files.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (with-eval-after-load 'org
    ;; This is needed as of Org 9.2

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python")))
#+end_src

** Org-mode Roam
Org Mode is known to be a great tool not just for writing and personal notes but also TODO lists, project planning, time tracking, and more. Once you start to become really invested in Org Mode you’ll eventually have to come up with a system for managing your Org files so that it’s easy to store and find the information you need.

Org Roam is an extension to Org Mode which solves a couple of the biggest problems that I’ve personally had when using Org for personal notes:

- How many Org files do I need?
- How do I decide where to put things in my Org files?

Org Roam solves these problems by making it easy to create topic-focused Org Files and link them together so that you can treat the information as nodes in a network rather than as hierarchical documents. You can think of it like a personal wiki!

#+begin_src emacs-lisp 
  ;;; --------------------------------------------------------------------------
  ;; (use-package emacsql)
  ;; (use-package emacsql-sqlite)

  (use-package org-roam
     ;; :demand t  ;; Ensure org-roam is loaded by default
     :init
     (setq org-roam-v2-ack t)
     :custom
     (org-roam-directory (expand-file-name "RoamNotes" custom-docs-dir))
     (org-roam-completion-everywhere t)
     :bind (("C-c n l" . org-roam-buffer-toggle)
            ("C-c n f" . org-roam-node-find)
            ("C-c n i" . org-roam-node-insert)
            ("C-c n I" . org-roam-node-insert-immediate)
            ("C-c n p" . my/org-roam-find-project)
            ("C-c n t" . my/org-roam-capture-task)
            ("C-c n b" . my/org-roam-capture-inbox)
            :map org-mode-map
            ("C-M-i" . completion-at-point)
            :map org-roam-dailies-map
            ("Y" . org-roam-dailies-capture-yesterday)
            ("T" . org-roam-dailies-capture-tomorrow))
     :bind-keymap
     ("C-c n d" . org-roam-dailies-map)
     :config
     (require 'org-roam-dailies) ;; Ensure the keymap is available
     (my/org-roam-refresh-agenda-list)
     (add-to-list 'org-after-todo-state-change-hook
        (lambda ()
         (when (equal org-state "DONE")
              (my/org-roam-copy-todo-to-today))))
     (org-roam-db-autosync-mode))

  (defun org-roam-node-insert-immediate (arg &rest args)
     (interactive "P")
     (let ((args (push arg args))
             (org-roam-capture-templates
                (list (append (car org-roam-capture-templates)
                         '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

  #+end_src

*** Org Agenda from Roam Notes
One of the most useful features of Org Mode is the agenda view. You can actually use your Org Roam notes as the source for this view!

Typically you won’t want to pull in all of your Org Roam notes, so we’ll only use the notes with a specific tag like Project.

Here is a snippet that will find all the notes with a specific tag and then set your org-agenda-list with the corresponding note files.

#+begin_src emacs-lisp 
  ;;; --------------------------------------------------------------------------
  ;; The buffer you put this code in must have lexical-binding set to t!
  ;; See the final configuration at the end for more details.

  (defun my/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun my/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (my/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))

  (defun my/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files (my/org-roam-list-notes-by-tag "Project")))

  ;; Build the agenda list the first time for the session
#+end_src

*** Selecting from a list of notes
The org-roam-node-find function gives us the ability to filter the list of notes that get displayed for selection.

We can define our own function that shows a selection list for notes that have a specific tag like Project which we talked about before. This can be useful to set up a keybinding to quickly select from a specific set of notes!

One added benefit is that we can override the set of capture templates that get used when a new note gets created.

This means that we can automatically create a new note with our project capture template if the note doesn’t already exist!

#+begin_src emacs-lisp 
  ;;; --------------------------------------------------------------------------

  (defun my/org-roam-project-finalize-hook ()
     "Adds the captured project file to `org-agenda-files' if the
  capture was not aborted."
     ;; Remove the hook since it was added temporarily
     (remove-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

     ;; Add project file to the agenda list if the capture was confirmed
     (unless org-note-abort
      (with-current-buffer (org-capture-get :buffer)
        (add-to-list 'org-agenda-files (buffer-file-name)))))

  (defun my/org-roam-find-project ()
     (interactive)
    ;; Add the project file to the agenda after capture is finished
     (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Select a project file to open, creating it if necessary
     (org-roam-node-find
        nil
        nil
        (my/org-roam-filter-by-tag "Project")
        :templates
        '(("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
             :unnarrowed t))))

  (global-set-key (kbd "C-c n p") #'my/org-roam-find-project)
#+end_src

*** Keep and inbox of notes and tasks
If you want to quickly capture new notes and tasks with a single keybinding into a place that you can review later, we can use org-roam-capture- to capture to a single-specific file like Inbox.org!

Even though this file won’t have the timestamped filename, it will still be treated as a node in your Org Roam notes.
#+begin_src emacs-lisp 
  ;;; --------------------------------------------------------------------------
  
  (defun my/org-roam-capture-inbox ()
     (interactive)
     (org-roam-capture- :node (org-roam-node-create)
        :templates '(("i" "inbox" plain "* %?"
                        :if-new (file+head "Inbox.org" "#+title: Inbox\n")))))
#+end_src

*** Capture a task
If you’ve set up project note files like we mentioned earlier, you can set up a capture template that allows you to quickly capture tasks for any project.

Much like the example before, we can either select a project that exists or automatically create a project note when it doesn’t exist yet.

#+begin_src emacs-lisp 
  ;;; --------------------------------------------------------------------------

  (defun my/org-roam-capture-task ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Capture the new task, creating the project file if necessary
     (org-roam-capture- :node (org-roam-node-read nil
                              (my/org-roam-filter-by-tag "Project"))
        :templates '(("p" "project" plain "** TODO %?"
                        :if-new
                        (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                           "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                           ("Tasks"))))))
#+end_src

*** Todo
The following snippet sets up a hook for all Org task state changes and then copies the completed (DONE) entry to today’s note file

#+begin_src emacs-lisp 
  ;;; --------------------------------------------------------------------------
  
  (defun my/org-roam-copy-todo-to-today ()
     (interactive)
     (let ((org-refile-keep t) ;; Set this to nil to delete the original!
             (org-roam-dailies-capture-templates
                '(("t" "tasks" entry "%?"
                     :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" ("Tasks")))))
             (org-after-refile-insert-hook #'save-buffer)
             today-file pos)
        (save-window-excursion
           (org-roam-dailies--capture (current-time) t)
           (setq today-file (buffer-file-name))
           (setq pos (point)))

        ;; Only refile if the target file is different than the current file
        (unless (equal (file-truename today-file)
                   (file-truename (buffer-file-name)))
           (org-refile nil nil (list "Tasks" today-file nil pos)))))

#+end_src

** Auto-tangle Configuration Files

This snippet adds a hook to =org-mode= buffers so that source code blocks can be written to another file - like how this Org file will write an init.el file. Add a =#+auto_tangle: t= at the top of the org file in order to enable this module to tangle the org file.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Automatically tangle our Configure.org config file when we save it
  ;; Org files that should use this need to add a '#+auto_tangle: t'
  ;; in the org file.
  (use-package org-auto-tangle
     :defer t
     :hook (org-mode . org-auto-tangle-mode))

#+end_src

** Markdown support
While there is standard markdown support built into =org-mode=, this additional markdown package can also be used.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (with-eval-after-load 'org
      (require 'ox-gfm nil t))
  
#+end_src


* IRC Client
#+begin_src emacs-lisp :tangle no
  ;;; --------------------------------------------------------------------------

  (add-hook 'rcirc-mode-hook #'rcirc-track-minor-mode)
  (add-hook 'rcirc-mode-hook #'rcirc-omit-mode)

#+end_src



* Quality of Life

The following packages are some additional quality of life features.

** Vertico
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when (equal completion-handler 'comphand-vertico)
      (use-package vertico
  	:demand t   ; Otherwise won't get loaded immediately
  	:straight (vertico :files (:defaults "extensions/*") ; Special recipe to load extensions conveniently
  		      :includes (vertico-indexed
  				    vertico-flat
  				    vertico-grid
  				    vertico-mouse
  				    vertico-quick
  				    vertico-buffer
  				    vertico-repeat
  				    vertico-reverse
  				    vertico-directory
  				    vertico-multiform
  				    vertico-unobtrusive
  				    ))
  	:config
  	(vertico-mode)
  	(recentf-mode t)
  	(vertico-multiform-mode)
  	(vertico-count 13)
  	(vertico-cycle nil)
  					; Clean up file path when typing
  	:hook ((rfn-eshadow-update-overlay . vertico-directory-tidy)
  					; Make sure vertico state is saved
  		  (minibuffer-setup . vertico-repeat-save)))

      (use-package vertico-prescient
  	:after vertico)

      (use-package vertico-posframe
  	:straight t
  	:custom
  	(vertico-posframe-parameters
  	    '((left-fringe . 8)
  		 (right-fringe . 8)))))
#+end_src

** Marginalia

Marginalia are marks or annotations placed at the margin of the page of a book  or in this case helpful colorful annotations placed at the margin of the  minibuffer for your completion candidates. Marginalia can only add annotations  to the completion candidates. It cannot modify the appearance of the candidates  themselves, which are shown unaltered as supplied by the original command.
 
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  
  (when (equal completion-handler 'comphand-vertico)
      (use-package marginalia
          :custom
          (marginalia-max-relative-age 0)
          (marginalia-align 'right)
          :config
          (marginalia-mode t)))

#+end_src

** Orderless
This package provides an orderless completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order. Each component can match in any one of several ways: literally, as a regexp, as an initialism, in the flex style, or as multiple word prefixes. By default, regexp and literal matches are enabled.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  
  (when (equal completion-handler 'comphand-vertico)
      (use-package orderless
  	:custom
  	(completion-styles '(orderless basic))
  	(completion-category-overrides '((file (styles basic partial-completion))))))

#+end_src

** Consult
Consult provides search and navigation commands based on the Emacs completion function completing-read. Completion allows you to quickly select an item from a list of candidates. Consult offers asynchronous and interactive consult-grep and  consult-ripgrep commands, and the line-based search command consult-line. Furthermore Consult provides an advanced buffer switching command consult-buffer to switch between buffers, recently opened files, bookmarks and buffer-like candidates from other sources. Some of the Consult commands are enhanced versions of built-in Emacs commands.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Example configuration for Consult
  
  (when (equal completion-handler 'comphand-vertico)
      (use-package consult
  	:straight t
  	;; Replace bindings. Lazily loaded due by `use-package'.
  	:bind (;; C-c bindings in `mode-specific-map'
  		  ("C-c M-x" . consult-mode-command)
  		  ("C-c h" . consult-history)
  		  ("C-c k" . consult-kmacro)
  		  ("C-c m" . consult-man)
  		  ("C-c i" . consult-info)
  		  ([remap Info-search] . consult-info)
  		  ;; C-x bindings in `ctl-x-map'
  		  ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
  		  ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
  		  ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
  		  ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
  		  ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
  		  ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
  		  ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
  		  ;; Custom M-# bindings for fast register access
  		  ("M-#" . consult-register-load)
  		  ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
  		  ("C-M-#" . consult-register)
  		  ;; Other custom bindings
  		  ("M-y" . consult-yank-pop)                ;; orig. yank-pop
  		  ;; M-g bindings in `goto-map'
  		  ("M-g e" . consult-compile-error)
  		  ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
  		  ("M-g g" . consult-goto-line)             ;; orig. goto-line
  		  ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
  		  ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
  		  ("M-g m" . consult-mark)
  		  ("M-g k" . consult-global-mark)
  		  ("M-g i" . consult-imenu)
  		  ("M-g I" . consult-imenu-multi)
  		  ;; M-s bindings in `search-map'
  		  ("M-s d" . consult-find)                  ;; Alternative: consult-fd
  		  ("M-s c" . consult-locate)
  		  ("M-s g" . consult-grep)
  		  ("M-s G" . consult-git-grep)
  		  ("M-s r" . consult-ripgrep)
  		  ("M-s l" . consult-line)
  		  ("M-s L" . consult-line-multi)
  		  ("M-s k" . consult-keep-lines)
  		  ("M-s u" . consult-focus-lines)
  		  ;; Isearch integration
  		  ("M-s e" . consult-isearch-history)
  		  :map isearch-mode-map
  		  ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
  		  ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
  		  ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
  		  ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
  		  ;; Minibuffer history
  		  :map minibuffer-local-map
  		  ("M-s" . consult-history)                 ;; orig. next-matching-history-element
  		  ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  	;; Enable automatic preview at point in the *Completions* buffer. This is
  	;; relevant when you use the default completion UI.
  	:hook (completion-list-mode . consult-preview-at-point-mode)

  	;; The :init configuration is always executed (Not lazy)
  	:init

  	;; Optionally configure the register formatting. This improves the register
  	;; preview for `consult-register', `consult-register-load',
  	;; `consult-register-store' and the Emacs built-ins.
  	(setq register-preview-delay 0.5
              register-preview-function #'consult-register-format)

  	;; Optionally tweak the register preview window.
  	;; This adds thin lines, sorting and hides the mode line of the window.
  	(advice-add #'register-preview :override #'consult-register-window)

  	;; Use Consult to select xref locations with preview
  	(setq xref-show-xrefs-function #'consult-xref
              xref-show-definitions-function #'consult-xref)

  	;; Configure other variables and modes in the :config section,
  	;; after lazily loading the package.
  	:config

  	;; Optionally configure preview. The default value
  	;; is 'any, such that any key triggers the preview.
  	;; (setq consult-preview-key 'any)
  	;; (setq consult-preview-key "M-.")
  	;; (setq consult-preview-key '("S-<down>" "S-<up>"))
  	;; For some commands and buffer sources it is useful to configure the
  	;; :preview-key on a per-command basis using the `consult-customize' macro.
  	(consult-customize
  	    consult-theme :preview-key '(:debounce 0.2 any)
  	    consult-ripgrep consult-git-grep consult-grep
  	    consult-bookmark consult-recent-file consult-xref
  	    consult--source-bookmark consult--source-file-register
  	    consult--source-recent-file consult--source-project-recent-file
  	    ;; :preview-key "M-."
  	    :preview-key '(:debounce 0.4 any))

  	;; Optionally configure the narrowing key.
  	;; Both < and C-+ work reasonably well.
  	(setq consult-narrow-key "<") ;; "C-+"

  	;; Optionally make narrowing help available in the minibuffer.
  	;; You may want to use `embark-prefix-help-command' or which-key instead.
  	;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  	;; By default `consult-project-function' uses `project-root' from project.el.
  	;; Optionally configure a different project root function.
    ;;;; 1. project.el (the default)
  	;; (setq consult-project-function #'consult--default-project--function)
    ;;;; 2. vc.el (vc-root-dir)
  	;; (setq consult-project-function (lambda (_) (vc-root-dir)))
    ;;;; 3. locate-dominating-file
  	;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
    ;;;; 4. projectile.el (projectile-project-root)
  	;; (autoload 'projectile-project-root "projectile")
  	;; (setq consult-project-function (lambda (_) (projectile-project-root)))
    ;;;; 5. No project support
  	;; (setq consult-project-function nil)
  	))
#+end_src

** Solair mode
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package solaire-mode
     :hook (after-init . solaire-global-mode)
     :config
     (push '(treemacs-window-background-face . solaire-default-face) solaire-mode-remap-alist)
     (push '(treemacs-hl-line-face . solaire-hl-line-face) solaire-mode-remap-alist))
  
#+end_src

** Golden Ratio
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Golen Ratio

  (if enable-golden-ratio
      (use-package golden-ratio
	  :custom
	  (golden-ratio-auto-scale t)
	  (golden-ratio-adjust-factor .4)
	  (golden-ratio-wide-adjust-factor .4)
	  (golden-ratio-max-width 100)
	  (golden-ratio-exclude-modes '(treemacs-mode
					undo-tree-visdualizer-mode
					inferior-python-mode
					vundo-mode
					which-key-mode
					c-mode
					cc-mode
					dashboard-mode
					python-mode
					markdown-mode))
	  (golden-ratio-exclude-buffer-regexp '("dap*"
					      "*dape*"
						"*python*"))
	  :config
	  (golden-ratio-mode 1)))
#+end_src

** Ace Window
[[https://github.com/abo-abo/ace-window][ace-window]] is a package for selecting a window to switch to. Like =other-window= but better!

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package ace-window
      :bind ("M-o" . ace-window))

#+end_src

** Dashboard
Dashboard is an extensible Emacs startup screen showing you what’s most important.
*** Value of dashboard-startup-banner can be:
**** =nil= to display no banner
**** ='official= which displays the official emacs logo
**** ='logo= which displays an alternative emacs logo
**** =1, 2 or 3= which displays one of the text banners
**** ~"path/to/your/image.gif"~, ~"path/to/your/image.png"~ or ~"path/to/your/text.txt"~  which displays whatever gif/image/text you would prefer
**** a cons of '("path/to/your/image.png" . "path/to/your/text.txt")

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package all-the-icons
      :if (display-graphic-p))

  (defun mrf/setup-dashboard-buffer ()
      "Set up the dashboard buffer and optionally make it the first."
      (setq dashboard-items '((recents . 15)
                                 (bookmarks . 10)
                                 (projects . 10))
  	dashboard-icon-type 'all-the-icons
  	dashboard-display-icons-p t
  	dashboard-center-content t
  	dashboard-set-heading-icons t
  	dashboard-set-file-icons t)
      ;; dashboard-projects-backend 'projectile)

      (global-set-key (kbd "C-c d") 'dashboard-open)

      (if (equal display-dashboard-at-start t)
  	(progn
              (setq initial-buffer-choice
  		(lambda ()
                      (get-buffer-create "*dashboard*")))
              (dashboard-open))
  	(get-buffer-create "*dashboard*")))

  (defun mrf/dashboard-banner ()
      "Setup defaults for the dashboard banner buffer."
      (setq dashboard-footer-messages '("Greetings Program!"))
      (setq dashboard-banner-logo-title "Welcome to Emacs!")
      (setq dashboard-startup-banner 'logo))

  (use-package dashboard
      :after (dired)
      :init
      (mrf/dashboard-banner)
      :hook ((after-init     . mrf/setup-dashboard-buffer)
                (dashboard-mode . mrf/dashboard-banner)))

#+end_src

** Vundo
A great package that allows moving up and down the undo-redo tree.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; A cleaner and simpler undo package.

  (if enable-vundo
      (use-package vundo
  	:bind (("C-x u" . vundo)
  		  ("C-x r u" . vundo))
  	:config
  	(setq vundo-glyph-alist vundo-unicode-symbols)
  	(set-face-attribute 'vundo-default nil :family "Wingdings2")))

#+end_src

** Undo-Tree
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Full-featured undo-tree handling. Look to Vundo for something a little
  ;; simpler.

  (defun mrf/undo-tree-hook ()
      (set-frame-width (selected-frame) 20))

  (if (not enable-vundo)
      (use-package undo-tree
          ;; :hook (undo-tree-visualizer-mode-hook . mrf/undo-tree-hook)
          :init
          (setq undo-tree-visualizer-timestamps t
  	        ;; undo-tree-visualizer-diff t
  	        undo-tree-enable-undo-in-region t
  	        ;; 10X bump of the undo limits to avoid issues with premature
  	        ;; Emacs GC which truncages the undo history very aggresively
  	        undo-limit 800000
  	        undo-strong-limit 12000000
  	        undo-outer-limit 120000000)
          (global-undo-tree-mode))
      ;; This prevents the *.~undo-tree~ files from being persisted.
      (with-eval-after-load 'undo-tree
          (setq undo-tree-auto-save-history nil)))
      
#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.  It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; helpful package

  (if (equal completion-handler 'comphand-ivy-counsel)
      (use-package helpful
  	:commands (helpful-callable helpful-variable helpful-command helpful-key)
  	:custom
  	(counsel-describe-function-function #'helpful-callable)
  	(counsel-describe-variable-function #'helpful-variable)
  	:bind
  	([remap describe-function] . counsel-describe-function)
  	([remap describe-command] . helpful-command)
  	([remap describe-variable] . counsel-describe-variable)
  	([remap describe-key] . helpful-key))
    (use-package helpful
        :commands (helpful-callable helpful-variable helpful-command helpful-key)
        :bind
        ([remap describe-command] . helpful-command)
        ([remap describe-key] . helpful-key)))

#+end_src

** Terminals
*** term-mode

=term-mode= is a built-in terminal emulator in Emacs.  Because it is written in Emacs Lisp, you can start using it immediately with very little configuration.  If you are on Linux or macOS, =term-mode= is a great choice to get started because it supports fairly complex terminal applications (=htop=, =vim=, etc) and works pretty reliably.  However, because it is written in Emacs Lisp, it can be slower than other options like =vterm=.  The speed will only be an issue if you regularly run console apps with a lot of output.

One important thing to understand is =line-mode= versus =char-mode=.  =line-mode= enables you to use normal Emacs keybindings while moving around in the terminal buffer while =char-mode= sends most of your keypresses to the underlying terminal.  While using =term-mode=, you will want to be in =char-mode= for any terminal applications that have their own keybindings.  If you're just in your usual shell, =line-mode= is sufficient and feels more integrated with Emacs.

With =evil-collection= installed, you will automatically switch to =char-mode= when you enter Evil's insert mode (press =i=).  You will automatically be switched back to =line-mode= when you enter Evil's normal mode (press =ESC=).

Run a terminal with =M-x term!=

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =C-c C-k= - Enter char-mode
- =C-c C-j= - Return to line-mode
- If you have =evil-collection= installed, =term-mode= will enter char mode when you use Evil's Insert mode

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package term
    :defer t
    :commands term
    :config
    (setq explicit-shell-file-name "bash") ;; Change this to zsh, etc
    ;;(setq explicit-zsh-args '())         ;; Use 'explicit-<shell>-args for shell-specific args

    ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))
  
#+end_src

*** Better term-mode colors

The =eterm-256color= package enhances the output of =term-mode= to enable handling of a wider range of color codes so that many popular terminal applications look as you would expect them to.  Keep in mind that this package requires =ncurses= to be installed on your machine so that it has access to the =tic= program.  Most Linux distributions come with this program installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package eterm-256color
    :defer t
    :hook (term-mode . eterm-256color-mode))
#+end_src

*** vterm

[[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native module to interact with the underlying terminal applications.  This enables it to be much faster than =term-mode= and to also provide a more complete terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to use =vterm= because there is a module that will need to be compiled before you can use it successfully.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package vterm
    :defer t
    :commands vterm
    :config
    (setq vterm-environment ("PS1=\\u@\\h:\\w \n$"))
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
    (setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
    (setq vterm-max-scrollback 10000))

#+end_src

*** shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell.  It is *not* a terminal emulator so more complex terminal programs will not run inside of it.  It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter.  This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

** Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-esh-history= - A searchable history of commands typed into Eshell

We will be covering Eshell more in future videos highlighting other things you can do with it.

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defun efs/configure-eshell ()
      ;; Save command history when commands are entered
      (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

      ;; Truncate buffer for performance
      (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

      ;; Bind some useful keys for evil-mode
      ;; (bind-keys :map eshell-mode-map
      ;; 	("C-r" . eshell-hist-mode)
      ;; 	("<home>" . eshell-bol))
      
      ;; (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
      ;; (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
      ;; (evil-normalize-keymaps)

      (setq eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell-git-prompt
      :after eshell)

  (use-package eshell
      :defer t
      :hook (eshell-first-time-mode . efs/configure-eshell)
      :config
      (with-eval-after-load 'esh-opt
  	(setq eshell-destroy-buffer-when-process-dies t)
  	(setq eshell-visual-commands '("htop" "zsh" "vim")))

      (eshell-git-prompt-use-theme 'powerline))

#+end_src

** Neotree
A tree plugin like NerdTree for Vim

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (when enable-neotree
      (use-package neotree
  	:config
  	(global-set-key [f8] 'neotree-toggle)
  	(setq neo-theme (if (display-graphic-p) 'icons 'arrow))))
  
#+end_src

** Icons
Some icons to be used in grpahical mode.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package all-the-icons)
  (use-package nerd-icons)

  ;; (use-package doom-modeline
  ;;   :diabled
  ;;   :init (doom-modeline-mode 1)
  ;;   :custom ((doom-modeline-height 15)))
#+end_src

** Useful functions and Keybindings
Here are some helpful functions.

#+begin_src emacs-lisp  :tangle no
  ;;; --------------------------------------------------------------------------
  ;; Functions to insert the buffer file name at the current cursor position
  ;;
  (defun mrf/insert-buffer-full-name-at-point ()
     (interactive)
     (insert buffer-file-name))

  (defun mrf/insert-buffer-name-at-point ()
     (interactive)
     (insert (file-name-nondirectory (buffer-file-name))))
  
#+end_src

** ChatGPT
#+begin_src emacs-lisp :tangle no
  ;;; --------------------------------------------------------------------------
  
  (use-package chatgpt-shell
     :custom
     (chatgpt-shell-openai-key "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"))
#+end_src

** Centaur Tabs
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Enable tabs for each buffer

  (when enable-centaur-tabs
      (use-package centaur-tabs
  	:custom
  	;; Set the style to rounded with icons (setq centaur-tabs-style "bar")
  	(centaur-tabs-style "bar")
  	(centaur-tabs-set-icons t)
  	(centaur-tabs-set-modified-marker t)
  	:bind (("C-c <" . centaur-tabs-backward)
  		  ("C-c >" . centaur-tabs-forward))
  	:config ;; Enable centaur-tabs
  	(centaur-tabs-mode t)))

#+end_src

** Diff HL
=diff-hl-mode= highlights uncommitted changes on the left side of the window (area also known as the "gutter"), allows you to jump between and revert them selectively.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package diff-hl
      :config
      (global-diff-hl-mode))
  
#+end_src

** Pulsar
#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package pulsar
      :config
      (pulsar-global-mode)
      :custom
      (pulsar-pulse t)
      (pulsar-delay 0.10)
      (pulsar-iterations 10)
      (pulsar-face 'pulsar-magenta)
      (pulsar-highlight-face 'pulsar-yellow))

#+end_src

** Popper
Popper is a minor-mode to tame the flood of ephemeral windows Emacs produces, while still keeping them within arm’s reach.

Designate any buffer to “popup” status, and it will stay out of your way. Disimss or summon it easily with one key. Cycle through all your “popups” or just the ones relevant to your current buffer. Group popups automatically so you’re presented with the most relevant ones. Useful for many things, including toggling display of REPLs, documentation, compilation or shell output: any buffer you need instant access to but want kept out of your way!

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package popper
      :defer t
      :bind (("C-`"   . popper-toggle)
  	   ("M-`"   . popper-cycle)
  	   ("C-M-`" . popper-toggle-type))
      :init
      (setq popper-reference-buffers
  	'("\\*Messages\\*"
  	     "\\*scratch\\*"
  	     "\\*ielm\\*"
               "Output\\*$"
               "\\*Async Shell Command\\*"
  	     "^\\*eshell.*\\*$" eshell-mode ;eshell as a popup
               "^\\*shell.*\\*$"  shell-mode  ;shell as a popup
               "^\\*term.*\\*$"   term-mode   ;term as a popup
               "^\\*vterm.*\\*$"  vterm-mode  ;vterm as a popup
               help-mode
               compilation-mode))
      (popper-mode +1)
      (popper-echo-mode +1))

#+end_src


* File Management
** Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings
**** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!

**** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

**** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

**** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

*** Configuration

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;; Prefer g-prefixed coreutils version of standard utilities when available
  (let ((gls (executable-find "gls")))
    (when gls (setq insert-directory-program gls)))

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-open
    :commands (dired dired-jump)
    :config
    ;; Doesn't work as expected!
    ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
    (setq dired-open-extensions '(("png" . "feh")
                                  ("mkv" . "mpv"))))

  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode))

#+end_src

*** Single Window
Dired, by default, opens up multiple windows - one for each directory. It would be nice to be able to limit =dired= to use just a single window. [[https://codeberg.org/amano.kenji/dired-single][dired-single]] does just that. We configure =dired-single= to open up a directory while in dired with the =C-<return>=  key combination. This will then open up the directory in the buffer named =*dired*=. Whenever a directory is opened with the =C-<return>= key sequence, that directory will then replace what's currently in the =*dired*= buffer.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Single Window dired - don't continually open new buffers

  (defun mrf/dired-single-keymap-init ()
    "Bunch of stuff to run for dired, either immediately or when it's
     loaded."
    (define-key dired-mode-map
       [remap dired-find-file] 'dired-single-buffer)
    (define-key dired-mode-map
       [remap dired-mouse-find-file-other-window] 'dired-single-buffer-mouse)
    (define-key dired-mode-map
       [remap dired-up-directory] 'dired-single-up-directory))

  (use-package dired-single
     :config
     (mrf/dired-single-keymap-init))

#+end_src



* Mitch's Minor Mode
This is a simple popup menu that provides some common QOL features in one menu.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (use-package popup)
  
  (defun mmm-menu ()
      (interactive)
      (let ((mmm-menu-choice (popup-cascade-menu '
  			       ("open-dashboard" "open-ielm"
  				   ("Themes" "next-theme" "previous-theme" "which-theme")
  				   ("Shells" "vterm" "vterm-other-window" "eshell")
  				   "set-fill-column" "set-org-fill-column"
  				   "eldoc-help" "pydoc-help"))))
  	(cond
  	    ((equal mmm-menu-choice "open-dashboard")
  		(dashboard-open))
  	    ((equal mmm-menu-choice "open-ielm")
  		(ielm))
  	    ((equal mmm-menu-choice "next-theme")
  		(next-theme))
  	    ((equal mmm-menu-choice "previous-theme")
  		(previous-theme))
  	    ((equal mmm-menu-choice "which-theme")
  		(which-theme))
  	    ((equal mmm-menu-choice "vterm")
  		(vterm))
  	    ((equal mmm-menu-choice "vterm-other-window")
  		(vterm-other-window))
  	    ((equal mmm-menu-choice "eshell")
  		(eshell))
  	    ((equal mmm-menu-choice "set-fill-column")
  		(call-interactively 'mrf/set-fill-column-interactively))
  	    ((equal mmm-menu-choice "set-org-fill-column")
  		(call-interactively 'mrf/set-org-fill-column-interactively))
  	    ((equal mmm-menu-choice "eldoc-help")
  		(eldoc-box-help-at-point))
  	    ((equal mmm-menu-choice "pydoc-help")
  		(pydoc-at-point)))
  	))


#+end_src

** Mitch's Minor-Mode Standard Keymaps

This is a set of keymaps that do the same things as the popup menu. Both are here for convenience. *Note* that the ~mmm-menu~ is called with either a ="C-c RET RET"= or simply a ="C-c C-<return>"=.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (defvar mmm-keys-minor-mode-map
      (let ((map (make-sparse-keymap)))
  	(bind-keys :map map
  	    ("M-RET p" . pulsar-pulse-line)
  	    ("M-RET P" . pulsar-highlight-line)
  	    ("M-RET RET" . mmm-menu)
  	    ("M-RET d" . dashboard-open)
  	    ("M-RET f" . mrf/set-fill-column-interactively)
  	    ("M-RET F" . mrf/set-org-fill-column-interactively)
  	    ("M-RET i" . ielm)
  	    ("M-RET v" . vterm-other-window)
  	    ("M-RET S" . smartparens-strict-mode)
  	    ("M-RET |" . global-display-fill-column-indicator-mode)
  	    ("M-RET C-=" . next-theme)
  	    ("M-RET C--" . previous-theme)
  	    ("M-RET C-?" . which-theme)
  	    ("M-RET ?" . eldoc-box-help-at-point))
  	(if (featurep 'python)
  	    (define-key map (kbd "M-RET C-.") 'pydoc-at-point))
  	map)
      "mmm-keys-minor-mode keymap.")

  (define-minor-mode mmm-keys-minor-mode
      "A minor mode so that my key settings override annoying major modes."
      :init-value t
      :lighter " mmm-keys")

  (mmm-keys-minor-mode 1)

  (which-key-add-key-based-replacements "M-RET f" "set-fill-column")
  (which-key-add-key-based-replacements "M-RET" "Mitch's Menu")
  (diminish 'mmm-keys-minor-mode "m3k")

  	  
#+end_src


* Lastly

Some final configuratiion to be done at the end of this configuration.

** Initial *scratch* buffer message

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  (setq-default initial-scratch-message
      (format ";; Hello, World and Happy hacking %s!\n%s\n\n"
  	user-login-name
  	";; Press M-RET (Meta-RET) to open the Mitch's Menu"))
  
    ;; (concat ";; Hello, World and Happy hacking "
    ;;     user-login-name "!\n;; Press M-RET (C-c C-m) to open the Mitch Menu\n\n"))

#+end_src

** Ignore Line Number Mode
The following is a list of major mode-hooks variables that are set so that they don't follow the normal global line number mode. If there is any mode that doesn't appear here, more than likely it will have line numbers added. Just add the hook name here to make it so that major mode not have line numbers. This doesn't effect minor modes.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Ignore Line Numbers for the following modes:

  ;; Line #'s appear everywhere
  ;; ... except for when in these modes
  (dolist (mode '(dashboard-mode-hook
                  helpful-mode-hook
                  eshell-mode-hook
                  eww-mode-hook
                  help-mode-hook
                  org-mode-hook
                  shell-mode-hook
                  term-mode-hook
                  treemacs-mode-hook
                  vterm-mode-hook))
     (add-hook mode (lambda () (display-line-numbers-mode 0))))

  (setq warning-suppress-types '((package reinitialization)
                                   (package-initialize)
                                   (package)
                                   (use-package)
                                   (python-mode)))
  #+end_src
  
** Helper to up the font size for a higher-res monitor.
*** Frame font selection
This little function toggles between a larger font size and the default font size.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Frame font selection

  (defvar mrf/font-size-slot 1)

  (defun mrf/update-font-size ()
      (message "adjusting font size")
      (cond
          ((equal mrf/font-size-slot 3)
              (message "X-Large Font")
              (setq custom-default-font-size mrf/x-large-font-size
                    mrf/default-variable-font-size (+ custom-default-font-size 20)
                    mrf/font-size-slot 2)
              (mrf/update-face-attribute))
          ((equal mrf/font-size-slot 2)
              (message "Large Font")
              (setq custom-default-font-size mrf/large-font-size
                    mrf/default-variable-font-size (+ custom-default-font-size 20)
                    mrf/font-size-slot 1)
              (mrf/update-face-attribute))
          ((equal mrf/font-size-slot 1)
              (message "Medium Font")
              (setq custom-default-font-size mrf/medium-font-size
                    mrf/default-variable-font-size (+ custom-default-font-size 20)
                    mrf/font-size-slot 0)
              (mrf/update-face-attribute))
          ((equal mrf/font-size-slot 0)
              (message "Small Font")
              (setq custom-default-font-size mrf/small-font-size
                    mrf/default-variable-font-size (+ custom-default-font-size 20)
                    mrf/font-size-slot 3)
              (mrf/update-face-attribute))
          )
      )

#+end_src

*** Resolution Key Bindings
Som key kindings to switch to different screen resolutions.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------
  ;; Some alternate keys below....

  (bind-keys ("C-c 1". use-small-display-font)
      ("C-c 2". use-medium-display-font)
      ("C-c 3". use-large-display-font)
      ("C-c 4". use-x-large-display-font))

#+end_src

*** Frame support functions
These functions are used to configure the main frame font size. Based upon a monitor's size, it may be necessary to make the font larger or smaller.

#+begin_src emacs-lisp 
  ;;; --------------------------------------------------------------------------
  ;; Frame support functions

  (defun mrf/set-frame-font (slot)
     (setq mrf/font-size-slot slot)
     (mrf/update-font-size)
     (mrf/frame-recenter)
     )

  (defun use-small-display-font ()
     (interactive)
     (mrf/set-frame-font 0)
     (mrf/frame-recenter)
     )

  (defun use-medium-display-font ()
     (interactive)
     (mrf/set-frame-font 1)
     (mrf/frame-recenter)
     )

  (defun use-large-display-font ()
     (interactive)
     (mrf/set-frame-font 2)
     (mrf/frame-recenter)
     )

  (defun use-x-large-display-font ()
     (interactive)
     (mrf/set-frame-font 3)
     (mrf/frame-recenter)
     )

  (when (display-graphic-p)
     (add-hook 'after-init-hook
         (lambda ()
  	   (progn
  	       (mrf/update-face-attribute)
  	       (mrf/frame-recenter)))
  	   ))

#+end_src

**** Lispy Footer
The standard =lisp= footer that should appear at the end of every =lisp= source file.

#+begin_src emacs-lisp
  ;;; --------------------------------------------------------------------------

  ;;; init.el ends here.
  
#+end_src
