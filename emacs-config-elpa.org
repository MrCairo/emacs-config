#+title: Mitch's Emacs Configuration Using Standard use-package
#+author: Mitch Fisher
#+date: 2024-05-11
#+options: toc:2 h:4
#+startup: showall
#+visibility: all
#+property: header-args:emacs-lisp :tangle ./init.el :results silent :exports code :mkdirp yes
#+modified-date: <2024-10-16 Wed>

* Table Of Contents
:PROPERTIES:
:TOC:      :include all :ignore this :depth 2
:End:

:CONTENTS:
- [[#synopsis][Synopsis]]
  - [[#tried-ideas][Tried Ideas]]
  - [[#early-init-file][Early init file]]
- [[#package-management][Package Management]]
  - [[#lispy-header][Lispy Header]]
  - [[#package-manager][Package Manager]]
  - [[#automatic-package-updates][Automatic Package Updates]]
- [[#customized-values][Customized Values]]
  - [[#customization-groups][Customization groups]]
  - [[#file-locations-and-variables][File Locations and Variables]]
  - [[#custom-feature-toggles][Custom Feature Toggles]]
  - [[#custom-feature-choices][Custom Feature Choices]]
  - [[#theme-options][Theme Options]]
- [[#default-behavior][Default Behavior]]
  - [[#landing-page][Landing Page]]
  - [[#create-toc][Create TOC]]
  - [[#better-defaults][Better Defaults]]
  - [[#emacsuser-config-directory][Emacs/User Config Directory]]
  - [[#additional-search-paths][Additional Search Paths]]
  - [[#save-history][Save History]]
  - [[#better-modes][Better Modes]]
  - [[#delight][Delight]]
  - [[#paren-mode-behavior][`paren` mode behavior]]
  - [[#some-helpful-registers-and-aliases][Some Helpful Registers and Aliases]]
  - [[#emacs-in-server-mode][Emacs in server mode]]
  - [[#mac-specific][Mac Specific]]
  - [[#mifis-minor-mode][MiFi's Minor Mode]]
  - [[#initial-scratch-buffer-message][Initial scratch buffer message]]
  - [[#exiting-and-cleanup][Exiting And Cleanup]]
  - [[#global-key-binding][Global key-binding]]
- [[#universal-packages][Universal Packages]]
  - [[#anzu][Anzu]]
  - [[#async][Async]]
  - [[#auto-complete][Auto-complete]]
  - [[#dumb-jump][Dumb Jump]]
  - [[#eldoc][Eldoc]]
  - [[#helpful-help-commands][Helpful Help Commands]]
  - [[#hydra][Hydra]]
  - [[#jinx][Jinx]]
  - [[#json-rpc][JSON-RPC]]
  - [[#simple-httpd][Simple-httpd]]
  - [[#thesaurus][Thesaurus]]
  - [[#which-key][Which Key]]
  - [[#yasnippet][YASnippet]]
- [[#operational-systems][Operational Systems]]
  - [[#undo-handlers][Undo Handlers]]
  - [[#completion-handlers][Completion Handlers]]
  - [[#terminals][Terminals]]
  - [[#file-management][File Management]]
- [[#window-management][Window Management]]
  - [[#ace-window][Ace Window]]
  - [[#golden-ratio][Golden Ratio]]
  - [[#popper][Popper]]
  - [[#swap-buffers][Swap Buffers]]
  - [[#writeroom-mode][Writeroom mode]]
  - [[#winner-mode][winner-mode]]
  - [[#winum][Winum]]
- [[#visuals][Visuals]]
  - [[#all-the-icons][All-the-icons]]
  - [[#default-text-scale][Default Text Scale]]
  - [[#diff-hl][Diff HL]]
  - [[#frame-and-font-setup][Frame and Font Setup]]
  - [[#grip-mode][GRIP Mode]]
  - [[#lisp-hightlighter][Lisp Hightlighter]]
  - [[#markdown-mode][Markdown Mode]]
  - [[#multiple-cursors][Multiple-cursors]]
  - [[#pulsar][Pulsar]]
  - [[#rainbow-mode][Rainbow-mode]]
  - [[#save--restore-frameset][Save / Restore Frameset]]
  - [[#solair-mode][Solair mode]]
  - [[#theme-list-and-selection][Theme List and Selection]]
  - [[#visual-fill][Visual Fill]]
- [[#productivity][Productivity]]
  - [[#org-mode][Org Mode]]
  - [[#org-journal][Org Journal]]
  - [[#org-roam][Org Roam]]
  - [[#denote][Denote]]
  - [[#projectile][Projectile]]
  - [[#projectel][Project.el]]
  - [[#gnus][Gnus]]
- [[#integrated-development-environment][Integrated Development Environment]]
  - [[#dashboard][Dashboard]]
  - [[#neotree][Neotree]]
  - [[#centaur-tabs][Centaur Tabs]]
  - [[#code-completion-and-handling][Code Completion and Handling]]
- [[#language-integration][Language Integration]]
  - [[#language-support-packages][Language Support Packages]]
  - [[#python][Python]]
  - [[#ocaml][OCaml]]
  - [[#javascript-based-languages][JavaScript based languages]]
  - [[#gameboy-development][GameBoy Development]]
  - [[#rust][Rust]]
  - [[#golang][Golang]]
  - [[#other-languages][Other Languages]]
  - [[#godot-script-mode][Godot Script Mode]]
  - [[#debug-support][Debug Support]]
- [[#lastly][Lastly]]
  - [[#ignore-line-number-mode][Ignore Line Number Mode]]
  - [[#supress-common-warnings][Supress common warnings]]
  - [[#lispy-footer][Lispy Footer]]
  - [[#ocaml-special-import][OCaml special import]]
:END:

* Synopsis

This ORG file will configure the  ~init.el~  file based upon all of the =emacs-lisp= source blocks. The =emacs-lisp= source blocks are defined in an organized order. While these blocks can generally be moved around, there are some order dependencies. So it's generally best that this order be preserved to prevent any compile-time issues.

*Note:* This particular file does not use ~elpaca~ but instead uses the built-in =use-package= functionality of Emacs. However, this org file also requires Emacs v30.0+ to work since the =use-package :vc= option is used to specify the remote version control repo and, optionally, the main list file.

- The goal of this Emacs configuration is to make an Emacs configuration that has a good collection of popular options. I actually use these different sets of packages based upon my work. Sometimes, Vertico, Consult, Corfu don't provide the right experience so I switch to Ivy. The same is true with debuggers. I prefer DAPE but sometimes it doesn't work as well as DAP/LSP, and so on.

While I'm trying to make a config that appeals to other people, most of what you see in here is for my personal dev projects in Python and other language and it also includes a sizable amount of e-lisp to continuously fiddle with.

So far, the following collections of options are included here:

:Features:
#+visibility: folded

- Landing Screen Options ::
  + Dashboard
  + IELM (Integrated Emacs Lisp Mode)
  + Default *scratch* buffer
  
- Completion Frameworks:
  + Vertico, Consult, orderless, marginalia, embark
  + Ivy, Counsel, Swiper
  + Corfu, oderless, cape eglot

- Customized Org mode
  
- Undo Handlers
  + =Vundo=
  + Undo-tree
    
- Debug Adapters
  + DAP

- Integrated Development Environments (IDE)
  + Elpy
  + Eglot
  + Stand-alone LSP
  + Merlin / Tuareg for OCaml
  + LSP Bridge (experimental)
    
- Project Options
  + Projectile
  + project.el
    
- Custom Themes
  + Several popular themes that are easy to cycle between and also good on the eyes.
    
- Other Optional Features
  + Game Boy Development Packages
  + Neo Tree
  + Golden Ratio
  + Embark
  + Customizable Menu (MmM)
:end:

--------------------------------------------------------------------------------

- This configuration requires Emacs 29.1+. It has been tested with Emacs 29.1 - 29.3 and Emacs 30

- This configuration only uses the standard =use-package=. It does assume that the =:vc= use-package option is available. This means that Emacs 29 will use.
  
- While this configuration includes support for several languages - and I mean support for syntax highlighting and, to some extent, debugging - this configuration caters to be a Python development environment.

- The C/C++ debugger for these type of programs are done via LSP/LLDB. The chosen =debug-adapter= custom variable doesn't apply. The reason for this is that the DAP/LSP/LLDB interaction doesn't work properly on my =Apple Silicon= mac. Until GDB supports =ARM= instruction sets then this (=RealGUD=) will remain as the only best way to support a more integrated debugging experience.

- Python is setup to use =dap=.

- If auto-tangling doesn't work because of a problem in the generated ~init.el~ file, then tangling can be done manually by either using ~(C-c C-v t)~ or by calling the =org-babel-tangle= M-x command.

- When starting this Configuration for the very first time, set the =use-package-always-ensure= variable to =t=. This will force all packages to be installed even if deferred. Make sure to set this value back to =nil= after everything is loaded otherwise Emacs startup time will be impacted.

- Take a look a the [[Customizable Values][Custom Variables]] and [[Customization groups][Groups]] section to see what options exist. It's important to note that these variables need to be adhered to.  Another thing to note is that the various =enable*= flags are not used as =:if= option in =use-package= statement. Instead, a lisp conditional statement is used so that the package is actually never loaded or installed. This improves overall startup performance.

- *Shout out to the many people in the Emacs community from which a lot of this configuration took inspiration from.*

  --------------------------------------------------------------------------------

** Tried Ideas
:properties:
:CUSTOM_ID: tried-ideas
:VISIBILITY: folded
:end:
  Some of the ideas that keep coming back and then leaving. It's worth while to keep a record of the ideas that have/were implemented at one point along with an outcome.

  1. Going between using ~elpaca~ or ~straight~ and just using plain Emacs ~use-package~.
     * I like the performancs of ~elpaca~ but I've sometimes run into issues when it fails to install packages where plain ~use-package~ would not fail. =:ensure= with a repo doesn't always help either.
       - I /have/ gotten and ~elpaca~ Emacs config to properly rebuild without issue but as I change (add/delete/update) the config, it doesn't always continue to work.
     * ~use-package~ isn't perfect either.
       
  2. Using separate =lisp/init-*= files as opposed to a single init.el. Some good, some bad.
     * Bad:  ~defvar~ variables must be re-declared in the =init=*= file in order to prevent warning messages. Not that it's *that* big a deal, just more of an annoyance.
     * Bad: It does make it more difficult to deal with functions that may be considered global. Can they go into the main init file, sure, but what about functions that are used for things like themes that will likely be defined in a separate init-* file.
     * Good: It seems to make the overall maintenance of Emac's init files easier since they're broken up and organized.
     * *For now, using a common ~org~ file seems to be the way to go.*
       
  3. Trying to pack in a lot of different languages and behaviors. It's great that I as a user can enable, disable and choose how my Emacs experience will be, it does make managing the Emacs config file more complex.
     * *Right now I pack as much as I can in as far as things I like (or could like) to use.*
** Early init file
:PROPERTIES:
:CUSTOM_ID: early-init-file
:VISIBILITY: folded
:END:

This is where all of the settings/setup goes for the ~early-init.el~ file.

*** Lispy Header for early-init.el
:properties:
:custom_id: lispy-header-for-early-initel
:visibility: folded
:end:

Standard fare and good practice.

#+begin_src emacs-lisp :tangle "early-init.el"
  ;;; early-init.el -*- flycheck-disabled-checkers: (emacs-lisp); lexical-binding: nil -*-
  ;;;
  ;;; Commentary:

  ;; Settings/Packages that need to be used early in the initialization process
  ;; of the Emacs startup. This file is executed before init.el.
  ;;
  ;;
  ;; DO NOT MODIFY this file directly as changes will be overwritten.
  ;; The source this file is generated from is from "emacs-config-elpa.org"

  ;;; Code:

#+end_src

*** Package archives
:PROPERTIES:
:CUSTOM_ID: package-archives
:visibility: folded
:END:

#+begin_src emacs-lisp :tangle "early-init.el" 
  ;;; ##########################################################################
  (setq package-vc-register-as-project nil) ; Emacs 30
  (add-hook 'package-menu-mode-hook #'hl-line-mode)

  (setq package-enable-at-startup t)

  ;; This allows for a set of PROXY variables/settings to be loaded before
  ;; we actually begin the load.
  (let
    ((file (expand-file-name "early-init-proxy.el" user-emacs-directory)))
    (when (file-exists-p file)
      (load file)))

  (setq package-archives
    '(("gnu-elpa" . "https://elpa.gnu.org/packages/")
       ("gnu-elpa-devel" . "https://elpa.gnu.org/devel/")
       ("nongnu" . "https://elpa.nongnu.org/nongnu/")
       ("melpa" . "https://melpa.org/packages/")))

  (setq package-archive-priorities
    '(
       ( "org" . 5 )
       ( "gnu" . 50 )
       ( "melpa-stable" . 40 )
       ( "melpa" . 30 )
       ( "gnu-dev" . 20 )
       ( "nongnu" . 10)
       ))

  ;;
  ;; I pull the whole mirror locally - it's not huge, 2.1 GB. If it's
  ;; available, add them to the start of the package-archives list.
  ;;
  (when (file-directory-p "/opt/local/elpa-mirror")
    ;; Make sure to refresh this local reppo often!!
    (add-to-list 'package-archives '("local-gnu" . "/opt/local/elpa-mirror/gnu") t)
    (add-to-list 'package-archives '("local-nongnu" . "/opt/local/elpa-mirror/nongnu") t)
    (add-to-list 'package-archives '("local-melpa" . "/opt/local/elpa-mirror/melpa") t)
    (add-to-list 'package-archives '("local-melpa-stable" . "/opt/local/elpa-mirror/stable-melpa") t)
    (add-to-list 'package-archive-priorities '( "local-gnu" . 99 ))
    (add-to-list 'package-archive-priorities '( "local-melpa" . 98 ))
    (add-to-list 'package-archive-priorities '( "local-nongnu" . 97))
    (add-to-list 'package-archive-priorities '( "local-melpa-stable" . 90 )))

  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3") ;; w/o this Emacs freezes when refreshing ELPA

#+end_src

*** Add =lisp=, =lisp/lang= to =load-path=
:PROPERTIES:
:CUSTOM_ID: add-lisp-lisplang-to-load-path
:visibility: folded
:END:

If there is a local =lisp= and/or =lisp/lang= directory in the ~user-emacs-directory~, then add them to the =load=path=.

#+begin_src emacs-lisp :tangle "early-init.el"
  ;;; ##########################################################################

  (let ( (lisp-dir (expand-file-name "lisp" user-emacs-directory))
         (lisp-lang-dir (expand-file-name "lisp/lang" user-emacs-directory)) )
    (when (file-directory-p lisp-dir)
      (add-to-list 'load-path lisp-dir))
    (when (file-directory-p lisp-lang-dir)
      (add-to-list 'load-path lisp-lang-dir)))

  (let ((minver "29.1"))
    (when (version< emacs-version minver)
      (error "Your Emacs is too old -- this config requires v%s or higher" minver)))

#+end_src

*** Configure use-package
:properties:
:CUSTOM_ID: configure-use-package
:VISIBILITY: folded
:end:

#+begin_src emacs-lisp :tangle "early-init.el" 

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (use-package use-package-ensure-system-package :ensure t)

  ;; For some reason, the function recentf-expand-file-name has been showing up
  ;; as 'undefined' even though this is a byte-compiled internal function. So,
  ;; instead of trying to find the issue, I'm just including it here as a
  ;; local package so that it works. Maybe one day I can remove it.
  ;; (use-package recentf :ensure nil :demand t)
  (use-package recentf :ensure nil :demand t)

  ;;
  ;; For use-package-always-ensure to t If the 'elpa' directory is missing.
  ;; It's a simple way to more intelligently determine if packages should
  ;; more aggressively be required. The good thing is that the user doesn't
  ;; have to manually change the value just for a clean install.
  ;;
  (if (file-directory-p (expand-file-name "elpa" user-emacs-directory))
    (setq use-package-always-ensure nil)
    (setq use-package-always-ensure t))

  (setq use-package-compute-statistics t
    use-package-verbose t
    use-package-always-demand nil
    use-package-always-defer nil)

#+end_src

*** GC and Performance Tuning
:properties:
:custom_id: gc-and-performance-tuning
:visibility: folded
:end:

#+begin_src emacs-lisp :tangle "early-init.el"
  ;;; ##########################################################################
  ;;; Set high for initial startup
  (setq gc-cons-threshold (* 1024 1024 100))
  (setq gc-cons-percentage 0.3)

  ;; Process performance tuning

  (setq read-process-output-max (* 64 1024))
  (setq process-adaptive-read-buffering nil)

  (add-hook 'emacs-startup-hook
    (lambda ()
      (setq startup-time-message
        (format "Emacs read in %.2f seconds with %d garbage collections."
          (float-time (time-subtract after-init-time before-init-time))
          gcs-done))
      (message startup-time-message)))

#+end_src

*** Set executable PATHs
:properties:
:custom_id: set-executable-paths
:visibility: folded
:end:

Because in macOS, Emacs could be started outside of a shell (like an application on the Dock), this code is used to migrate the <current user's shell path to Emacs ~exec-path~.

#+begin_src emacs-lisp :tangle "early-init.el"
  ;;; ##########################################################################

  (defconst *is-a-mac* (eq system-type 'darwin))

  (defun mifi/setup-path-from-exec-path ()
    "Sets the environment PATH from the the `exec-path' list using the OS's
  defined path-separator."
    (interactive)
    (let ((path-from-exec-path (string-join exec-path path-separator)))
      (setenv "PATH" path-from-exec-path)))

  (defun mifi/setup-exec-path ()
    "A list of customized executable paths for standard Linux and macOS
  (and possibly) other UN*X type environments."
    (interactive)
    (cond
      ((eq system-type 'darwin)
        (setq exec-path
          '( "~/.cargo/bin" "~/.local/bin"
             "/opt/homebrew/bin" "/opt/homebrew/sbin"
             "/Library/Frameworks/Python.framework/Versions/Current/bin"
             "/usr/local/sbin" "/usr/local/bin" "/usr/sbin" "/usr/bin"
             "/sbin" "/bin" "/opt/local/bin")))
      ((eq system-type 'gnu/linux)
        (setq exec-path
          '( "/usr/local/sbin" "/usr/local/bin" "/usr/sbin" "/usr/bin"
             "/sbin" "/bin" "/usr/local/games" "/usr/games")))
      (t ;; default to something
        (setq exec-path '( "/usr/local/sbin" "/usr/local/bin"
                           "/usr/sbin" "/usr/bin"))))
    (when (file-directory-p "/usr/local/go/bin")
      (add-to-list 'exec-path "/usr/local/go/bin"))    
    (mifi/setup-path-from-exec-path))

  (when *is-a-mac*
    (setq browse-url-firefox-program
      "/Applications/Firefox.app/Contents/MacOS/firefox")
    (setq browse-url-chrome-program
      "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"))

  (add-hook 'before-init-hook #'mifi/setup-exec-path)

#+end_src

*** Lispy end of early-init.el
:properties:
:custom_id: lispy-end-of-early-initel
:visibility: folded
:TOC:      :ignore this
:end:

Standard fare and good practice.

#+begin_src emacs-lisp :tangle "early-init.el" 
  ;;; early-init.el ends here.
#+end_src

* Package Management
:properties:
:custom_id: package-management
:visibility: folded
:end:

** Lispy Header
:properties:
:custom_id: lispy-header
:visibility: folded
:end:

This is the standard format of a =lisp= header that should appear for all =lisp= scripts. It also indicates that the ~init.el~ file is generated from this ~Configure.org~ file.

#+begin_src emacs-lisp
  ;;; init.el -*- flycheck-disabled-checkers: (emacs-lisp); lexical-binding: nil -*-
  ;;;
  ;;; Commentary:

  ;; This file bootstraps the configuration which is generated from tangling an org-mode file.
  ;; DO NOT MODIFY this file directly as changes will be overwritten.
  ;; The source this file is generated from is from "emacs-config-elpa.org"

  ;;; Code:

  ;; Produce backtraces when errors occur: can be helpful to diagnose startup issues
  ;; (setq debug-on-error t)
  ;;

#+end_src

** Package Manager
:properties:
:custom_id: package-manager
:visibility: folded
:end:

Contrary to what some users might think, =use-package= is not a package
manager. To download and use packages that are not available in package sources,
I use [[https://github.com/raxod502/straight.el][straight]]. The snippet below takes care of installing =straight=.

#+begin_src emacs-lisp :tangle no
  ;; Bootstrap straight
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Integrates `straight' directly into the `use-package' package through the
  ;; `:straight' expression.
  (straight-use-package 'use-package)
#+end_src

** Automatic Package Updates
:properties:
:custom_id: automatic-package-updates
:visibility: folded
:end:

The auto-package-update package helps us keep our Emacs packages up to date! It will prompt you after a certain number of days either at startup or at a specific time of day to remind you to update your packages.

You can also use =M-x auto-package-update-now= to update right now!


#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Automatic Package Updates

  (use-package auto-package-update
    ;; :ensure (:fetcher github :repo "rranelli/auto-package-update.el")
    :ensure t
    :defer t
    :custom
    (auto-package-update-interval 7)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe)
    (auto-package-update-at-time "09:00"))

#+end_src

* Customized Values
:properties:
:custom_id: customized-values
:visibility: folded
:end:

Variables that define the operational behavior of this Emacs installation. These can be accessed via the built-in Customize menus.

** Customization groups
:properties:
:custom_id: customized-groups
:visibility: folded
:end:

These are the groups used by this Emacs config for customization.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Define my customization groups

  (defgroup mifi-config nil
    "M.R. Fisher's configuration section."
    :group 'Local)

  (defgroup mifi-config-toggles nil
    "A set of toggles that enable or disable specific packages or behaviors."
    :group 'mifi-config)

  (defgroup mifi-config-features nil
    "Customization from a selection of a curated list of features and handlers."
    :group 'mifi-config)

  (defgroup mifi-config-fonts nil
    "Customization of fonts and font sizes."
    :group 'mifi-config)

  (defgroup mifi-config-theming nil
    "Custom theming list and list index values."
    :group 'mifi-config)

  (defconst *is-a-mac* (eq system-type 'darwin))

#+end_src

** File Locations and Variables
:properties:
:custom_id: file-locations-and-variables
:visibility: folded
:end:

#+begin_src emacs-lisp
   ;;; ##########################################################################

  (defcustom custom-emacs-home
    (expand-file-name "emacs-home" "~/")
    "The base directory to where emacs user-operation files are stored. This is
  in contrast to the `emacs-config-directory' where all the initialization and
  configuration of Emacs are stored."
    :type 'string
    :group 'mifi-config)

  (defcustom custom-docs-directory
    (expand-file-name "emacs-docs" custom-emacs-home)
    "A directory used to store documents and customized data."
    :type 'string
    :group 'mifi-config)

  (defcustom custom-developer-root
    (expand-file-name "Developer/src" "~/")
    "The root of all development projects. Used when initializing project.el or
       projectile."
    :type 'string
    :group 'mifi-config)

  (defcustom working-files-directory
    (expand-file-name "emacs-working-files" custom-emacs-home)
    "The directory where to store Emacs working files. `user-emacs-directory'
  will also be set to this directory. The starting user-emacs-directory will
  become `emacs-config-directory'."
    :type 'string
    :group 'mifi-config)

  #+end_src

#+begin_src emacs-lisp

    (defcustom custom-org-fill-column 120
      "The fill column width for Org mode text. Note that the text is also centered
    on the screen so that should be taken into consideration when providing a
    width."
      :type 'natnum
      :group 'mifi-config)
    
#+end_src

** Custom Feature Toggles
:properties:
:custom_id: custom-package-toggles
:visibility: folded
:end:

Thes values toggle the availability of specific packages. These options are not grouped together as can be done with the =mifi-config-features= group so are all separate values.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Feature Toggles

  (defcustom enable-centaur-tabs nil
    "Set to t to enable `centaur-tabs' which uses tabs to represent open buffer."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-embark nil
    "Set to t to enable the Embark package."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-frameset-restore t
    "Set to t to enable restoring the last Emacs window size and position
     upon startup."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-gb-dev nil
    "If set to t, the z80-mode and other GameBoy related packages
      will be enabled."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-golden-ratio nil
    "Set to t to enable `golden-ratio-mode' which resizes the active buffer
     window to the dimensions of a golden-rectangle"
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-ocaml nil
    "Set to t to enable inclusion of OCaml support: Merlin, Tuareg."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-org-fill-column-centering nil
    "Set to t to center the visual-fill column of the Org display."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-python t
    "Set to t to enable Python language support."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-neotree nil
    "Set to t to enable the `neotree' package."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-thesaurus t
    "When set to t, enables the Merriam-Webster Thesaurus."
    :type 'boolean
    :group 'mifi-config-toggles)

  (defcustom enable-ts nil
    "Set to t to enable TypeScript handling."
    :type 'boolean
    :group 'mifi-config-toggles)

#+end_src

** Custom Feature Choices
:properties:
:custom_id: custom-feature-choices
:visibility: folded
:end:

These are features that basically have multiple-choice options instead of being a typical binary t or nil.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defcustom default-landing-mode 'landing-mode-scratch
    "Select which landing screen to end up on once Emacs has finished
  launching.

  Dashboard provides an overview of items and tasks such as recent files,
  agendas, projects, and bookmarks. The Dashboard appears in the *dashboard*
  buffer and can also be opened using \"C-c d\" or \"M-RET d\" from anywhere
  with the MmM mode enabled.

  Scratch is the standard *scratch* buffer that Emacs provides but has a slightly
  different startup message. It continues to be a place to write things or test
  out Lisp expressions.

  IELM (Inferior Emacs Lisp Mode) is a more interactive Lisp environment over the
  ,*scratch* buffer.

  eshell is the Emacs shell environment that is part terminal and part Lisp
  interpreter."
    :type '(radio
             (const :tag "Dashboard" landing-mode-dashboard)
             (const :tag "*scratch*" landing-mode-scratch)
             (const :tag "IELM" landing-mode-ielm)
             (const :tag "eshell" landing-mode-eshell))
    :group 'mifi-config-features)

  (defcustom undo-handler 'undo-handler-vundo
    "Select the undo handler to use.

  Vundo is a minimalistic undo handler that provides a simple, graphical undo
  horizontal tree.

  Undo-tree is a very mature and full featured undo handler. It also has the
  capability to persist undo history across Emacs sessions.

  Finally, the standard undo handler can also be chosen."
    :type '(radio
             (const :tag "Vundo (default)" undo-handler-vundo)
             (const :tag "Undo-tree" undo-handler-undo-tree)
             (const :tag "Built-in" undo-handler-built-in))
    :group 'mifi-config-features)

  (defcustom completion-handler 'comphand-vertico
    "Select the default minibuffer completion handler.

  Vertico provides a performant and minimalistic minibuffer vertical completion
  UI based on the default completion system. Corfu provides a
  completion-at-point feature in main buffers. Cape provides Corfu with
  additional completion-at-point backends to use.

  Ivy is a generic completion mechanism for Emacs. While it operates similarly to
  other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
  smaller, simpler, and smoother to use yet highly customizable.  The Ivy package
  also includes Counsel. Counsel provides completion versions of common Emacs
  commands that are customised to make the best use of Ivy.  Swiper is an
  alternative to isearch that uses Ivy to show an overview of all matches."
    :type '(radio
             (const :tag "Vertico, Orderless, Consult, Embark completion system." comphand-vertico)
             (const :tag "Ivy, Counsel, Swiper completion systems" comphand-ivy)
             (const :tag "Helm" comphand-helm)
             (const :tag "Corfu, Orderless, Cape" comphand-corfu)
             (const :tag "Built-in Ido" comp-hand-ido))
    :group 'mifi-config-features)

  ;; The debug-adapter used to also support DAPE. For now, that option has been
  ;; removed since DAP has more language coverage - especially for OCaml.
  ;; However, the variable will remain as an option so that not all code has to
  ;; be changed plus it allows for future debug-adapter support if a new one
  ;; becomes supported in this configuration.
  (defcustom debug-adapter 'debug-adapter-dap-mode
    "Select the debug adapter to use for debugging applications.  dap-mode is an
  Emacs client/library for Debug Adapter Protocol is a wire protocol for
  communication between client and Debug Server. It’s similar to the LSP but
  provides integration with debug server."
    :type '(radio
             (const :tag "Debug Adapter Protocol (DAP)" debug-adapter-dap-mode))
    :group 'mifi-config-features)

  (defcustom custom-ide 'custom-ide-eglot
    "Select which IDE will be used for Python development.

  Elpy is an Emacs package to bring powerful Python editing to Emacs. It
  combines and configures a number of other packages, both written in Emacs
  Lisp as well as Python. Elpy is fully documented at
  https://elpy.readthedocs.io/en/latest/index.html.

  Eglot/LSP Eglot is the Emacs client for the Language Server Protocol
  (LSP). Eglot provides infrastructure and a set of commands for enriching the
  source code editing capabilities of Emacs via LSP. Eglot itself is
  completely language-agnostic, but it can support any programming language
  for which there is a language server and an Emacs major mode."
    :type '(radio
             (const :tag "Elpy: Emacs Lisp Python Environment" custom-ide-elpy)
             (const :tag "Emacs Polyglot (Eglot)" custom-ide-eglot)
             (const :tag "Language Server Protocol (LSP)" custom-ide-lsp)
             (const :tag "LSP Bridge (standalone)" custom-ide-lsp-bridge))
    :group 'mifi-config-features)

  (defcustom custom-project-handler 'custom-project-project-el
    "Select which project handler to use."
    :type '(radio (const :tag "Projectile" custom-project-projectile)
             (const :tag "Built-in project.el" custom-project-project-el))
    :group 'mifi-config-features)

  (defcustom custom-note-system 'custom-note-system-denote
    "Select which note-taking/knowledge system will be used.

  The simpler, more efficient and lightweight for just simple note is `denote'.
  `Denote' is a simple note-taking tool for Emacs. It is based on the idea that
  notes should follow a predictable and descriptive file-naming scheme. The file
  name must offer a clear indication of what the note is about, without reference
  to any other metadata. Denote basically streamlines the creation of such files
  while providing facilities to link between them.

  A more full-featured note and other productivity tools like agenda, and todo is
  `org-roam'. Org-roam allows for effortless non-hierarchical note-taking: with
  Org-roam, notes flow naturally, making note-taking fun and easy. Org-roam
  augments the Org-mode syntax, and will work for anyone already using Org-mode
  for their personal wiki."
    :type '(radio
             (const :tag "Denote" custom-note-system-denote)
             (const :tag "Org Roam" custom-note-system-org-roam)
             (const :tag "Org Journal" custom-note-system-org-journal)
             (const :tag "None" custom-note-system-none))
    :group 'mifi-config-features)

#+end_src

** Theme Options
:properties:
:custom_id: theme-options
:visibility: folded
:end:

This is a curated selection of themes that I personally like. Most of them are dark mode but there are a few light versions. New themes can be added here or done via the =customize= interface. If a new theme is added to this list, it's important to ensure that the theme is actually included (see [[Color Theming][Color Theming]] section)

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Theming related

  (defcustom theme-list '( "palenight-deeper-blue"
                           "ef-symbiosis"
                           "ef-maris-light"
                           "ef-maris-dark"
                           "ef-kassio"
                           "ef-bio"
                           "ef-dream"
                           "ef-deuteranopia-dark"
                           "sanityinc-tomorrow-bright"
                           "ef-melissa-dark"
                           "darktooth-dark"
                           "material"
                           "tron-legacy")

    "My personal list of themes to cycle through indexed by `theme-selector'.
  If additional themes are added, they must be previously installed."
    :group 'mifi-config-theming
    :type '(repeat string))

  (defcustom default-terminal-theme "sanityinc-tomorrow-bright"
    "The default theme used for a terminal invocation of Emacs."
    :group 'mifi-config-theming
    :type 'string)

  (defcustom theme-selector 0
    "The index into the list of custom themes."
    :group 'mifi-config-theming
    :type 'natnum)

  ;;; Font related
  (defcustom default-font-family "Source Code Pro"
    "The font family used as the default font."
    :type 'string
    :group 'mifi-config-fonts)

  (defcustom mono-spaced-font-family "Source Code Pro"
    "The font family used as the mono-spaced font."
    :type 'string
    :group 'mifi-config-fonts)

  (defcustom variable-pitch-font-family "JetBrains Mono"
    "The font family used as the default proportional font."
    :type 'string
    :group 'mifi-config-fonts)

  (defcustom variable-pitch-font-weight 'light
    "The 'suggested' weight of the variable-pitch-font. The reason that it is
  suggested is that the font family may not support one of the weight values
  listed below."
    :type '(radio
             (const :tag "ultra-bold" ultra-bold)
             (const :tag "extra-bold" extra-bold)
             (const :tag "bold" bold)
             (const :tag "semi-bold" semi-bold)
             (const :tag "normal" normal)
             (const :tag "semi-light" semi-light)
             (const :tag "light" light)
             (const :tag "extra-light" extra-light)
             (const :tag "ultra-light" ultra-light))
    :group 'mifi-config-fonts)

  (defcustom small-mono-font-size 150
    "The small font size in pixels."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defcustom medium-mono-font-size 170
    "The medium font size in pixels."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defcustom large-mono-font-size 190
    "The large font size in pixels."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defcustom x-large-mono-font-size 220
    "The extra-large font size in pixels."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defcustom small-variable-font-size 170
    "The small font size in pixels."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defcustom medium-variable-font-size 190
    "The small font size in pixels."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defcustom large-variable-font-size 210
    "The small font size in pixels."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defcustom x-large-variable-font-size 240
    "The small font size in pixels."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defcustom custom-default-font-size 170
    "A place to store the most current (face-attribute 'default :height).  This
  is specifically for the mono-spaced and default font. The variable type-face
  font size is computed + 20 of this value."
    :type 'natnum
    :group 'mifi-config-fonts)

  (defvar custom-default-mono-font-size 170
    "Storage for the current mono-spaced font height.")

  (defvar theme-did-load nil
    "Set to true if the last Theme was loaded.")

#+end_src

*** Verify Default variable-pitch Font
:properties:
:custom_id: verify-default-variable-pitch-font
:visibility: folded
:end:

Look for a proportional font that is available on the OS. If the actual default font isn't available, find another that will work instead.

:MiFi-validate-prop-font-func:
#+visibility: folded

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/validate-variable-pitch-font ()
    (when (display-graphic-p)
      (let* ((variable-pitch-font
               (cond
                 ((x-list-fonts variable-pitch-font-family) variable-pitch-font-family)
                 ((x-list-fonts "SF Pro")           "SF Pro")
                 ((x-list-fonts "DejaVu Sans")      "DejaVu Sans")
                 ((x-list-fonts "Ubuntu")           "Ubuntu")
                 ((x-list-fonts "Helvetica")        "Helvetica")
                 ((x-list-fonts "Source Sans Pro")  "Source Sans Pro")
                 ((x-list-fonts "Lucida Grande")    "Lucida Grande")
                 ((x-list-fonts "Verdana")          "Verdana")
                 ((x-family-fonts "Sans Serif")     "Sans Serif")
                 (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro.")))))
        (if variable-pitch-font
        (when (not (equal variable-pitch-font variable-pitch-font-family))
            (setq variable-pitch-font-family variable-pitch-font))
        (message "---- Can't find a variable-pitch font to use.")))
      (message (format "=== variable-pitch font is %s" variable-pitch-font-family))))

#+end_src

*** Verify Default mono-space font
:properties:
:custom_id: verify-default-mono-space-font
:visibility: folded
:end:

Look for a proportional font that is available on the OS. If the actual default font isn't available, find another that will work instead.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/validate-monospace-font ()
    (when (display-graphic-p)
      (let* ((monospace-font
               (cond
                 ((x-list-fonts mono-spaced-font-family) mono-spaced-font-family)
                 ((x-list-fonts "Source Code Pro")   "Source Code Pro")
                 ((x-list-fonts "Fira Code Retina")  "Fira Code Retina")
                 ((x-list-fonts "Fira Code")         "Fira Code")
                 ((x-list-fonts "Ubuntu Monospaced") "Ubuntu Monospaced")
                 ((x-family-fonts "Monospaced")      "Monospaced")
                 (nil (warn "Cannot find a monospaced Font.  Install Source Code Pro.")))))
        (if monospace-font
  	(when (not (equal monospace-font variable-pitch-font-family))
            (setq mono-spaced-font-family monospace-font)
            (setq default-font-family monospace-font))
  	(message "---- Can't find a monospace font to use.")))
      (message (format "=== monospace font is %s" mono-spaced-font-family))))
  
#+end_src

* Default Behavior
:properties:
:custom_id: default-behavior
:visibility: folded
:end:

Setup initial paths, global values and settings, and Emacs working directories.

** Landing Page
:properties:
:custom_id: landing-page
:visibility: folded
:end:

Since we are adding to the LIFO list of things to run _after_ elpaca is done initializing, the first entry in the list is the last thing run. Updating and switching to the landing page should be done after everything else is done initializing. This way, things like the *Messages* buffer won't be displayed instead of the landing page.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;
  ;; This list is processed as a LIFO queue. This entry _should_ be made to be
  ;; the first so it executes last.
  (add-hook 'after-init-hook
    (lambda ()
      (mifi/config-landing)
      (mifi/set-recenter-keys)))

#+end_src

** Create TOC

#+begin_src emacs-lisp

  (use-package org-make-toc
    :after org
    :defer t
    :ensure t)

#+end_src

:properties:
:custom_id: create-toc
:visibility: folded
:end:

This package contains functions to create an in-org file table of contents.

#+begin_src emacs-lisp

  (use-package org-make-toc
    :ensure t)

#+end_src

** Better Defaults
:properties:
:custom_id: better-defaults
:visibility: folded
:end:

These are global variables that effect the behavior of Emacs in general. These values represent a better set of defaults than the standard, vanilla values.

#+begin_src emacs-lisp

  (setq-default
    ad-redefinition-action 'accept                   ; Silence warnings for redefinition
    backup-inhibited t                               ; diabled backup (no ~ tilde files)
    cursor-in-non-selected-windows nil               ; Hide the cursor in inactive windows
    display-time-default-load-average nil            ; Don't display load average
    fill-column 80                                   ; Set width for automatic line breaks
    help-window-select t                             ; Focus new help windows when opened
    history-length 30                                ; Reasonable number of items
    indent-tabs-mode nil                             ; Prefer spaces over tabs
    inhibit-startup-screen t                         ; Disable start-up screen
    kill-ring-max 128                                ; Maximum length of kill ring
    lisp-indent-offset '2                            ; Emacs list tab size
    load-prefer-newer t                              ; Prefer the newest version of a file
    mark-ring-max 128                                ; Maximum length of mark ring
    read-process-output-max (* 1024 1024)            ; Increase the amount of data reads from the process
    scroll-conservatively most-positive-fixnum       ; Always scroll by one line
    select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
    tab-width 4                                      ; Set width for tabs
    truncate-lines 1                                 ; Long lines of text do not wrap
    truncate-partial-width-windows 1                 ; truncate lines in partial-width windows
    user-full-name "Mitchell Fisher"                 ; Set the full name of the current user
    user-mail-address "Trafalgar42@gmail.com"        ; Set the email address of the current user
    vc-follow-symlinks t                             ; Always follow the symlinks
    view-read-only t                                 ; Always open read-only buffers in view-mode
    visible-bell t)                                  ; Set up the visible bell

  (column-number-mode 1)                             ; Show the column number
  (fset 'yes-or-no-p 'y-or-n-p)                      ; Replace yes/no prompts with y/n
  ;; (global-hl-line-mode)                              ; Hightlight current line
  (set-default-coding-systems 'utf-8)                ; Default to utf-8 encoding
  (show-paren-mode 1)                                ; Show the parent
  ;; Rebind C-z/C-. to act like vim's repeat previous command ( . )
  (unbind-key "C-z")
  (bind-key "C-z" 'repeat-complex-command)
  (bind-key "C-+" 'repeat)

#+end_src

#+begin_src emacs-lisp :tangle no

  ;;; ##########################################################################

  (setq-default
    auto-save-default nil     ;; disable auto save
    dired-dwim-target t       ;; try to guess target directory
    frame-inhibit-implied-resize t
    frame-resize-pixelwise t
    global-auto-revert-mode 1 ;; Refresh buffer if file has changed
    global-eldoc-mode t       ;; Enabled in all buffers
    sentence-end-double-space nil
    truncate-lines 1          ;; long lines of text do not wrap
    truncate-partial-width-windows 1 ;; truncate lines in partial-width windows
    window-resize-pixelwise t
    window-resize-pixelwise t ;; enable smooth resizing
    ;; Triggers project for directories with any of the following files:
    global-auto-revert-non-file-buffers t
    project-vc-extra-root-markers '(".dir-locals.el"
                                     "requirements.txt"
                                     "Gemfile"
                                     "package.json"))

  ;; Since there used to be a supported dape mode, we force the
  ;; existing configuration to the only option, dap-mode since
  ;; dape used to be supported. This resets any previous value.
  (setq-default debug-adapter 'debug-adapter-dap-mode)

#+end_src

** Emacs/User Config Directory

By default, the =user-emacs-directory= points to the .emacs.d* directory from which the =init.el= is used when Emacs starts. What this means is that any package that writes to this directory will be writing files to this initialization directory. Since we want to keep this directory clean, we set this directory to something external. A new variable, =emacs-config-directory= is set to now point to the starting Emacs condfiguration directory.

*** Files API
:properties:
:custom_id: files-api
:visibility: folded
:end:

This is the excellent 'F' package. This is a more "friendly/modern" API for working with files and directories in Emacs.

#+begin_src emacs-lisp

  ;;; ##########################################################################

  (use-package f
    :ensure t :demand t)

#+end_src

*** Dirs
:properties:
:custom_id: dirs
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;;; Set a variable that represents the actual emacs configuration directory.
  ;;; This is being done so that the user-emacs-directory which normally points
  ;;; to the .emacs.d directory can be re-assigned so that customized files don't
  ;;; pollute the configuration directory. This is where things like YASnippet
  ;;; snippets are saved and also additional color themese are stored.

  (defvar emacs-config-directory user-emacs-directory)

  ;;; Put any emacs cusomized variables in a special file. Load this file early
  ;;; since things like the working-files-directory or custom-docs-directory
  ;;; customized values could be in this file.
  (setq custom-file (expand-file-name "customized-vars.el" emacs-config-directory))

  (unless (file-exists-p custom-file) ;; create custom file if it doesn't exists
    (write-region "" nil custom-file))
  (load custom-file 'noerror 'nomessage)

  ;;;
  ;;; This directory stores any files that are used by the user to store
  ;;; additional Emacs files, like themes or specialized moduls. This is
  ;;; where emacs-config files are backed up to. Of course, any document that the
  ;;; user wants to associate with an Emacs installation can be stored here.
  (message "=== working-files-dir = %s" working-files-directory)
  (make-directory working-files-directory t)

  ;;; user-emacs-directory always ends in a "/" so we need to make the
  ;;; working-files-directory act the same since it becomes the new
  ;;; user-emacs-directory. So, add a "/" if there isn't one already.
  (unless (string-suffix-p "/" working-files-directory)
    (setq working-files-directory (concat working-files-directory "/")))

  ;;; Point the user-emacs-directory to the new working directory
  (setq user-emacs-directory working-files-directory)

  ;;; Add an additional INFO dir for custom info docs
  (let ((infodir (expand-file-name "share/info" custom-docs-directory)))
    (unless (file-exists-p infodir)
      (make-directory infodir t)))

  ;; ensure that the loaded font values are supported by this OS. If not, try
  ;; to correct them.
  (mifi/validate-variable-pitch-font)
  (mifi/validate-monospace-font)

#+end_src

** Additional Search Paths
:properties:
:custom_id: additional-search-paths
:visibility: folded
:end:

This directory is expected to be in the ~emacs-config-direcory~ dir. This can be used to store custom lisp (or non-elpa/melpa) files that can'tbe found by =require.el= or =straight-use-package=.


#+begin_src emacs-lisp
  ;;; ##########################################################################

  (let ((epath (f-dirname
                 (expand-file-name invocation-name invocation-directory))))
    (when (file-directory-p (format "%s/bin" epath))
      (add-to-list 'exec-path (format "%s:%s/bin" epath epath))
      (mifi/setup-path-from-exec-path)))

  ;; mostly for OCaml
  (add-to-list 'load-path (expand-file-name "." emacs-config-directory))
  (add-to-list 'custom-theme-load-path (expand-file-name "Themes" custom-docs-directory))

#+end_src

*** Add =site-lisp= directories to ~load-path~
:properties:
:custom_id: add-site-lisp-directories-to-load-path
:visibility: folded
:end:

The =site-lisp= directory in the ~emacs-config-directory~ can hold local (site) specific packages that are not available through the standard package archives.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; Add both site-lisp and its immediate subdirs to `load-path'
  (let ((site-lisp-dir (expand-file-name "site-lisp/" emacs-config-directory)))
    (when (file-directory-p site-lisp-dir)
      (push site-lisp-dir load-path)
      ;; Add every non-hidden subdir of PARENT-DIR to `load-path'.
      (let ((default-directory site-lisp-dir))
        (setq load-path
          (append
            (cl-remove-if-not
              #'file-directory-p
              (directory-files (expand-file-name site-lisp-dir) t "^[^\\.]"))
            load-path)))))

#+end_src

** Save History
:properties:
:custom_id: save-history
:visibility: folded
:end:

Keeps a persistent history file across Emacs restarts. It's also saved into the ~user-emacs-directory~ so it's not tied to a specific Emacs installation directory.

:save-history:
#+visibility: folded

#+begin_src emacs-lisp
  ;;; ##########################################################################
  
  (setq savehist-file (expand-file-name "savehist" user-emacs-directory))
  (savehist-mode t)
  (setq history-length 150)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history 1)
  (setq savehist-additional-variables
    '(kill-ring
       search-ring
       regexp-search-ring))

#+end_src
:end:

** Better Modes
:properties:
:custom_id: better-modes
:visibility: folded
:end:

Calls to mode functions that effect various Emacs behavior.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; (global-display-line-numbers-mode 1) ;; Line numbers appear everywhere
  ;; A cool mode to revert a window configuration
  (winner-mode 1)
  (save-place-mode 1)                  ;; Remember where we were last editing a file.
  (column-number-mode 1)
  (tool-bar-mode -1)                   ;; Hide the toolbar
  (global-prettify-symbols-mode 1)     ;; Display pretty symbols (i.e. λ = lambda)
  (repeat-mode 0)                      ;; Also in MmM
  ;; (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  ;; Key binding to use "hippie expand" for text autocompletion
  ;; http://www.emacswiki.org/emacs/HippieExpand
  (global-set-key (kbd "C-c C-/") 'hippie-expand)
  ;; Lisp-friendly hippie expand
  (setq hippie-expand-try-functions-list
    '( try-expand-dabbrev
       try-expand-dabbrev-all-buffers
       try-expand-dabbrev-from-kill
       try-complete-lisp-symbol-partially
       try-complete-lisp-symbol))
  
  (setq-default project-vc-extra-root-markers '( ".dir-locals.el"
                                                 "requirements.txt"
                                                 "Gemfile"
                                                 "package.json" ))

  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    "Prevent annoying \"Active processes exist\" query when you quit Emacs."
    (cl-letf (((symbol-function #'process-list) (lambda ())))
      ad-do-it))

#+end_src

** Delight
:properties:
:custom_id: delight
:visibility: folded
:end:

Delight enables you to customize the mode names displayed in the mode line. It's different from =diminish= in that this can be configured to work with both major and minor modes.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/delight-config ()
    (interactive)
    (delight '( (abbrev-mode " Abv" abbrev)
                (anaconda-mode)
                (buffer-face-mode "Buff")
                (counsel-mode)
                (golden-ratio-mode " 𝜑")
                (lisp-interaction-mode " 𝝺")
                (mmm-keys-minor-mode " m3")
                (projectile-mode " ->")
                (tree-sitter-mode " ts")
                (eldoc-mode " 📖")
                (overwrite-mode " Ov" t)
                (python-mode " Py" :major)
                (rainbow-mode " 🌈")
                (emacs-lisp-mode "Elisp" :major))))

  (use-package delight
    :ensure t
    :demand t
    :hook (elpaca-after-init . mifi/delight-config))

#+end_src

** `paren` mode behavior
:properties:
:custom_id: paren-mode-behavior
:visibility: folded
:end:

This package is used to highlight matching delimters '( { [ < > ] } )

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package paren
    :ensure nil
    :custom
    show-paren-delay 0.1
    show-paren-highlight-openparen t
    show-paren-when-point-inside-paren t
    show-paren-when-point-in-periphery t
    show-paren-context-when-offscreen t
    :config
    (show-paren-mode 1))

#+end_src

** Some Helpful Registers and Aliases
:properties:
:custom_id: some-helpful-registers-and-aliases
:visibility: folded
:end:

This local package defines some commonly used registers. Registers need to be loaded after the initial happens hence the call to initialize the registers via a hook.

#+begin_src emacs-lisp

  (defun mifi/setup-helpful-aliases ()
    "Define some helpful aliases."
    (defalias 'visibility-folded
      (kmacro "# + v i s i b i l i t y : SPC f o l d e d <return>")))

#+end_src

#+begin_src emacs-lisp

  (defun mifi/setup-common-registers ()
    "Define some common registers."
    (setq register-preview-delay 0) ;; Show registers ASAP
    (setq reg-elpa '?c
          reg-elpaca '?C)
    (set-register reg-elpa (cons 'file (concat emacs-config-directory "emacs-config-elpa.org")))
    (set-register reg-elpaca (cons 'file (concat emacs-config-directory "emacs-config-elpaca.org")))
    (set-register ?G '(file . "~/Developer/game-dev/GB_asm"))
    (set-register ?S (cons 'file (concat emacs-config-directory "org-files/important-scripts.org"))))

  #+end_src
  
  #+begin_src emacs-lisp

    (add-hook 'after-init-hook
      (lambda ()
        (mifi/setup-helpful-aliases)
        (mifi/setup-common-registers)))

#+end_src

** Emacs in server mode
:properties:
:custom_id: emacs-in-server-mode
:visibility: folded
:end:

Handle the case of starting the Emacs server when Emacs is started as a foreground or background daemon.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; Allow access from emacsclient
  (add-hook 'after-init-hook
    (lambda ()
      (use-package server :ensure nil)
      (unless (server-running-p)
        (server-start))))

  (when (fboundp 'pixel-scroll-precision-mode)
    (pixel-scroll-precision-mode))

#+end_src

** Mac Specific
:properties:
:custom_id: mac-specific
:visibility: folded
:end:

This function is called after Elpaca has initialized and, if this machine is a Macintosh, will setup the mack keyboard keys.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/set-mac-modifier-keys ()
    (interactive)
    ;; Macintosh specific configurations.
    (when *is-a-mac*
      (setq mac-command-modifier   'meta
        mac-option-modifier        'super
        mac-control-modifier       'control
        mac-right-command-modifier 'meta
        mac-right-control-modifier 'hyper)))

  (add-hook 'after-init-hook #'mifi/set-mac-modifier-keys)

#+end_src

** MiFi's Minor Mode
:properties:
:custom_id: mifi-minor-mode
:visibility: folded
:end:

Mitch's minor mode (or MmM) just defines frequently used hot-keys. It works well when =which-key= is active.

*** Helper Functions
:properties:
:custom_id: helper-functions
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defadvice custom-buffer-create (before my-advice-custom-buffer-create)
    "Exit the current Customize buffer before creating a new one, unless there are modified widgets."
    (if (eq major-mode 'Custom-mode)
        (let ((custom-buffer-done-kill t)
              (custom-buffer-modified nil))
          (mapc (lambda (widget)
                  (and (not custom-buffer-modified)
                       (eq (widget-get widget :custom-state) 'modified)
                       (setq custom-buffer-modified t)))
                custom-options)
          (if (not custom-buffer-modified)
              (Custom-buffer-done)))))

  (defun mifi/set-fill-column-interactively (num)
    "Asks for the fill column."
    (interactive "nfill-column: ")
    (set-fill-column num))

  (defun mifi/set-org-fill-column-interactively (num)
    "Asks for the fill column for Org mode."
    (interactive "norg-fill-column: ")
    (setq custom-org-fill-column num)
    (mifi/org-mode-visual-fill)
    (redraw-display))

  (defun mifi/jump-to-register ()
    "Asks for a register to jump to."
    (interactive)
    (call-interactively 'jump-to-register))

  (defun mifi/customize-mifi ()
    "Opens up the customize section for all of the MiFi options."
    (interactive)
    (ad-activate 'custom-buffer-create)
    (customize-apropos "mifi-config"))

#+end_src

*** Standard Keymaps
:properties:
:custom_id: standard-keymaps
:visibility: folded
:end:

This is a set of keymaps that do the same things as the popup menu. Both are here for convenience. *Note* that the ~mmm-menu~ is called with either a ="C-c RET RET"= or simply a ="C-c C-<return>"=.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/define-mmm-minor-mode-map ()
    (defvar mmm-keys-minor-mode-map
      (let ((map (make-sparse-keymap)))
        (bind-keys :map map
          ("M-RET $" . jinx-correct)
          ("M-RET ?" . eldoc-box-help-at-point)
          ("M-RET /" . hydra-combine/body)
          ("M-RET M s" . markdown-preview-mode)
          ("M-RET M e" . markdown-preview-cleanup)
          ("M-RET S e" . eshell)
          ("M-RET S i" . ielm)
          ("M-RET S v" . vterm-other-window)
          ("M-RET v" . hydra-themes-and-fonts/body)
          ("M-RET W" . writeroom-mode)
          ("M-RET w <right>" . which-key-setup-side-window-right-bottom)
          ("M-RET w <down>" . which-key-setup-side-window-bottom)
          ("M-RET =" . next-theme)
          ("M-RET -" . previous-theme)
          ("M-RET _" . which-theme)
          ("M-RET M-c" . mifi/customize-mifi)
          ("M-RET d" . dashboard-open)
          ("M-RET e" . treemacs) ;; e for Explore
          ("M-RET f" . mifi/set-fill-column-interactively)
          ("M-RET p" . pulsar-pulse-line)
          ("M-RET r" . repeat-mode)
          ("M-RET j" . hydra-registers/body) ;; mifi/jump-to-register)
          ("M-RET |" . global-display-fill-column-indicator-mode)
          ("M-RET C-g" . keyboard-quit))
        map)
      "mmm-keys-minor-mode keymap.")

    (define-minor-mode mmm-keys-minor-mode
      "A minor mode so that my key settings override annoying major modes."
      :init-value t
      :lighter " MmM"))

  (mifi/define-mmm-minor-mode-map)

#+end_src

*** Context-Aware Keys and Descriptions
:properties:
:custom_id: context-aware-keys-and-descriptions
:visibility: folded
:end:

For those menus that would normally show up as either =prefix= or =lambda=, given them a better description via the which-key replacement function. This is run via the ~which-key-inhibit-display-hook~ hook which is run just before the which-key popup is shown. Plus, some keys are mode specific and will only appear when that major mode is active.

#+begin_src emacs-lisp :results output silent
  ;;; ##########################################################################

  (defun mifi/mmm-handle-context-keys (&optional winframe)
    "Enable or Disable keys based upon featurep context."
    (when winframe
      (let ((map mmm-keys-minor-mode-map))
        (when enable-thesaurus
          (bind-keys :map map
            ("M-RET t t" . mw-thesaurus-lookup-dwim)))
        (cond
          ((equal major-mode 'org-mode)
            (bind-keys :map map
              ("M-RET M-RET" . org-insert-heading)
              ("M-RET o f" . mifi/set-org-fill-column-interactively)
              ("M-RET o c" . mifi/toggle-org-centering)
              ("M-RET o r" . org-mode-restart)
              ("M-RET o l" . org-toggle-link-display)))
          ((equal major-mode 'python-mode)
            (bind-keys :map map
              ("M-RET P" . 'pydoc-at-point)))
    ((equal major-mode 'tuareg-mode)
      (bind-keys :map map
        ("M-RET c m" . tuarg-browse-manual)))
          (t   ;; Default 
            (unbind-key "M-RET o f" map)
            (unbind-key "M-RET o c" map)
            (unbind-key "M-RET o l" map)
            (unbind-key "M-RET P ?" map)
            (unbind-key "M-RET c m" map)
            (unbind-key "M-RET M-RET" map)))))

    ;; Override default menu text with better things
    (which-key-add-key-based-replacements
      "M-RET t t" "thesaurus-at-point"
      "M-RET o" "org-menu"
      "M-RET c" "ocaml-menu"
      "M-RET o c" "toggle-org-centering"
      "M-RET o f" "set-org-fill-column"))

#+end_src

*** Key Description Overrides
:properties:
:custom_id: key-description-overrides
:visibility: folded
:end:

Sometimes, the descriptions that which-key provide are not what we want. So, for cases like this, these description replacemens are used.

What's also important with this function is that it calls the ~mifi/mmm-handle-context-keys~ function which updates the context aware keys.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/mmm-update-menu (&optional winframe)
    (interactive)
    (mifi/mmm-handle-context-keys nil)
    (which-key-add-key-based-replacements
      "M-RET w" "which-key-position"
      "M-RET w <right>" "which-key-on-right"
      "M-RET w <down>" "which-key-on-bottom"
      "M-RET M" "markdown-preview"
      "M-RET S" "shells"
      "M-RET P" "python-menu"
      "M-RET e" "treemacs-toggle"
      "M-RET t" "Thesaurus"
      "M-RET f" "set-fill-column"
      "M-RET j" "jump-to-register"
      "M-RET v" "font-size"
      "M-RET C-g" "Exit menu"
      "M-RET" "Mitch's Menu"))

#+end_src

*** Hooks
:properties:
:custom_id: hooks
:visibility: folded
:end:

These are the hools that update the context-aware menu triggered by various state changes of Emacs buffers and windows.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; Check the keys when:
  ;; - the whick-key menu is displayed
  (add-hook 'after-init-hook
    (lambda ()
      (add-hook 'which-key-inhibit-display-hook 'mifi/mmm-update-menu)
      ;; - the user updates/changes the buffer - like loading a file
      ;;   (but not switching to a new buffer)
      (add-hook 'window-buffer-change-functions 'mifi/mmm-handle-context-keys)
      ;; - the user switches windows
      (add-hook 'window-selection-change-functions 'mifi/mmm-handle-context-keys)
      ;; (add-hook 'which-key-mode-hook #'mifi/after-which-key)
      (mifi/after-which-key)
      (mifi/define-mmm-minor-mode-map)
      (mifi/set-recenter-keys)))

#+end_src

** Initial *scratch* buffer message
:properties:
:custom_id: initial-scratch-buffer-message
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/config-landing ()
    (cond
      ((equal default-landing-mode 'landing-mode-dashboard)
        (dashboard-open))
      ((equal default-landing-mode 'landing-mode-scratch)
        (switch-to-buffer "*scratch*")
        (erase-buffer)
        (beginning-of-buffer)
        (insert (concat 
                ";; 'Tis but a scratch! A scratch? Your arm's off! - No, it isn't!\n"
                (format ";; Happy hacking, %s! %s" user-login-name
                  "Press M-RET (Meta-RET) to open the MiFi Menu\n")))
        (end-of-buffer))
      ((equal default-landing-mode 'landing-mode-ielm)
        (ielm))
      ((equal default-landing-mode 'landing-mode-eshell)
        (eshell))))

#+end_src

** Exiting And Cleanup
:properties:
:custom_id: existing-and-cleanup
:visibility: folded
:end:

+ Also, opam-user-setup Compiled (OCaml)

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/backup-file (file)
    "Backup the file from the configuration directory into the
  backup directory. If a file already exists in the backup directory, the old
  file is renamed with a ~ at the end before the new file is copied. If Emacs
  is running in server mode, then don't backup the files when the emacsclient
  exits."
    (unless (server-running-p)
      (let ((backdir (format "%s/config-backup" working-files-directory)))
        (make-directory backdir t)
        ;; --------------------------------------------------
        (when (file-exists-p (format "%s/%s" backdir file))
        (copy-file
          (expand-file-name file backdir)
          (expand-file-name (format "%s~" file) backdir) t))
        (when (file-exists-p (format "%s/%s" emacs-config-directory file))
        (copy-file
          (expand-file-name file emacs-config-directory)
          (expand-file-name file backdir) t)))))

  (defun mifi/when-exiting-emacs ()
    "Backup Emacs initialization files for recovery. If old files exist, they are
  backed up as tilde (~) files. Also, if ocaml is enabled, byte (re)compile the
  opam-user-setup.el so that upon next startup, it can be loaded quickly."
    (when (featurep 'simple-httpd)
      (httpd-stop))
    (when enable-ocaml
      (let ((src (expand-file-name "opam-user-setup.el" emacs-config-directory)))
        (when (file-exists-p src)
          (byte-compile-file src))))
    (mifi/backup-file "early-init.el")
    (mifi/backup-file "init.el")
    (mifi/backup-file "emacs-config-elpaca.org")
    (mifi/backup-file "emacs-config-elpa.org"))

  (add-hook 'kill-emacs-hook #'mifi/when-exiting-emacs)

#+end_src
** Global key-binding
:properties:
:custom_id: global-key-binding
:visibility: folded
:end:

These are key-bindings that are done at a global level.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/setup-global-keybindings ()
    (interactive)
    (bind-key "C-c ]" 'indent-region prog-mode-map)
    (bind-key "C-c }" 'indent-region prog-mode-map) 
    (bind-key "C-x C-j" 'dired-jump)

    ;;
    ;; A little better than just the typical "C-x o"
    ;; windmove is a built-in Emacs package.
    ;;
    (global-set-key (kbd "C-c <left>")  'windmove-left)
    (global-set-key (kbd "C-c <right>") 'windmove-right)
    (global-set-key (kbd "C-c <up>")    'windmove-up)
    (global-set-key (kbd "C-c <down>")  'windmove-down)

    ;;
    ;; Ctl-mouse to adjust/scale fonts will be disabled.
    ;; I personally like this since it was all to easy to accidentally
    ;; change the size of the font.
    ;;
    (global-unset-key (kbd "C-<mouse-4>"))
    (global-unset-key (kbd "C-<mouse-5>"))
    (global-unset-key (kbd "C-<wheel-down>"))
    (global-unset-key (kbd "C-<wheel-up>")))

  (use-package evil-nerd-commenter
    :ensure t
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))

  (add-hook 'emacs-startup-hook #'mifi/setup-global-keybindings)

#+end_src

* Universal Packages
:properties:
:custom_id: universal-packages
:visibility: folded
:end:

These are the common packages that I pretty much use universally in my normal Emacs workflow. It excludes packages that can be customized through my =mifi-config= variables as they are generally in their own section.

It's also important to note that some of these packages are required to be loaded prior to packages later on in this configuration.

+ System Packages
  
This is a collection of functions to make handling installed system packages more convenient through Emacs.

#+begin_src emacs-lisp 

  (use-package system-packages :ensure t)
  
#+end_src

** Anzu
:properties:
:custom_id: anzu
:visibility: folded
:end:

anzu.el is an Emacs port of anzu.vim. anzu.el provides a minor mode which displays current match and total matches information in the mode-line in various search modes.

#+begin_src emacs-lisp :tangle no
  ;;; ##########################################################################

  (use-package anzu
    :ensure t
    :custom
    (anzu-mode-lighter "")
    (anzu-deactivate-region t)
    (anzu-search-threshold 1000)
    (anzu-replace-threshold 50)
    (anzu-replace-to-string-separator " => ")
    :config
    (global-anzu-mode +1)
    (set-face-attribute 'anzu-mode-line nil
      :foreground "yellow" :weight 'bold)
    (define-key isearch-mode-map
      [remap isearch-query-replace]  #'anzu-isearch-query-replace)
    (define-key isearch-mode-map
      [remap isearch-query-replace-regexp] #'anzu-isearch-query-replace-regexp))

#+end_src

** Async
:properties:
:custom_id: async
:visibility: folded
:end:

~async.el~ is a module for doing asynchronous processing in Emacs. Some async applications are provided as well with this package:

+ Dired-async
+ smtp-mail-async
+ async-bytecomp
+ async-package
  
#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package async
    :ensure t)

#+end_src

** Auto-complete
:properties:
:custom_id: auto-complete
:visibility: folded
:end:

#+begin_src emacs-lisp :tangle no
  ;;; ##########################################################################

  (use-package auto-complete
    :config
    (defvar ac-directory
      (unless (file-exists-p "auto-complete")
        (make-directory "auto-complete")))
    (add-to-list 'load-path ac-directory)
    (global-auto-complete-mode 1)
    (ac-set-trigger-key "TAB")
    (ac-set-trigger-key "<tab>")
    ;; from http://blog.deadpansincerity.com/2011/05/setting-up-emacs-as-a-javascript-editing-environment-for-fun-and-profit/
    ;; Start auto-completion after 2 characters of a word
    (setq ac-auto-start 2)
    ;; case sensitivity is important when finding matches
    (setq ac-ignore-case nil)
    (setq-default ac-sources '(ac-source-pycomplete
                               ac-source-yasnippet
                               ac-source-abbrev
                               ac-source-dictionary
                               ac-source-words-in-same-mode-buffers)))

#+end_src

** Dumb Jump
:properties:
:custom_id: dumb-jump
:visibility: folded
:end:

Dumb Jump is an Emacs "jump to definition" package with support for 50+ programming languages that favors "just working". This means minimal -- and ideally zero -- configuration with absolutely no stored indexes (TAGS) or persistent background processes.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package xref :ensure nil)
  (use-package dumb-jump
    :after xref
    :config
    (setq xref-show-definitions-function #'xref-show-definitions-completing-read)
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

#+end_src

** Eldoc
:properties:
:custom_id: eldoc
:visibility: folded
:end:

This package displays ElDoc documentations in a childframe. The childframe is selectable and scrollable with mouse, even though the cursor is hidden. 

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/setup-hooks-for-eldoc ()
    (interactive)
    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
    (add-hook 'ielm-mode-hook 'eldoc-mode)
    ;; Eldoc will try to load/unload a theme which can cause issues with our
    ;; theme loading mechanism. Our theme could fail to load because of this.
    ;; So, to get our themes loading properly, load it here if not already
    ;; loaded.
    (unless theme-did-load
      (mifi/load-theme-from-selector)))

  (use-package eldoc)

  (use-package eldoc-box
    :delight DocBox
    :ensure t
    :hook (after-init . mifi/setup-hooks-for-eldoc))

#+end_src

** Helpful Help Commands
:properties:
:custom_id: helpful-help-commands
:visibility: folded
:end:

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers. For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration. It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package helpful
    :ensure t
    ;; :commands (helpful-callable helpful-variable helpful-command helpful-key helpful-function)
    :config
    (bind-keys
      ([remap describe-command] . helpful-command)
      ([remap describe-function] . helpful-function)
      ([remap describe-variable] . helpful-variable)
      ([remap describe-key] . helpful-key)))

#+end_src

** Hydra
:properties:
:custom_id: hydra
:visibility: folded
:end:

This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra. Once you summon the Hydra through the prefixed binding (the body + any one head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head, arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his original purpose, calling his proper command. This makes the Hydra very seamless, it's like a minor mode that disables itself auto-magically.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package hydra
    :defer t
    :commands defhydra
    :bind (("C-c c" . hydra-clock/body)
           ("C-c m" . hydra-magit/body)
           ("C-c r" . hydra-registers/body)
           ("C-c t" . hydra-themes-and-fonts/body))
    :ensure t)
#+end_src

*** Hydra major mode
:properties:
:custom_id: major-mode-hydra
:visibility: folded
:end:

#+begin_src emacs-lisp
  (use-package major-mode-hydra
    :ensure t
    :after hydra
    :preface
    (defun with-alltheicon (icon str &optional height v-adjust face)
      "Display an icon from all-the-icon."
      (s-concat (all-the-icons-alltheicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

    (defun with-faicon (icon str &optional height v-adjust face)
      "Display an icon from Font Awesome icon."
      (s-concat (all-the-icons-faicon icon ':v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

    (defun with-fileicon (icon str &optional height v-adjust face)
      "Display an icon from the Atom File Icons package."
      (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))

    (defun with-octicon (icon str &optional height v-adjust face)
      "Display an icon from the GitHub Octicons."
      (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))
    :config
    (mifi/hydra-clock)
    (mifi/hydra-combine)
    (mifi/hydra-themes-and-fonts)
    (mifi/hydra-magit)
    (mifi/hydra-registers))

#+end_src

*** Hydra / Clock
:properties:
:custom_id: hydra-clock
:visibility: folded
:end:

Group clock commands

#+begin_src emacs-lisp

  (defun mifi/hydra-clock ()
    (pretty-hydra-define hydra-clock
      (:hint nil :color teal :quit-key "q" :title (with-faicon "clock-o" "Clock" 1 -0.05))
      ("Action"
        ( ("c" org-clock-cancel "cancel")
          ("d" org-clock-display "display")
          ("e" org-clock-modify-effort-estimate "effort")
          ("i" org-clock-in "in")
          ("j" org-clock-goto "jump")
          ("o" org-clock-out "out")
          ("p" org-pomodoro "pomodoro")
          ("r" org-clock-report "report")))))

#+end_src

*** Hydra / Magit
:properties:
:custom_id: hydra-magit
:visibility: folded
:end:

Group Magit commands.

#+begin_src emacs-lisp

  (defun mifi/hydra-magit ()
    (pretty-hydra-define hydra-magit
      (:hint nil :color teal :quit-key "q" :title (with-octicon "mark-github" "Magit" 1 -0.05))
      ("Action"
        ( ("b" magit-blame "blame")
          ("c" magit-clone "clone")
          ("i" magit-init "init")
          ("l" magit-log-buffer-file "commit log (current file)")
          ("L" magit-log-current "commit log (project)")
          ("s" magit-status "status"))))  )

#+end_src

*** Hydra / Registers
:properties:
:custom_id: hydra-registers
:visibility: folded
:end:

Group Common Register commands.

#+begin_src emacs-lisp

  (defun mifi/hydra-registers ()
    (pretty-hydra-define hydra-registers
      (:hint nil :color teal :quit-key "q" :title (with-faicon "thumb-tack" "Registers" 1 -0.05))
      ("Action"
        ( ("o" (jump-to-register reg-elpa) "open emacs-config-elpa.org")
          ("O" (jump-to-register reg-elpaca) "open emacs-config-elpaca.org")
          ("S" (jump-to-register ?S) "Scripts")
          ("G" (jump-to-register ?G) "GameBoy Asm Root")))
      ))

#+end_src

*** Hydra / Themes and Fonts
:properties:
:custom_id: hydra-themes-and-fonts
:visibility: folded
:end:

Group Theme commands.

#+begin_src emacs-lisp

  (defun mifi/hydra-themes-and-fonts ()
    (pretty-hydra-define hydra-themes-and-fonts
      (:hint nil :color teal :quit-key "q" :title (with-faicon "puzzle-piece" "Themes and Fonts" 1 -0.05))
      ("Action"
        ( ("+" next-theme "Next theme")
          ("-" previous-theme "Previous Theme")
          ("=" which-theme "Display Current Theme")
          ("S" use-small-display-font "Small Font without resize")
          ("M" use-medium-display-font "Medium Font without resize")
          ("L" use-large-display-font "Large Font without resize")
          ("X" use-x-large-display-font "X-Large Font without resize")
          ("s" (use-small-display-font t) "Small Font with resize")
          ("m" (use-medium-display-font t) "Medium Font with resize")
          ("l" (use-large-display-font t) "Large Font with resize")
          ("x" (use-x-large-display-font t) "X-Large Font with resize")) )))

#+end_src

*** Hydra / Combine
:properties:
:custom_id: hydra-combine
:visibility: folded
:end:

Combination of groups

#+begin_src emacs-lisp

  (defun mifi/hydra-combine ()
    (pretty-hydra-define hydra-combine
      (:hint nil :color teal :quit-key "q" :title (with-faicon "thumb-tack" "Combine" 1 -0.05))
      ("Action"
        ( ("m" hydra-magit/body "Magit menu")
          ("t" hydra-themes-and-fonts/body "Themes and Fonts menu") ))
      ))
#+end_src

#+begin_src emacs-lisp
    ;;; ^^^ ;;;
#+end_src
** Jinx
:properties:
:custom_id: jinx
:visibility: folded
:end:

Jinx is a fast just-in-time spell-checker for Emacs. Jinx highlights misspelled words in the text of the visible portion of the buffer. For efficiency, Jinx highlights misspellings lazily, recognizes window boundaries and text folding, if any. For example, when unfolding or scrolling, only the newly visible part of the text is checked if it has not been checked before. Each misspelling can be corrected from a list of dictionary words presented as a completion menu.

*Important* Jinx requires the library ~libenchant~ or ~enchant~ installed. This can be done via the [[https://github.com/AbiWord/enchant][enchant github]] site, through ~brew~ on macOS or the package management system of the OS.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package jinx
    :ensure t
    :bind ( ("C-c C-$" . jinx-correct)
            ("C-x C-$" . jinx-languages))
    :hook (emacs-startup . global-jinx-mode)
    :config
    (dolist (hook '(text-mode-hook prog-mode-hook org-mode-hook))
            (add-hook hook #'jinx-mode)))


#+end_src

** JSON-RPC
:properties:
:custom_id: json-rpc
:visibility: folded
:end:

The JSON-RPC protocol is used to communicate with many different types of server. This is required for the DAP Debug Adapter as well as Eglot.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package jsonrpc
    :defer t
    :ensure t)
    ;; :config
    ;; For some odd reason, it is possible that jsonrpc will try to load a
    ;; theme. (jsonrpc/lisp/custom.el:1362). If our theme hasn't been loaded
    ;; yet, go ahead and try. This could prevent a startup without the theme
    ;; properly loaded.
    ;; (unless theme-did-load
    ;;   (mifi/load-theme-from-selector)))

#+end_src

** Simple-httpd
:properties:
:custom_id: simple-httpd
:visibility: folded
:end:

A simple Emacs web server.

This used to be httpd.el but there are already several of these out there already of varying usefulness. Since the name change, it's been stripped down to simply serve files and directory listings. Client requests are sanitized so this should be safe, but I make no guarantees.

#+begin_src emacs-lisp

  ;; All kept in local /lisp directory.
  ;; (use-package web-server-status-codes )
  ;; (use-package simple-httpd )
  ;; (use-package web-server )

#+end_src
** Thesaurus
:properties:
:custom_id: thesaurus
:visibility: folded
:end:

The ubiquitous Merriam-Websters Thesaurus

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package mw-thesaurus
    :when enable-thesaurus
    :custom
    (mw-thesaurus-api-key "429331e9-b40e-4f17-9988-0632ef3ddd2d")
    :defer t
    :commands mw-thesaurus-lookup-dwim
    :hook (mw-thesaurus-mode . variable-pitch-mode)
    :config
    ;; window on the right side
    (add-to-list 'display-buffer-alist '(,mw-thesaurus-buffer-name
                                          (display-buffer-reuse-window
                                            display-buffer-in-direction)
                                          (direction . right)
                                          (window . root)
                                          (window-width . 0.3))))

#+end_src

** Which Key
:properties:
:custom_id: which-key
:visibility: folded
:end:

[[Https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix. For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run. This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/after-which-key ()
    (interactive)
    (which-key-mode 1)
    (add-to-list 'savehist-additional-variables 'which-key-side-window-location)
    (which-key-add-key-based-replacements
      "M-RET |" "display-fill-column"
      "M-RET ?" "help-at-point")
    (mmm-keys-minor-mode 1)
    (when (featurep 'prog-mode)
      (which-key-add-key-based-replacements
        "C-c g r" "find-symbol-reference"
        "C-c g o" "find-defitions-other-window"
        "C-c g g" "find-defitions"
        "C-c g ?" "eldoc-definition"))
    (mifi/set-recenter-keys))

  (use-package which-key
    ;; :ensure (:wait t)
    :ensure t
    :demand t
    :commands which-key-mode
    :delight which-key-mode
    :custom
    (which-key-popup-type 'side-window)
    (which-key-preserve-window-configuration t)
    (which-key-idle-delay 1,0)
    (which-key-prefix-prefix "✪ ")
    ;; (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-min-display-lines 3)
    :config
    (add-hook 'after-init-hook #'mifi/after-which-key))

#+end_src

** YASnippet
:properties:
:custom_id: yasnippet
:visibility: folded
:end:

These are useful snippets of code that are commonly used in various languages. You can even create your own.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; YASnippets

  (use-package yasnippet
    :ensure t
    :defer t
    :bind (:map yas-minor-mode-map
            ("<C-'>" . yas-expand))
    :config
    (setq yas-global-mode t)
    (setq yas-minor-mode t)
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (add-to-list #'yas-snippet-dirs (expand-file-name "Snippets" custom-docs-directory))
    (yas-reload-all)
    (add-hook 'prog-mode-hook 'yas-minor-mode)
    (add-hook 'text-mode-hook 'yas-minor-mode)
    (setq yas-prompt-functions '(yas-ido-prompt))
    (defun help/yas-after-exit-snippet-hook-fn ()
      (prettify-symbols-mode))
    (add-hook 'yas-after-exit-snippet-hook #'help/yas-after-exit-snippet-hook-fn))

#+end_src

**** Yasnippet Snippets
:properties:
:custom_id: yasnippet-snippets
:visibility: folded
:end:

Collections of more yasnippet snippets for various languages.

#+begin_src emacs-lisp

  (use-package yasnippet-snippets
    :ensure t
    :after yasnippet)

#+end_src

* Operational Systems
:properties:
:custom_id: operational-systems
:visibility: folded
:end:

These are major systems that control major operational features of Emacs like Search, File handling, Undo/Redo.

** Undo Handlers
:properties:
:custom_id: undo-handlers
:visibility: folded
:end:

*** Vundo (visual undo)
:properties:
:custom_id: vundo-visual-undo
:visibility: folded
:end:

Vundo displays the undo history as a tree and lets you move in the tree to go back to previous buffer states. To use vundo, type M-x vundo RET in the buffer you want to undo. An undo tree buffer should pop up.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package vundo
    ;;:ensure ( :host github :repo "casouri/vundo")
    :when (equal undo-handler 'undo-handler-vundo)
    :ensure t
    :commands vundo
    :bind
    ("C-x u" . vundo)
    ("C-x r u" . vundo)
    :config
    (set-face-attribute 'vundo-default nil :family "Symbola")
    (setq vundo-glyph-alist vundo-unicode-symbols))

#+end_src

*** Undo Tree
:properties:
:custom_id: undo-tree
:visibility: folded
:end:

Instead of treating undo/redo as a linear sequence of changes, undo-tree-mode treats undo history as a branching tree of changes, similar to the way Vim handles it. This makes it substantially easier to undo and redo any change, while preserving the entire history of past states. The undo-tree visualizer is particularly helpful in complex cases. An added side bonus is that undo history can in some cases be stored more efficiently, allowing more changes to accumulate before Emacs starts discarding history. Undo history can be saved persistently across sessions with Emacs 24.3 and later. It also sports various other nifty features: storing and restoring past buffer states in registers, a diff view of the changes that will be made by undoing, and probably more besides.

#+begin_src emacs-lisp
  ;;; vvv ;;;

  (defun mifi/undo-tree-hook ()
    (set-frame-width (selected-frame) 20))

  (defun undo-tree-split-side-by-side (original-function &rest args)
    "Split undo-tree side-by-side"
    (let ((split-height-threshold nil)
           (split-width-threshold 0))
      (apply original-function args)))

  ;;
  ;; Sometimes, when behind a firewall, the undo-tree package triggers elpaca
  ;; to queue up the Queue package which then hangs and fails. This happens
  ;; even if the :unless/:when option is specified in the use-package (only :disabled
  ;; seems to work which isn't what I want). So, we prevent the loading of the
  ;; page altogether unless the undo-handler is set to undo tree.
  ;;
  (when (equal undo-handler 'undo-handler-undo-tree)
    (use-package undo-tree
      :ensure t
      :init
      (setq undo-tree-visualizer-timestamps nil
        undo-tree-visualizer-diff t
        undo-tree-enable-undo-in-region t
        ;; 10X bump of the undo limits to avoid issues with premature
        ;; Emacs GC which truncages the undo history very aggresively
        undo-limit 800000
        undo-strong-limit 12000000
        undo-outer-limit 120000000)
      :delight untree
      :config
      (global-undo-tree-mode)
      (advice-add 'undo-tree-visualize :around #'undo-tree-split-side-by-side)
      (bind-keys :map undo-tree-visualizer-mode-map
        ("RET" . undo-tree-visualizer-quit)
        ("C-g" . undo-tree-visualizer-abort))
      (setq undo-tree-auto-save-history nil)))

  ;;; ^^^ ;;;
#+end_src

** Completion Handlers
:properties:
:custom_id: completion-handler
:visibility: folded
:end:

Here are a series of completion systems that are available for Emacs.

*** Prescient
:properties:
:custom_id: prescient
:visibility: folded
:end:

prescient.el is a library which sorts and filters lists of candidates, such as appear when you use a package like Ivy or Company. Extension packages such as ivy-prescient.el and company-prescient.el adapt the library for usage with various frameworks.

prescient.el also provides a completion style (prescient) for filtering candidates via Emacs's generic completion, such as in Icomplete, Vertico, and Corfu. These last two have extension packages to correctly set up filtering and sorting.

As compared to other packages which accomplish similar tasks, including IDO, Ivy, Helm, Smex, Flx, Historian, and Company-Statistics, prescient.el aims to be simpler, more predictable, and faster.

TL;DR prescient.el: simple but effective sorting and filtering package for Emacs.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package prescient
    :after (:any ivy vertico corfu)
    :defer t)

  (use-package company-prescient
    :after prescient)

#+end_src

*** Orderless
:properties:
:custom_id: orderless
:visibility: folded
:end:

This package provides an orderless completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order. Each component can match in any one of several ways: literally, as a regexp, as an initialism, in the flex style, or as multiple word prefixes. By default, regexp and literal matches are enabled.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package orderless
    :when (or (or (equal completion-handler 'comphand-vertico)
                  (equal completion-handler 'comphand-ivy))
              (equal completion-handler 'comphand-corfu))
    :after (:any ivy swiper vertico counsel corfu)
    :ensure t
    :custom
    (when (equal completion-handler 'comphand-ivy)
      (setq ivy-re-builders-alist '((t . orderless-ivy-re-builder)))
      (add-to-list 'ivy-highlight-functions-alist '(orderless-ivy-re-builder . orderless-ivy-highlight)))
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))

#+end_src

*** IVY Mode
:properties:
:custom_id: ivy-mode
:visibility: folded
:end:

<<<Ivy>>> is an excellent completion framework for Emacs. It provides a minimal yet powerful selection menu that appears when you open files, switch buffers, and for many other tasks in Emacs. Counsel is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide useful commands for each of the default completion commands.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Swiper and IVY mode

  (use-package ivy
    :when (equal completion-handler 'comphand-ivy)
    :bind (("C-s" . swiper)
            :map ivy-minibuffer-map
              ;;; ("TAB" . ivy-alt-done)
            ("C-l" . ivy-alt-done)
            ("C-j" . ivy-next-line)
            ("C-k" . ivy-previous-line)
            :map ivy-switch-buffer-map
            ("C-k" . ivy-previous-line)
            ("C-l" . ivy-done)
            ("C-d" . ivy-switch-buffer-kill)
            :map ivy-reverse-i-search-map
            ("C-k" . ivy-previous-line)
            ("C-d" . ivy-reverse-i-search-kill))
    :custom
    (enable-recursive-minibuffers t)
    (ivy-use-virtual-buffers t)
    :config
    (ivy-mode 1)
    (setq ivy-re-builders-alist '((t . orderless-ivy-re-builder)))
    (add-to-list 'ivy-highlight-functions-alist
      '(orderless-ivy-re-builder . orderless-ivy-highlight)))

#+end_src

**** Ivy-rich and ivy-yasnippet
:properties:
:custom_id: ivy-rich-and-ivy-yasnippet
:visibility: folded
:end:

Ivy-rich provides rich transformers for commands from ivy and counsel.
Ivy-yasnippet lets you preview yasnippet snippets with ivy.

#+begin_src emacs-lisp
  ;;; vvv ;;;

  (use-package ivy-rich
    :when (equal completion-handler 'comphand-ivy)
    :after ivy
    :init
    (ivy-rich-mode 1)
    :config
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line))

  (use-package ivy-yasnippet
    :when (equal completion-handler 'comphand-ivy)
    :after (:any yasnippet ivy))

#+end_src

**** Swiper
:properties:
:custom_id: swiper
:visibility: folded
:end:

Swiper is an alternative to isearch that uses Ivy to show an overview of all matches.

#+begin_src emacs-lisp

  (use-package swiper
    :when (equal completion-handler 'comphand-ivy)
    :after ivy)

#+end_src

**** Counsel
:properties:
:custom_id: counsel
:visibility: folded
:end:

~ivy-mode~ ensures that any Emacs command using completing-read-function uses ivy for completion. Counsel takes this further, providing versions of common Emacs commands that are customised to make the best use of Ivy. For example, ~counsel-find-file~ has some additional keybindings. Pressing =DEL= will move you to the parent directory.

#+begin_src emacs-lisp :results output silent

  (use-package counsel
    :when (equal completion-handler 'comphand-ivy)
    :ensure t
    :after ivy
    :defer t
    :bind ( ("C-M-j" . 'counsel-switch-buffer)
            ("M-x" . 'counsel-M-x)
            ("M-g o" . 'counsel-outline)
            ("C-x C-f" . 'counsel-find-file)
            ("C-c C-r" . 'ivy-resume)
            :map minibuffer-local-map
            ("C-r" . 'counsel-minibuffer-history))
    :custom
    (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
    :config
    (bind-keys
      ([remap describe-function] . counsel-describe-function)
      ([remap describe-variable] . counsel-describe-variable))
    (when (featurep 'helpful)
      (setq counsel-describe-function-function #'helpful-callable)
      (setq counsel-describe-variable-function #'helpful-variable))
    (counsel-mode 1))

#+end_src

**** Ivy Prescient
:properties:
:custom_id: ivy-prescient
:visibility: folded
:end:

~prescient.el~ is a library which sorts and filters lists of candidates, such as appear when you use a package like =Ivy= or =Company=.

#+begin_src emacs-lisp

  (use-package ivy-prescient
    :when (equal completion-handler 'comphand-ivy)
    :after (ivy prescient)
    :ensure t
    :custom
    (prescient-persist-mode t)
    (ivy-prescient-mode t)
    (ivy-prescient-enable-filtering t))

  ;;; ^^^ ;;;
#+end_src

*** Company Mode
:properties:
:custom_id: company-mode
:visibility: folded
:end:

[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than =completion-at-point= which is more reminiscent of what you would expect from an IDE. We add a simple configuration to make the keybindings a little more useful (=TAB= now completes the selection and initiates completion at the current location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with icons and better overall presentation.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; Don't use lsp-bridge with company as lsp-bridge already provides the same
  ;; features. They actually collide.

  (use-package company
    :unless (equal custom-ide 'custom-ide-lsp-bridge)
    :ensure t
    :delight
    (company-mode " 🏢")
    :custom
    (company-minimum-prefix-length 2)
    (company-idle-delay 0.5)
    :commands (global-company-mode company-mode)
    :bind (:map company-active-map
            ("C-n". company-select-next)
            ("C-p". company-select-previous)
            ("M-<". company-select-first)
            ("M->". company-select-last)
            ("<tab>" . company-complete-selection))
    :hook (after-init . (lambda () (global-company-mode 1)))
    :config
    (when (featurep 'prescient)
      (company-prescient-mode 1)))

  ;; IMPORTANT:
  ;; Don't use company at all if lsp-bridge is active.
  ;; lsp-bridge already provides similar functionality.

  ;; :config
  ;; (add-to-list 'company-backends 'company-yasnippet))

#+end_src

**** Company Packages
:properties:
:custom_id: company-packages
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; vvv ;;;
  ;; (require 'company-box)
  ;; (add-hook 'company-mode-hook 'company-box-mode)

  (use-package company-box
    :ensure t
    :after company
    :delight
    (company-box-mode " 📦")
    ;; :vc (:url "https://github.com/sebastiencs/company-box.git")
    :hook (company-mode . company-box-mode))

#+end_src

#+begin_src emacs-lisp

  (use-package company-jedi
    :when  (equal custom-ide 'custom-ide-elpy)
    :after (:all python company)
    :config
    (jedi:setup)
    (defun my/company-jedi-python-mode-hook ()
      (add-to-list 'company-backends 'company-jedi))
    (add-hook 'python-mode-hook 'my/company-jedi-python-mode-hook))

  #+end_src
  
*** Corfu
:properties:
:custom_id: corfu
:visibility: folded
:end:

<<<Corfu>>> enhances in-buffer completion with a small completion popup. The current candidates are shown in a popup below or above the point. The candidates can be selected by moving up and down. Corfu is the minimalistic in-buffer completion counterpart of the Vertico minibuffer UI.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;;;; Code Completion
  (use-package corfu
    :ensure t
    :when (equal completion-handler 'comphand-corfu)
    ;; Optional customizations
    :custom
    (corfu-cycle t)                  ; Allows cycling through candidates
    (corfu-auto t)                   ; Enable auto completion
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.8)
    (corfu-popupinfo-delay '(0.5 . 0.2))
    (corfu-preview-current 'insert) ; insert previewed candidate
    (corfu-preselect 'prompt)
    (corfu-on-exact-match nil)       ; Don't auto expand tempel snippets
    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
            ("M-SPC"      . corfu-insert-separator)
            ("TAB"        . corfu-next)
            ([tab]        . corfu-next)
            ("S-TAB"      . corfu-previous)
            ([backtab]    . corfu-previous)
            ("S-<return>" . corfu-insert)
            ("RET"        . nil))
    :hook (prog-mode . corfu-mode)
    :config
    (corfu-prescient-mode t)
    (corfu-history-mode t)
    (corfu-popupinfo-mode) ; Popup completion info
    (add-hook 'eshell-mode-hook
      (lambda () (setq-local corfu-quit-at-boundary t
                   corfu-quit-no-match t
                   corfu-auto nil)
        (corfu-mode))))

#+end_src

**** Cape Configuration
:properties:
:custom_id: cape-configuration
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; Add extensions
  (use-package cape
    :when (equal completion-handler 'comphand-corfu)
    :after corfu
    :ensure t
    ;; Bind dedicated completion commands
    ;; Alternative prefix keys: C-c p, M-p, M-+, ...
    :bind ( ("C-c C-p p" . completion-at-point) ;; capf
            ("C-c C-p t" . complete-tag)        ;; etags
            ("C-c C-p d" . cape-dabbrev)        ;; or dabbrev-completion
            ("C-c C-p h" . cape-history)
            ("C-c C-p f" . cape-file)
            ("C-c C-p k" . cape-keyword)
            ("C-c C-p s" . cape-elisp-symbol)
            ("C-c C-p e" . cape-elisp-block)
            ("C-c C-p a" . cape-abbrev)
            ("C-c C-p l" . cape-line)
            ("C-c C-p w" . cape-dict)
            ("C-c C-p :" . cape-emoji)
            ("C-c C-p \\" . cape-tex)
            ("C-c C-p _" . cape-tex)
            ("C-c C-p ^" . cape-tex)
            ("C-c C-p &" . cape-sgml)
            ("C-c C-p r" . cape-rfc1345))
    :config
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block)
    ;;(add-hook 'completion-at-point-functions #'cape-history)
    ;;(add-hook 'completion-at-point-functions #'cape-keyword)
    ;;(add-hook 'completion-at-point-functions #'cape-tex)
    ;;(add-hook 'completion-at-point-functions #'cape-sgml)
    ;;(add-hook 'completion-at-point-functions #'cape-rfc1345)
    ;;(add-hook 'completion-at-point-functions #'cape-abbrev)
    ;;(add-hook 'completion-at-point-functions #'cape-dict)
    ;;(add-hook 'completion-at-point-functions #'cape-elisp-symbol)
    (add-hook 'completion-at-point-functions #'cape-line)
    )

#+end_src

**** Corfu-prescient
:properties:
:custom_id: corfu-prescient
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package corfu-prescient
    :when (equal completion-handler 'comphand-corfu)
    :ensure t
    :after corfu prescient)

#+end_src

*** Vertico
:properties:
:custom_id: vertico
:visibility: folded
:end:

<<<Vertico>>> provides a performant and minimalistic vertical completion UI based on the default completion system. The focus of Vertico is to provide a UI which behaves correctly under all circumstances. By reusing the built-in facilities system, Vertico achieves full compatibility with built-in Emacs completion commands and completion tables.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package vertico
    :when (equal completion-handler 'comphand-vertico)
    :ensure t
    :custom
    (recentf-mode t)
    (vertico-count 12)
    (vertico-cycle nil)
    (vertico-multiform-mode 1)
    :config
    (vertico-mode)
    ;; (when (featurep 'prescient)
    ;;   (vertico-prescient-mode 0))
    ;; :bind ("C-x C-f" . ido-find-file)
    ;; Clean up file path when typing
    :hook ((rfn-eshadow-update-overlay . vertico-directory-tidy)
            ;; Make sure vertico state is saved
            (minibuffer-setup . vertico-repeat-save)))

#+end_src

**** Vertico support packages
:properties:
:custom_id: vertico-support-packages
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; vvv ;;;

  (use-package vertico-prescient
    :when (equal completion-handler 'comphand-vertico)
    :ensure t
    :after (vertico prescient)
    :config (vertico-prescient-mode t))

#+end_src

vertico-posframe is an vertico extension, which lets vertico use posframe to show its candidate menu.

#+begin_src emacs-lisp

  (use-package vertico-posframe
    :when (equal completion-handler 'comphand-vertico)
    :ensure t
    :after vertico
    :custom
    (setq vertico-multiform-commands
      '((consult-line
          posframe
          (vertico-posframe-poshandler . posframe-poshandler-frame-top-center)
          (vertico-posframe-border-width . 10)
          ;; NOTE: This is useful when emacs is used in both in X and
          ;; terminal, for posframe do not work well in terminal, so
          ;; vertico-buffer-mode will be used as fallback at the
          ;; moment.
          (vertico-posframe-fallback-mode . vertico-buffer-mode))
         (t posframe)))
    (vertico-multiform-mode 1)
    (setq vertico-posframe-parameters
      '((left-fringe . 8)
         (right-fringe . 8))))

  ;;; ^^^ ;;;
#+end_src

*** Marginalia
:properties:
:custom_id: marginalia
:visibility: folded
:end:

Marginalia are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations placed at the margin of the minibuffer for your completion candidates. Marginalia can only add annotations to the completion candidates. It cannot modify the appearance of the candidates themselves, which are shown unaltered as supplied by the original command.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package marginalia
    :when (or (equal completion-handler 'comphand-vertico)
            (equal completion-handler 'comphand-corfu))
    :ensure t
    :after (:any vertico corfu)
    ;; :commands marginalia-mode
    :custom
    (marginalia-max-relative-age 60)
    (marginalia-align 'left)
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :config
    (marginalia-mode t))

#+end_src

**** Icons for Marginalia
:properties:
:custom_id: icons-for-marginalia
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package all-the-icons-completion
    :ensure t
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup))

#+end_src

*** Consult
:properties:
:custom_id: consult
:visibility: folded
:end:

Consult provides search and navigation commands based on the Emacs completion function completing-read. Completion allows you to quickly select an item from a list of candidates. Consult offers asynchronous and interactive consult-grep and consult-ripgrep commands, and the line-based search command consult-line. Furthermore Consult provides an advanced buffer switching command consult-buffer to switch between buffers, recently opened files, bookmarks and buffer-like candidates from other sources. Some of the Consult commands are enhanced versions of built-in Emacs commands.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package consult
    :when (equal completion-handler 'comphand-vertico)
    :after vertico
    :ensure t
    :defer t
    :bind
    ([remap switch-to-buffer] . consult-buffer)
    ([remap switch-to-buffer-other-window] . consult-buffer-other-window)
    ([remap switch-to-buffer-other-frame] . consult-buffer-other-frame)
    ([remap project-switch-to-buffer] . consult-project-buffer)
    ([remap bookmark-jump] . consult-bookmark)
    ([remap recentf-open] . consult-recent-file)
    ([remap yank] . nil)
    ([remap yank-pop] . consult-yank-pop)
    ([remap goto-line] . consult-goto-line)
    ("M-g m" . consult-mark)
    ("M-g M" . consult-global-mark)
    ("M-g o" . consult-outline)
    ("M-g i" . consult-imenu)
    ("M-g I" . consult-imenu-multi)
    ("M-s l" . consult-line)
    ("M-s p" . consult-preview)  
    ("M-s L" . consult-line-multi)
    ("M-s k" . consult-keep-lines)
    ("M-s u" . consult-focus-lines)
    ("M-s r" . consult-ripgrep)
    ("M-s f" . consult-find)
    ("M-s F" . consult-locate)
    ("M-g e" . consult-compile-error)
    ("M-g f" . consult-flymake)
    ([remap repeat-complex-command] . consult-complex-command)
    ("M-s e" . consult-isearch-history)
    ([remap isearch-edit-string] . consult-isearch-history)
    ([remap next-matching-history-element] . consult-history)
    ([remap previous-matching-history-element] . consult-history)
    ([remap Info-search] . consult-info)
    :custom
    (xref-show-xrefs-function 'consult-xref)
    (xref-show-definitions-function 'consult-xref)
    :config
    (setq consult-buffer-sources
      '(consult--source-hidden-buffer 
         consult--source-buffer
         (:name "Ephemeral" :state consult--buffer-state
           :narrow 109 :category buffer
           :items ("*Messages*"  "*scratch*" "*vterm*"
                    "*Async-native-compile-log*" "*dashboard*"))
         consult--source-modified-buffer
         consult--source-recent-file)))

#+end_src

*** Embark
:properties:
:custom_id: embark
:visibility: folded
:end:

Embark makes it easy to choose a command to run based on what is near point, both during a minibuffer completion session (in a way familiar to Helm or Counsel users) and in normal buffers. Bind the command embark-act to a key and it acts like prefix-key for a keymap of actions (commands) relevant to the target around point. With point on an URL in a buffer you can open the URL in a browser or eww or download the file it points to. If while switching buffers you spot an old one, you can kill it right there and continue to select another. Embark comes preconfigured with over a hundred actions for common types of targets such as files, buffers, identifiers, s-expressions, sentences; and it is easy to add more actions and more target types. Embark can also collect all the candidates in a minibuffer to an occur-like buffer or export them to a buffer in a major-mode specific to the type of candidates, such as dired for a set of files, ibuffer for a set of buffers, or customize for a set of variables.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; Taken from:
  ;; https://erick.navarro.io/blog/switching-from-helm-to-vertico-and-friends
  ;;
  (defun mifi/grep-edit-results ()
    "Export results using `embark-export' and activate `wgrep'.
  This only runs for ripgrep results"
    (interactive)
    (when (cl-search "Ripgrep" (buffer-string))
      ;; we use `run-at-time' to ensure all of these steps
      ;; will be executed in order
      (run-at-time 0 nil #'embark-export)
      (run-at-time 0 nil #'wgrep-change-to-wgrep-mode))
      ;; Don't be evil
      ;; (run-at-time 0 nil #'evil-normal-state)))
    )

  (use-package embark
    :when (equal completion-handler 'comphand-vertico)
    :ensure t
    :defer t
    :bind
    ( ("C-." . embark-act)         ;; pick some comfortable binding
      ("C-;" . embark-dwim)        ;; good alternative: M-.
      ("C-h B" . embark-bindings)  ;; alternative for `describe-bindings'
      ("C-c C-e" . mifi/grep-edit-results))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc. You may adjust the
    ;; Eldoc strategy, if you want to see the documentation from
    ;; multiple providers. Beware that using this can be a little
    ;; jarring since the message shown in the minibuffer can be more
    ;; than one line, causing the modeline to move up and down:

    ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
      '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
         nil
         (window-parameters (mode-line-format . none))))
    :ensure-system-package
    ((rg . "brew install ripgrep")))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :when (equal completion-handler 'comphand-vertico)
    :after embark
    :ensure t
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

#+end_src

*** Helm
:properties:
:custom_id: helm
:visibility: folded
:end:

Helm is an Emacs framework for incremental completions and narrowing selections. It provides an easy-to-use API for developers wishing to build their own Helm applications in Emacs, powerful search tools and dozens of already built-in commands providing completion to almost everything. It is a must-have for anyone using Emacs as a main work environment. Helm has been widely adopted by many Emacs power-users.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package helm
    :when (equal completion-handler 'comphand-helm)
    :after async
    :ensure t
    :bind
    ("M-x"   . helm-M-x)
    ("M-s o" . helm-occur)
    ([remap find-file] . helm-find-files)
    ([remap switch-to-buffer] . helm-mini)
    :init
    ;; open helm buffer inside current window, not occupy whole other window
    (setq helm-split-window-inside-p t)
    ;; move to end or beginning of source when reaching top or bottom of source.
    (setq helm-move-to-line-cycle-in-source t)
    ;; search for library in `require' and `declare-function' sexp.
    (setq helm-ff-search-library-in-sexp t)
    ;; scroll 8 lines other window using M-<next>/M-<prior>
    (setq helm-scroll-amount 8)
    (setq helm-ff-file-name-history-use-recentf t)
    (setq helm-echo-input-in-header-line t)
    ;; (setq helm-autoresize-max-height 0)
    ;; (setq helm-autoresize-min-height 20)
    :config
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))
    (helm-autoresize-mode 1)
    (helm-mode 1))

#+end_src

**** helm wikipedia
:properties:
:custom_id: helm-wikipedia
:visibility: folded
:end:

#+begin_src emacs-lisp

  (use-package helm-wikipedia
    :after helm
    :ensure t
    :bind
    ("C-c h w" . helm-wikipedia-lookup)
    :custom
    (helm-wikipedia-summary-url
      "https://fr.wikipedia.org/w/api.php?action=query&format=json&prop=extracts&titles=%s&exintro=1&explaintext=1&redirects=1")
    (helm-wikipedia-suggest-url
      "https://fr.wikipedia.org/w/api.php?action=opensearch&search=%s"))

#+end_src

*** Built-In (Ido)
:properties:
:custom_id: build-in-ido
:visibility: folded
:end:

Enable the IDO handler everywhere.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; This has to be evaluated at the end of the init since it's possible that the
  ;; completion-handler variable will not yet be defined at this point in the
  ;; init phase usi\ng elpaca.

  (add-hook 'after-init-hook
    (lambda ()
      (use-package ido
        :when (equal completion-handler 'comp-hand-ido)
        :ensure nil
        :config
        (ido-everywhere t))))

#+end_src

** Terminals
:properties:
:custom_id: terminals
:visibility: folded
:end:

*** term-mode
:properties:
:custom_id: term-mode
:visibility: folded
:end:

=term-mode= is a built-in terminal emulator in Emacs. Because it is written in Emacs Lisp, you can start using it immediately with very little configuration. If you are on Linux or macOS, =term-mode= is a great choice to get started because it supports fairly complex terminal applications (=htop=, =vim=, etc) and works pretty reliably. However, because it is written in Emacs Lisp, it can be slower than other options like =vterm=. The speed will only be an issue if you regularly run console apps with a lot of output.

One important thing to understand is =line-mode= versus =char-mode=. =line-mode= enables you to use normal Emacs keybindings while moving around in the terminal buffer while =char-mode= sends most of your keypresses to the underlying terminal. While using =term-mode=, you will want to be in =char-mode= for any terminal applications that have their own keybindings. If you're just in your usual shell, =line-mode= is sufficient and feels more integrated with Emacs.

With =evil-collection= installed, you will automatically switch to =char-mode= when you enter Evil's insert mode (press =i=). You will automatically be switched back to =line-mode= when you enter Evil's normal mode (press =ESC=).

Run a terminal with =M-x term!=

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[=  and =]]= with evil-mode)
- =C-c C-k= - Enter char-mode
- =C-c C-j= - Return to line-mode
- If you have =evil-collection= installed, =term-mode= will enter char mode when you use Evil's Insert mode

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package term+
    ;;:ensure (:repo "tarao/term-plus-el" :fetcher github)
    :commands term
    :config
    (setq explicit-shell-file-name "bash") ;; Change this to zsh, etc
    ;;(setq explicit-zsh-args '())          ;; Use 'explicit-<shell>-args for shell-specific args

    ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

#+end_src

*** Better term-mode colors
:properties:
:custom_id: better-term-mode-colors
:visibility: folded
:end:

The =eterm-256color= package enhances the output of =term-mode= to enable handling of a wider range of color codes so that many popular terminal applications look as you would expect them to. Keep in mind that this package requires =ncurses= to be installed on your machine so that it has access to the =tic= program. Most Linux distributions come with this program installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package eterm-256color
    :ensure t
    :hook (term-mode . eterm-256color-mode))

#+end_src

*** vterm
:properties:
:custom_id: vterm
:visibility: folded
:end:

[[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native module to interact with the underlying terminal applications. This enables it to be much faster than =term-mode= and to also provide a more complete terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to use =vterm= because there is a module that will need to be compiled before you can use it successfully.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package vterm
    ;;:ensure (:fetcher github :repo "akermu/emacs-libvterm")
    :ensure t
    :defer t
    :commands vterm
    :config
    (setq vterm-environment ("PS1=\\u@\\h:\\w \n$"))
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
    (setq vterm-shell "zsh")                        ;; Set this to customize the shell to launch
    (setq vterm-max-scrollback 10000))

#+end_src

*** shell-mode
:properties:
:custom_id: shell-mode
:visibility: folded
:end:

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell. It is *not* a terminal emulator so more complex terminal programs will not run inside of it. It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter. This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[=  and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

*** Eshell
:properties:
:custom_id: eshell
:visibility: folded
:end:

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp. It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc). It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=). Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well. However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[=  and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-esh-history= - A searchable history of commands typed into Eshell

We will be covering Eshell more in future videos highlighting other things you can do with it.

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)
    (setq eshell-history-size   10000
      eshell-buffer-maximum-lines 10000
      eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t))

  (use-package eshell-git-prompt
    :after eshell)

  (use-package eshell
    :ensure nil
    :defer t
    :hook (eshell-first-time-mode . mifi/configure-eshell)
    :config
    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "zsh" "vim")))
    (eshell-git-prompt-use-theme 'powerline))

#+end_src

** File Management
:properties:
:custom_id: file-management
:visibility: folded
:end:

*** Dired
:properties:
:custom_id: dired
:visibility: folded
:end:

Dired is a built-in file manager for Emacs that does some pretty amazing things! Here are some key bindings you should try out:

**** Key Binding Instructions
:properties:
:custom_id: key-binding-instructions
:visibility: folded
:end:

+ ***** Navigation
*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing
  configuration (and after filesystem changes!)

+ ***** Marking files
- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them
  back)
- Many operations can be done on a single file if there are no active marks!

+ ***** Copying and Renaming files
- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in
the buffer editable directly to rename them! Press =Z Z= to confirm renaming or
=Z Q= to abort.

+ ***** Deleting files
- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

+ ***** Creating and extracting archives
- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

+ ***** Other common operations
- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

**** Use =gls= for dired on macOS
:properties:
:custom_id: use-gls-for-dired-on-macos
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; Prefer g-prefixed coreutils version of standard utilities when available
  (let ((gls (executable-find "gls")))
    (when gls (setq-default insert-directory-program gls
                dired-use-ls-dired t
                ;; Needed to fix an issue on Mac which causes dired to fail
                dired-listing-switches "-al --group-directories-first")))

  #+end_src

**** All the icons - Dired
:properties:
:custom_id: all-the-icons-dired
:visibility: folded
:end:

To know the type of file at a glance, [[https://github.com/jtbm37/all-the-icons-dired][all-the-icons-dired]] integrates icons
directly into =dired=.

  #+begin_src emacs-lisp
    (use-package all-the-icons-dired
      :after dired
      :ensure t
      :when (display-graphic-p)
      :hook (dired-mode . all-the-icons-dired-mode))
    #+end_src


**** Files to open eternally
:properties:
:custom_id: files-to-open-eternally
:visibility: folded
:end:

By default, =dired= opens files in plain text. This behavior is sometimes
undesirable. Hopefully, [[https://github.com/Fuco1/dired-hacks/blob/master/dired-open.el][dired-open]] can be used to informs =dired= that certain
desired file extensions must be opened with external packages to GNU Emacs.

    #+begin_src emacs-lisp
    (use-package dired-open
      :ensure t
      :commands (dired dired-jump)
      :config
      ;; Doesn't work as expected!
      ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
      (setq dired-open-extensions '(("png" . "feh")
                                     ("mkv" . "mpv"))))
#+end_src

**** Hide dot files
:properties:
:custom_id: hide-dot-files
:visibility: folded
:end:

It is sometimes convenient to hide dotfiles. With [[https://github.com/mattiasb/dired-hide-dotfiles][dired-hide-dotfiles]] this
becomes possible.

#+begin_src emacs-lisp
    (use-package dired-hide-dotfiles
      :ensure t
      :after dired-mode
      :hook (dired-mode . dired-hide-dotfiles-mode))

#+end_src

**** Tab to open subdirs
:properties:
:custom_id: tab-to-open-subdirs
:visibility: folded
:end:

I like being able to =<TAB>= on a folder and see its contents, without me getting
into it. [[https://github.com/Fuco1/dired-hacks/blob/master/dired-subtree.el][dired-subtree]] allows this behavior.

#+begin_src emacs-lisp
  (use-package dired-subtree
    :after dired
    :ensure t
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)))
#+end_src

**** Large number of files handling
:properties:
:custom_id: large-number-of-files-handling
:visibility: folded
:end:

Finally, to manage folders with a large number of files, it may be useful to
filter with [[https://github.com/Fuco1/dired-hacks/blob/master/dired-narrow.el][dired-narrow]]

#+begin_src emacs-lisp
  (use-package dired-narrow
    :ensure nil
    :bind (("C-c C-n" . dired-narrow)
           ("C-c C-f" . dired-narrow-fuzzy)))
#+end_src

**** Single Window
:properties:
:custom_id: single-window
:visibility: folded
:end:

This package provides a way to reuse the current dired buffer to visit another directory (rather than creating a new buffer for the new directory). Optionally, it allows the user to specify a name that all such buffers will have, regardless of the directory they point to.

#+begin_src emacs-lisp
  (use-package dired-single
    :ensure nil ;; Package installed in local 'lisp' directory
    :after dired
    :bind (:map dired-mode-map
                ([remap dired-find-file] . dired-single-buffer)
                ([remap dired-up-directory] . dired-single-up-directory)
                ("M-DEL" . dired-prev-subdir)))
#+end_src

**** Special ediff with dired
:properties:
:custom_id: special-ediff-with-dired
:visibility: folded
:end:

Virtical Split comparison of two files selected from the dired window.
(www.youtube.com/@emacselements)

***** Supporting Functions
:properties:
:custom_id: supporting-functions
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################
  
  (defun mifi/dired-ediff-marked-files ()
    "Compare two marked files in Dired with ediff."
    (interactive)
    (let ((marked-files (dired-get-marked-files)))
      (unless (= (length marked-files) 2)
        (error "You need to mark exactly two files to compare."))
      (ediff-files (car marked-files) (cadr marked-files))))

  (defun mifi/ediff-bsh ()
    "Function to be called before any buffers or window setup for
        ediff."
    (setq mifi/ediff-bwin-config (current-window-configuration))
    (when (characterp mifi/ediff-bwin-reg)
      (set-register mifi/ediff-bwin-reg
        (list mifi/ediff-bwin-config (point-marker)))))

  (defun mifi/ediff-ash ()
    "Function to be called after buffers and window setup for ediff."
    (setq mifi/ediff-awin-config (current-window-configuration))
    (when (characterp mifi/ediff-awin-reg)
      (set-register mifi/ediff-awin-reg
        (list mifi/ediff-awin-config (point-marker)))))

  (defun mifi/ediff-qh ()
    "Function to be called when ediff quits."
    (when mifi/ediff-bwin-config
      (set-window-configuration mifi/ediff-bwin-config)))

#+end_src

***** Customized Variables
:properties:
:custom_id: customized-variables
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; Restore window configuration after ediff exits
  ;;   URL: https://www.emacswiki.org/emacs/EdiffMode

  (defvar mifi/ediff-bwin-config nil "Window configuration before ediff.")
  (defcustom mifi/ediff-bwin-reg ?b
    "*Register to be set up to hold `mifi/ediff-bwin-config' configuration.")

  (defvar mifi/ediff-awin-config nil "Window configuration after ediff.")
  (defcustom mifi/ediff-awin-reg ?e
    "*Register to be used to hold `mifi/ediff-awin-config' window configuration.")

#+end_src

***** Dired and ediff configuration
:properties:
:custom_id: dired-and-ediff-configuration
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package dired
    :ensure nil
    :no-require t
    :bind (:map dired-mode-map
          ("=" . mifi/dired-ediff-marked-files)))

  (use-package ediff
    :ensure nil
    :no-require t
    :custom
    (ediff-diff-options "-w")
    ;; Split windows so that they are compared horizontally
    (ediff-split-window-function 'split-window-horizontally)
    :hook
    (ediff-before-setup . mifi/ediff-bsh)
    (ediff-after-setup-window . (lambda () (mifi/ediff-ash 'append)))
    (ediff-quit . mifi/ediff-qh))

#+end_src

*** Treemacs
:properties:
:custom_id: treemacs
:visibility: folded
:end:

Treemacs is a file and project explorer similar to NeoTree or vim’s NerdTree, but largely inspired by the Project Explorer in Eclipse. It shows the file system outlines of your projects in a simple tree layout allowing quick navigation and exploration, while also possessing basic file management utilities.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Treemacs

  (use-package treemacs
    :after (:all winum ace-window)
    :ensure t
    :bind (:map global-map
            ("M-0"       . treemacs-select-window)
            ("C-x t 1"   . treemacs-delete-other-windows)
            ("C-x t t"   . treemacs)
            ("C-x t d"   . treemacs-select-directory)
            ("C-x t B"   . treemacs-bookmark)
            ("C-x t C-t" . treemacs-find-file)
            ("C-x t M-t" . treemacs-find-tag))
    :config
    (setq treemacs-collapse-dirs                  (if treemacs-python-executable 3 0)
      treemacs-deferred-git-apply-delay  0.5
      treemacs-directory-name-transformer        #'identity
      treemacs-display-in-side-window            t
      treemacs-eldoc-display                     'simple
      treemacs-file-event-delay          2000
      treemacs-file-extension-regex              treemacs-last-period-regex-value
      treemacs-file-follow-delay                 0.2
      treemacs-file-name-transformer             #'identity
      treemacs-follow-after-init                 t
      treemacs-expand-after-init                 t
      treemacs-find-workspace-method             'find-for-file-or-pick-first
      treemacs-git-command-pipe          ""
      treemacs-goto-tag-strategy                 'refetch-index
      treemacs-header-scroll-indicators  '(nil . "^^^^^^")
      treemacs-hide-dot-git-directory            t
      treemacs-indentation                       2
      treemacs-indentation-string                " "
      treemacs-is-never-other-window             nil
      treemacs-max-git-entries           5000
      treemacs-missing-project-action            'ask
      treemacs-move-forward-on-expand            nil
      treemacs-no-png-images                     nil
      treemacs-no-delete-other-windows   t
      treemacs-project-follow-cleanup            nil
      treemacs-persist-file                      (expand-file-name
                                                   ".cache/treemacs-persist"
                                                   user-emacs-directory)
      treemacs-position                  'left
      treemacs-read-string-input                 'from-child-frame
      treemacs-recenter-distance                 0.1
      treemacs-recenter-after-file-follow        nil
      treemacs-recenter-after-tag-follow         nil
      treemacs-recenter-after-project-jump       'always
      treemacs-recenter-after-project-expand     'on-distance
      treemacs-litter-directories                '("/node_modules"
                                                    "/.venv"
                                                    "/.cask"
                                                    "/__pycache__")
      treemacs-project-follow-into-home  nil
      treemacs-show-cursor                       nil
      treemacs-show-hidden-files                 t
      treemacs-silent-filewatch          nil
      treemacs-silent-refresh                    nil
      treemacs-sorting                   'alphabetic-asc
      treemacs-select-when-already-in-treemacs 'move-back
      treemacs-space-between-root-nodes  t
      treemacs-tag-follow-cleanup                t
      treemacs-tag-follow-delay          1.5
      treemacs-text-scale                        nil
      treemacs-user-mode-line-format             nil
      treemacs-user-header-line-format   nil
      treemacs-wide-toggle-width                 70
      treemacs-width                             38
      treemacs-width-increment           1
      treemacs-width-is-initially-locked         t
      treemacs-workspace-switch-cleanup  nil)

    ;; The default width and height of the icons is 22 pixels. If you are
    ;; using a Hi-DPI display, uncomment this to double the icon size.
    ;;(treemacs-resize-icons 44)

    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode 'always)
    (when treemacs-python-executable
      (treemacs-git-commit-diff-mode t))
    (pcase (cons (not (null (executable-find "git")))
             (not (null treemacs-python-executable)))
      (`(t . t)
        (treemacs-git-mode 'deferred))
      (`(t . _)
        (treemacs-git-mode 'simple)))
    (treemacs-hide-gitignored-files-mode nil))

#+end_src

**** Treemacs Projectile
:properties:
:custom_id: treemacs-projectile
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package treemacs-projectile
    :ensure t
    :when (equal custom-project-handler 'custom-project-projectile)
    :after treemacs projectile)

#+end_src

**** Treemacs dired
:properties:
:custom_id: treemacs-dired
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package treemacs-icons-dired
    :ensure t
    :after treemacs
    :hook (dired-mode . treemacs-icons-dired-enable-once))

#+end_src

**** Treemacs Persp
:properties:
:custom_id: treemacs-persp
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; (use-package treemacs-perspective
  ;;    :disabled
  ;;    :after (treemacs persp-mode) ;;or perspective vs. persp-mode
  ;;    :config (treemacs-set-scope-type 'Perspectives))

  (use-package treemacs-persp ;;treemacs-perspective if you use perspective.el vs. persp-mode
    ;;:ensure (:files ("src/extra/treemacs-persp.el" "treemacs-persp-pkg.el"):host github :repo "Alexander-Miller/treemacs")
    :ensure t
    :after (:any treemacs persp-mode) ;;or perspective vs. persp-mode
    :config (treemacs-set-scope-type 'Perspectives))

#+end_src

**** Treemacs tab-bar
:properties:
:custom_id: treemacs-tar-bar
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
    :ensure t
    :after treemacs
    :config (treemacs-set-scope-type 'Tabs))

#+end_src

**** Treemacs all-the-icons
:properties:
:custom_id: treemacs-all-the-icons
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package treemacs-all-the-icons
    :ensure t
    :after treemacs
    :when (display-graphic-p))

#+end_src

* Window Management
:properties:
:custom_id: window-management
:visibility: folded
:end:

These packages enhance the management of windows and buffers.

** Ace Window
:properties:
:custom_id: ace-window
:visibility: folded
:end:

[[https://github.com/abo-abo/ace-window][ace-window]] is a package for selecting a window to switch to. Like =other-window= but better!

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package ace-window
    :ensure t
    :bind ("M-o" . ace-window))

#+end_src

** Golden Ratio
:properties:
:custom_id: golden-ratio
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; Golen Ratio

  (use-package golden-ratio
    :when enable-golden-ratio
    :custom
    (golden-ratio-auto-scale t)
    (golden-ratio-adjust-factor .4)
    (golden-ratio-wide-adjust-factor .4)
    (golden-ratio-max-width 100)
    (golden-ratio-exclude-modes '(
                                   prog-mode
                                   dashboard-mode
                                   ;;inferior-emacs-lisp-mode
                                   ;;inferior-python-mode
                                   comint-mode
                                   ;;lisp-interaction-mode
                                   treemacs-mode
                                   undo-tree-visualizer-mode
                                   vundo-mode
                                   ))
    (golden-ratio-exclude-buffer-regexp '("dap*"
                                           "*python*"))
    :config
    (golden-ratio-mode 1))

#+end_src

** Popper
:properties:
:custom_id: popper
:visibility: folded
:end:

Popper is a minor-mode to tame the flood of ephemeral windows Emacs produces, while still keeping them within arm’s reach.

Designate any buffer to “popup” status, and it will stay out of your way. Disimss or summon it easily with one key. Cycle through all your “popups” or just the ones relevant to your current buffer. Group popups automatically so you’re presented with the most relevant ones. Useful for many things, including toggling display of REPLs, documentation, compilation or shell output: any buffer you need instant access to but want kept out of your way!

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package popper
    :ensure t :defer t
    :bind (("C-`"   . popper-toggle)
            ("M-`"   . popper-cycle)
            ("C-M-`" . popper-toggle-type))
    :init
    (setq popper-reference-buffers
      '("\\*Messages\\*"
         "\\*scratch\\*"
         "\\*ielm\\*"
         "Output\\*$"
         "\\*Async Shell Command\\*"
         "^\\*eshell.*\\*$" eshell-mode ;eshell as a popup
         "^\\*shell.*\\*$"  shell-mode  ;shell as a popup
         "^\\*term.*\\*$"   term-mode   ;term as a popup
         "^\\*vterm.*\\*$"  vterm-mode  ;vterm as a popup
         help-mode
         compilation-mode))
    :config
    (popper-mode +1)
    (popper-echo-mode +1))

#+end_src

** Swap Buffers
:properties:
:custom_id: swap-buffers
:visibility: folded
:end:

This file is for lazy people wanting to swap buffers without typing C-x b on each window.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package buffer-move
    :bind (("C-S-<up>"     . buf-move-up)
            ("C-S-<down>"  . buf-move-down)
            ("C-S-<left>"  . buf-move-left)
            ("C-S-<right>" . buf-move-right)))

#+end_src

** Writeroom mode
:properties:
:custom_id: writeroom-mode
:visibility: folded
:end:

writeroom-mode is a minor mode for Emacs that implements a distraction-free writing mode similar to the famous Writeroom editor for OS X.  By default, writeroom-mode does the following things:

+ activate fullscreen
+ disable transparency
+ disable the menu bar
+ disable the tool bar
+ disable the scroll bar
+ enable a bottom window divider of 1 pixel
+ maximise the current window (i.e., delete all other windows in the frame)
+ place the fringes outside the margins
+ disable the mode line
+ add window margins to the current buffer so that the text is 80 characters wide

The last three effects are buffer-local. The other effects apply to the current frame. Because writeroom-mode is a minor mode, this isn't entirely on the up and up, since minor modes aren't supposed to have such global effects. But writeroom-mode is meant for distraction-free writing, so these effects do make sense.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package writeroom-mode
    :ensure t
    :defer t
    :init
    (setq writeroom-width visual-fill-column-width)
    :after visual-fill-column)

#+end_src

** winner-mode
:properties:
:custom_id: winner-mode
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package init-windows ;; From purcell
    :ensure nil
    :demand t
    :hook (after-init . winner-mode))

#+end_src
** Winum
:properties:
:custom_id: winum
:visibility: folded
:end:

Window numbers for Emacs: Navigate your windows and frames using numbers. This is not only handy but used by Treemacs to select the Treemacs panel with the keyboard.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Window Number

  (use-package winum
    :ensure t
    :config (winum-mode))

#+end_src

* Visuals
:properties:
:custom_id: visuals
:visibility: folded
:end:

These packages and functions are used to select from a list of curated themes and also to handle frame size changes. In addition to themes, packages that are visually oriented (like writeroom) are also included.

** All-the-icons
:properties:
:custom_id: all-the-icons
:visibility: folded
:end:

This package is a utility for using and formatting various Icon fonts within Emacs.  Icon Fonts allow you to propertize and format icons the same way you would normal text.  This enables things such as better scaling of and anti aliasing of the icons.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package all-the-icons :ensure t)

#+end_src

** Default Text Scale
:properties:
:custom_id: default-text-scale
:visibility: folded
:end:

This package provides commands for increasing or decreasing the default font size in all GUI Emacs frames -- it is like an Emacs-wide version of text-scale-mode.

+ It works by adjusting the height of the default face in the user theme, which is always combined with any other loaded themes.
+ It's handy for quickly adjusting the font size for readability or impromptu screen-sharing.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Default keys are C-M-= or C-M--

  (use-package default-text-scale
    :ensure t
    :hook (after-init . default-text-scale-mode))

#+end_src
** Diff HL
:properties:
:custom_id: diff-hl
:visibility: folded
:end:

=diff-hl-mode= highlights uncommitted changes on the left side of the window (area also known as the "gutter"), allows you to jump between and revert them selectively.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package diff-hl
    :ensure t
    :config
    (global-diff-hl-mode))

#+end_src

** Frame and Font Setup
:properties:
:custom_id: frame-and-font-setup
:visibility: folded
:end:

It's nice to know that Emacs is somewhat working. To help this along, we set the Frame (window size fonts) early in the loading process.

*** Define the various font size constants

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; Frame (view) setup including fonts.
  ;; You will most likely need to adjust this font size for your system!

  (setq-default mifi/small-font-size 150)
  (setq-default mifi/small-mono-font-size 150)
  (setq-default mifi/small-variable-font-size 170)

  (setq-default mifi/medium-font-size 170)
  (setq-default mifi/medium-mono-font-size 170)
  (setq-default mifi/medium-variable-font-size 190)

  (setq-default mifi/large-font-size 190)
  (setq-default mifi/large-mono-font-size 190)
  (setq-default mifi/large-variable-font-size 210)

  (setq-default mifi/x-large-font-size 220)
  (setq-default mifi/x-large-mono-font-size 220)
  (setq-default mifi/x-large-variable-font-size 240)

  ;; (setq-default custom-default-font-size mifi/medium-font-size)
  (setq-default mifi/default-variable-font-size (+ custom-default-font-size 20))
  ;; (setq-default mifi/set-frame-maximized t)  ;; or f

  ;; Make frame transparency overridable
  ;; (setq-default mifi/frame-transparency '(90 . 90))

  (setq frame-resize-pixelwise t)

#+end_src

*** mixed-pitch
:properties:
:custom_id: mixed-pitch
:visibility: folded
:end:

A better version of variable-pitch mode. This keeps certain faces (defined in mixed-pitch-fixed-pitch-faces) fixed-pitch.

#+begin_src emacs-lisp
  ;;; vvv ;;;

  (use-package mixed-pitch
    :defer t
    :ensure t
    :custom
    (mixed-pitch-set-height t)
    :config
    (dolist (face '(org-date org-priority org-special-keyword org-tag))
      (add-to-list 'mixed-pitch-fixed-pitch-faces face)))

#+end_src

*** Functions to set the frame size
:properties:
:custom_id: functions-to-set-the-frame-size
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;; Functions to set the frame size

  (defun mifi/update-frame-dimensions ()
    "Updates the frame dimensions so that it occupies 95% of the width of the
  display and 100% of the display height. The left edge is moved over to the right
  approximately 5% of the width (not sure why the value must be 0.65 but it
  works). The space to the left is done so that the Emacs window plays well with
  Stage Manager on macOS."
    (let ( (width  (nth 3 (assq 'geometry (car (display-monitor-attributes-list)))))
           (height (nth 4 (assq 'geometry (car (display-monitor-attributes-list))))))
      (message "width = %d, height = %d" width height)
      (modify-frame-parameters
        frame '((user-position . t)
                 (top . 0)
                 (left . 0.55)
                 (width . 0.95)
                 (height . 1.0)))
      ))

  ;; Set frame transparency
  (defun mifi/set-frame-alpha-maximized ()
    "Function to set the alpha and also maximize the frame."
    ;; (set-frame-parameter (selected-frame) 'alpha mifi/frame-transparency)
    (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
    (add-to-list 'default-frame-alist '(fullscreen . maximized)))

  ;; default window width and height
  (defun mifi/custom-set-frame-size ()
    "Simple function to set the default frame width/height."
    ;; (set-frame-parameter (selected-frame) 'alpha mifi/frame-transparency)
    (setq swidth (nth 3 (assq 'geometry (car (display-monitor-attributes-list)))))
    (setq sheight (nth 4 (assq 'geometry (car (display-monitor-attributes-list)))))

    (add-to-list 'default-frame-alist '(fullscreen . maximized))
    (unless enable-frameset-restore (mifi/frame-recenter)))

  (defun mifi/frame-recenter (&optional frame)
    "Center FRAME on the screen.  FRAME can be a frame name, a terminal name,
      or a frame.  If FRAME is omitted or nil, use currently selected frame."
    (interactive)
    ;; (set-frame-size (selected-frame) 250 120)
    (unless (eq 'maximised (frame-parameter nil 'fullscreen))
      (mifi/update-frame-dimensions)))

#+end_src

*** Default fonts and sizes
:properties:
:custom_id: default-fonts-and-sizes
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;; Default fonts

  (defun mifi/update-face-attribute ()
    "Set the font faces."
    (interactive)
    ;; ====================================
    (set-face-attribute 'default nil
      :family default-font-family
      :height custom-default-font-size
      :weight 'medium)

    ;; Set the fixed pitch face
    (set-face-attribute 'fixed-pitch nil
      :family mono-spaced-font-family
      :height custom-default-mono-font-size
      :weight 'medium)

    ;; Set the variable pitch face
    (set-face-attribute 'variable-pitch nil
      :family variable-pitch-font-family
      :height (+ custom-default-font-size 20)
      :weight variable-pitch-font-weight))

  ;; This is done so that the Emacs window is sized early in the init phase along
  ;; with the default font size. Startup works without this but it's nice to see
  ;; the window expand early...

  (add-hook 'after-init-hook
    (lambda ()
      (when (display-graphic-p)
        (mifi/update-face-attribute)
        (unless (daemonp)
          (if enable-frameset-restore
            (mifi/restore-desktop-frameset)
            (mifi/frame-recenter)))
        )))

#+end_src

*** Track Selected Font Size
:properties:
:custom_id: track-selected-font-size
:visibility: folded
:end:

The functions in the list =after-setting-font-hook= are called whenever the frame's font changes. In order to save this value, we capture it and store it in the =custom-default-font-size= custom variable. This variable is saved whenver Emacs exists. Then, when Emacs is started again, the default and fixed-pitch font height values are set to =custom-default-font-size=. The variable pitch font is computed as ~(+ custom-default-font-size 20)~

#+begin_src emacs-lisp

  (defun mifi/default-font-height-change ()
    (setq-default custom-default-font-size (face-attribute 'default :height))
    (mifi/update-face-attribute)
    (unless enable-frameset-restore (mifi/frame-recenter)))

  (add-hook 'after-setting-font-hook 'mifi/default-font-height-change)

#+end_src

*** Handle higher-rez monitor.
:properties:
:custom_id: handle-higher-rez-monitor
:visibility: folded
:end:

**** Frame font selection
:properties:
:custom_id: frame-font-selection
:visibility: folded
:end:

This little function toggles between a larger font size and the default font size.

#+begin_src emacs-lisp
  ;; Frame font selection

  (defvar mifi/font-size-slot 1)

  (defun mifi/update-font-size ()
    (cond
      ((equal mifi/font-size-slot 3)
        (setq custom-default-font-size mifi/x-large-font-size
          custom-default-mono-font-size mifi/x-large-mono-font-size
          mifi/default-variable-font-size (+ custom-default-font-size 20))
        (mifi/update-face-attribute))
      ((equal mifi/font-size-slot 2)
        (setq custom-default-font-size mifi/large-font-size
          custom-default-mono-font-size mifi/large-mono-font-size
          mifi/default-variable-font-size (+ custom-default-font-size 20))
        (mifi/update-face-attribute))
      ((equal mifi/font-size-slot 1)
        (setq custom-default-font-size mifi/medium-font-size
          custom-default-mono-font-size mifi/medium-mono-font-size
          mifi/default-variable-font-size (+ custom-default-font-size 20))
        (mifi/update-face-attribute))
      ((equal mifi/font-size-slot 0)
        (setq custom-default-font-size mifi/small-font-size
          custom-default-mono-font-size mifi/small-mono-font-size
          mifi/default-variable-font-size (+ custom-default-font-size 20))
        (mifi/update-face-attribute))))

#+end_src

***** Resolution Key Bindings
:properties:
:custom_id: resolution-key-bindings
:visibility: folded
:end:

Some key kindings to switch to different screen resolutions.

#+begin_src emacs-lisp
  ;; Some alternate keys below....

  (defun mifi/set-recenter-keys ()
    (let ((map global-map))
      (define-key map (kbd "C-S-c 1")
        (lambda () (interactive) (use-small-display-font t)))
      (define-key map (kbd "C-S-c 2")
        (lambda () (interactive) (use-medium-display-font t)))
      (define-key map (kbd "C-S-c 3")
        (lambda () (interactive) (use-large-display-font t)))
      (define-key map (kbd "C-S-c 4")
        (lambda () (interactive) (use-x-large-display-font t)))
      (which-key-add-key-based-replacements
        "C-S-c 1" "recenter-with-small-font"
        "C-S-c 2" "recenter-with-medium-font"
        "C-S-c 3" "recenter-with-large-font"
        "C-S-c 4" "recenter-with-x-large-font")))

#+end_src

***** Frame support functions
:properties:
:custom_id: frame-support-functions
:visibility: folded
:end:

These functions are used to configure the main frame font size. Based upon a monitor's size, it may be necessary to make the font larger or smaller.

#+begin_src emacs-lisp
  ;; Frame support functions

  (defun mifi/set-frame-font (slot)
    (setq mifi/font-size-slot slot)
    (mifi/update-font-size)
    (unless enable-frameset-restore (mifi/frame-recenter)))

  (defun mifi/should-recenter (&optional force-recenter)
    (if force-recenter
      (mifi/frame-recenter)
      ;;else
      (unless enable-frameset-restore (mifi/frame-recenter))))

#+end_src

***** Update other mode fonts if needed
:properties:
:custom_id: update-other-mode-fonts-if-needed
:visibility: folded
:end:

This is for things like Org mode

#+begin_src emacs-lisp

  (defun mifi/update-other-modes-font ()
    "This updates/calls functions to update mode font sizes."
    (when (featurep 'org)
      (mifi/org-font-setup)))

#+end_src

***** Select Display Font and optionally Recenter
:properties:
:custom_id: select-display-font-and-optionally-recenter
:visibility: folded
:end:

These functions resize the font to some pre-defined values and will optiononally resize and recenter the window. (see =mifi-config= defcustom variables for the pre-defined font sizes and font families).

#+begin_src emacs-lisp

  (defun use-small-display-font (&optional force-recenter)
    (interactive)
    (mifi/set-frame-font 0)
    (mifi/reset-if-spacious-padding-mode)
    (mifi/update-other-modes-font)
    (mifi/should-recenter force-recenter))
  (defun use-small-display-font-t () (interactive) (use-small-display-font t))

  (defun use-medium-display-font (&optional force-recenter)
    (interactive)
    (mifi/set-frame-font 1)
    (mifi/reset-if-spacious-padding-mode)
    (mifi/update-other-modes-font)
    (mifi/should-recenter force-recenter))
  (defun use-medium-display-font-t () (interactive) (use-medium-display-font t))

  (defun use-large-display-font (&optional force-recenter)
    (interactive)
    (mifi/set-frame-font 2)
    (mifi/reset-if-spacious-padding-mode)
    (mifi/update-other-modes-font)
    (mifi/should-recenter force-recenter))
  (defun use-large-display-font-t () (interactive) (use-large-display-font t))

  (defun use-x-large-display-font (&optional force-recenter)
    (interactive)
    (mifi/set-frame-font 3)
    (mifi/reset-if-spacious-padding-mode)
    (mifi/update-other-modes-font)
    (mifi/should-recenter force-recenter))
  (defun use-x-large-display-font-t () (interactive) (use-x-large-display-font t))

#+end_src

***** Early Display Resize
:properties:
:custom_id: early-display-resize
:visibility: folded
:end:

Apply saved font/window-size early in the startup process.

#+begin_src emacs-lisp
  ;; This is done so that the Emacs window is sized early in the init phase along with the default font size.
  ;; Startup works without this but it's nice to see the window expand early...
  (when (display-graphic-p)
    (add-hook 'after-init-hook
      (lambda ()
        (progn
          (mifi/update-face-attribute)
          (unless (daemonp)
            (unless enable-frameset-restore (mifi/frame-recenter))))
        )))
#+end_src

*** Window, mode-line, +more padding
:properties:
:custom_id: window-mode-line-more-padding
:visibility: folded
:end:

This package provides a global minor mode to increase the spacing/padding of Emacs windows and frames. The idea is to make editing and reading feel more comfortable.

#+begin_src emacs-lisp

  (use-package spacious-padding
    :ensure t
    :custom
    (spacious-padding-widths
      '( :internal-border-width 15
         :header-line-width 4
         :mode-line-width 6
         :tab-width 4
         :right-divider-width 30
         :scroll-bar-width 8
         :left-fringe-width 20
         :right-fringe-width 20
         :fringe-width 8))
    :config
    (spacious-padding-mode t))

  ;; Read the doc string of `spacious-padding-subtle-mode-line' as it
  ;; is very flexible and provides several examples.
  ;; (setq spacious-padding-subtle-mode-line
  ;;       `( :mode-line-active 'default
  ;;          :mode-line-inactive vertical-border))

  ;;; ^^^ ;;;
#+end_src

** GRIP Mode
:properties:
:custom_id: grip-mode
:visibility: folded
:end:

Instant Github-flavored Markdown/Org preview using Grip (GitHub Readme Instant Preview).

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; Use keybindings
  (use-package grip-mode
    :ensure t :defer t
    :bind (:map markdown-mode-command-map
            ("g" . grip-mode)))

  ;; ;; Or using hooks
  ;; (use-package grip-mode
  ;;   :hook ((markdown-mode org-mode) . grip-mode))

#+end_src
** Lisp Hightlighter
:properties:
:custom_id: lisp-highlighter
:visibility: folded
:end:

highlight-defined is an Emacs minor mode that highlights defined Emacs Lisp symbols in source code.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package highlight-defined
    :defer t
    :after emacs-lisp-mode
    :hook (emacs-lisp-mode . highlight-defined-mode))

#+end_src

** Markdown Mode
:properties:
:custom_id: markdown-mode
:visibility: folded
:end:

markdown-mode is a major mode for editing Markdown-formatted text. The latest stable version is markdown-mode 2.5, released on Feb 12, 2022. See the release notes for details. markdown-mode is free software, licensed under the GNU GPL, version 3 or later.

It's important to note that ~multimarkdown~ is set as the ~markdown-command~. This is an external program that was loaded via brew. Another option is ~pandoc~ and ~markdown.pl~. In each case, these are external and, whatever is chosen, needs to appear as the ~markdown-command~.

+ external markdown-command

#+begin_src bash :tangle no
  brew install multiparkdown
#+end_src

+ markdown-mode package

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; (defun mifi/load-web-support ()
  ;;   (use-package web-server-status-codes )
  ;;   (use-package simple-httpd
  ;;     :preface (setq warning-minimum-level :emergency)
  ;;     
  ;;     :config (setq warning-minimum-level :warning))
  ;;   (use-package websocket )
  ;;   (use-package web-server ))

  (use-package markdown-mode
    :defer t :ensure t
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
    ;;:hook (after-init . mifi/load-web-support))
    

#+end_src

*** Markdown Preview Mode
:properties:
:custom_id: markdown-preview-mode
:visibility: folded
:end:

Markdown preview in emacs features:

+ on save/idle preview update
+ scroll sync
+ custom/extra css and javascript
+ remote preview
+ multiple simultaneous previews
  
#+begin_src emacs-lisp :tangle no

  ;; markdown-preview-mode is depent upon:
  ;; +  markdown-mode.el
  ;; +  websocket.el
  ;; +  web-server.el

  (use-package markdown-preview-mode
    :after (:all websocket web-server markdown-mode)
    :defer t
    :config
    (add-to-list 'markdown-preview-stylesheets
      "https://raw.githubusercontent.com/richleland/pygments-css/master/emacs.css")
    (add-to-list 'markdown-preview-javascript
      "http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"))

#+end_src

*** Impatient Mode
:properties:
:custom_id: impatient-mode
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun markdown-html (buffer)
    (princ (with-current-buffer buffer
  	   (format "<!DOCTYPE html><html><title>Impatient Markdown</title><xmp theme=\"united\" style=\"display:none;\"> %s  </xmp><script src=\"http://ndossougbe.github.io/strapdown/dist/strapdown.js\"></script></html>" (buffer-substring-no-properties (point-min) (point-max))))
      (current-buffer)))

  (use-package simple-httpd
    :ensure t)

  (use-package impatient-mode
    :ensure t :defer t
    :config
    (imp-set-user-filter #'markdown-html)
    :hook (elpaca-after-init . httpd-start))

#+end_src

** Multiple-cursors
:properties:
:custom_id: multiple-cursors
:visibility: folded
:end:

Multiple cursors for Emacs. This is some pretty crazy functionality, so yes, there are kinks. Don't be afraid though.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package multiple-cursors
    :ensure t
    :bind (("C-S-c C-S-c" . mc/edit-lines)
            ("C->" . mc/mark-next-like-this)
            ("C-<" . mc/mark-previous-like-this)
            ("C-c C-<" . mc/mark-all-like-this)))

#+end_src

** Pulsar
:properties:
:custom_id: pulsar
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package pulsar
    :ensure t
    :config
    (pulsar-global-mode)
    :custom
    (pulsar-pulse t)
    (pulsar-delay 0.10)
    (pulsar-iterations 10)
    (pulsar-face 'pulsar-magenta)
    (pulsar-highlight-face 'pulsar-yellow))

#+end_src

** Rainbow-mode
:properties:
:custom_id: rainbow-mode
:visibility: folded
:end:

This minor mode sets background color to strings that match color names, e.g. #0000FF is displayed in white with a blue background.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package rainbow-mode
    :ensure t
    :hook (prog-mode . (lambda () (rainbow-mode t))))

#+end_src

** Save / Restore Frameset
:properties:
:custom_id: save-restore-frameset
:visibility: folded
:end:

These functions will save and restore Emacs framework. These are normally called when starting and exiting Emacs.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  
  (defun mifi/save-desktop-frameset ()
    (unless (or (daemonp)
              (not enable-frameset-restore)
              (not (display-graphic-p)))
      (desktop-save-mode 0)
      (desktop-save-frameset)
      (with-temp-file (expand-file-name "saved-frameset.el" user-emacs-directory)
        (insert (format
                  "(setq desktop-saved-frameset %S)"
                  desktop-saved-frameset)))))

  (add-hook 'kill-emacs-hook 'mifi/save-desktop-frameset -100)

  ;;; ##########################################################################

  (defun mifi/restore-desktop-frameset ()
    (unless (or (daemonp)
              (not enable-frameset-restore)
              (not (display-graphic-p)))
      (let
        ((file (expand-file-name "saved-frameset.el" user-emacs-directory)))
        (desktop-save-mode 0)
        (if (file-exists-p file)
          (progn
            (load file)
            (desktop-restore-frameset)
            (when (featurep 'spacious-padding)
              (when spacious-padding-mode
                (spacious-padding-mode 0)
                (spacious-padding-mode 1))))
          (use-medium-display-font t)))))

#+end_src
** Solair mode
:properties:
:custom_id: solair-mode
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package solaire-mode
    :ensure t
    :after treemacs
    :hook (after-init . solaire-global-mode)
    :config
    (push '(treemacs-window-background-face . solaire-default-face) solaire-mode-remap-alist)
    (push '(treemacs-hl-line-face . solaire-hl-line-face) solaire-mode-remap-alist))

#+end_src

** Theme List and Selection
:properties:
:custom_id: theme-list-and-selection
:visibility: folded
:end:

This bit of code contains a list of themes that I like personally and then allows them to be switched between themselves. The index of ~theme-selector~ is what is set in order to access a theme via the ~mifi/load-theme-from-selector()~ function.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;;
  ;; 1. The function `mifi/load-theme-from-selector' is called from the
  ;;    "C-= =" Keybinding (just search for it).
  ;;
  ;; 2. Once the new theme is loaded via the `theme-selector', the previous
  ;;    theme is unloaded (or disabled) the function(s) defined in the
  ;;    `disable-theme-functions' hook are called (defined in the load-theme.el
  ;;    package).
  ;;
  ;; 3. The function `mifi/cycle-theme-selector' is called by the hook. This
  ;;    function increments the theme-selector by 1, cycling the value to 0
  ;;    if beyond the `theme-list' bounds.
  ;;
  (setq-default loaded-theme (nth theme-selector theme-list))
  (add-to-list 'savehist-additional-variables 'loaded-theme)
  (add-to-list 'savehist-additional-variables 'custom-default-font-size)
  (add-to-list 'savehist-additional-variables 'theme-selector)
  (add-to-list 'savehist-additional-variables 'custom-default-mono-font-size)

#+end_src

*** Cycle Theme Function
:properties:
:custom_id: cycle-theme-function
:visibility: folded
:end:

This is the main function that allows cycling (up or down) through the list of
themes defined in the ~theme-list~. This function is normally called by the
~disable-theme-functions~ hook. Before calling this function, set the variable
~theme-cycle-step~ to either a 1 or -1 depending upon which direction in the
~theme-list~ array to select the next element from. The resulting index will
cycle to the end or the beginning of the list if the computed index goes beyond
element 0 or the length of ~theme-list~. The parameter theme is passed to this
function when a theme becomes disabled (via the ~disable-theme~ function) and
represents the theme that has become disabled.

#+begin_src emacs-lisp
  ;;; vvv ;;;

  (defun mifi/cycle-theme-selector (&rest theme)
    "Cycle the `theme-selector' by 1, resetting to 0 if beyond array bounds."
    (interactive)
    (when (not (eq theme-cycle-step nil))
      (let ((step theme-cycle-step) (result 0))
        (when step
          (setq result (+ step theme-selector))
          (when (< result 0)
            (setq result (- (length theme-list) 1)))
          (when (> result (- (length theme-list) 1))
            (setq result 0)))
        (setq-default theme-selector result))))

  ;; This is used to trigger the cycling of the theme-selector
  ;; It is called when a theme is disabled. The theme is disabled from the
  ;; `mifi/load-theme-from-selector' function.
  (add-hook 'disable-theme-functions #'mifi/cycle-theme-selector)

#+end_src

*** Load Theme Function
:properties:
:custom_id: load-theme-functions
:visibility: folded
:end:

This function simply loads the theme from the theme-list indexed by the ~theme-selector~ variable. Note the advice for ~load-theme~ that deactivates the current theme before activating the new theme. This is done to reset all the colors, a clean slate, before the new theme is activated.

**** Reset spacious-padding
:properties:
:custom_id: reset-spacious-padding
:visibility: folded
:end:

This function is used to reset spacious-padding-mode if it is loaded and active. Reset is performed by turning spacious-padding off and then restoring it to it's original state. The reason for this is that spacious-padding can sometimes get confused and have weird spacing when font-sizes changes - like after a theme switch or display-font change.

#+begin_src emacs-lisp

  (defun mifi/reset-if-spacious-padding-mode ()
    (interactive)
    (when-let ((spm? (featurep 'spacious-padding))
              (spm-on-off (default-value 'spacious-padding-mode)))
      (spacious-padding-mode 0)
      (run-with-timer 0.2 nil
        (lambda (on-off) (spacious-padding-mode on-off)) spm-on-off)))
  
#+end_src

**** Load Theme From Selector
:properties:
:custom_id: load-theme-from-selector
:visibility: folded
:end:

This function loads the theme from the =theme-list= indexed by =theme-selector=. Once the theme is loaded, the variable ~theme-did-load~ is set to t, or nil if the theme failed to load.

#+begin_src emacs-lisp

  (defun mifi/load-theme-from-selector (&optional step)
    "Load the theme in `theme-list' indexed by `theme-selector'."
    (interactive)
    ;; Save value of spacious-padding-mode
    (setq theme-cycle-step nil)
    (cond
      ((or (eq step nil) (eq step 0)) (setq theme-cycle-step 0))
      ((> step 0) (setq theme-cycle-step 1))
      ((< step 0) (setq theme-cycle-step -1)))
    (when loaded-theme
      (disable-theme (intern loaded-theme)))
    (setq loaded-theme (nth theme-selector theme-list))
    (setq theme-did-load (load-theme (intern loaded-theme) t))
    (when (featurep 'org)
      (mifi/org-font-setup))
    (mifi/reset-if-spacious-padding-mode)
    (set-face-foreground 'line-number "SkyBlue4"))
  
#+end_src

*** Theme selection helper functions.
:properties:
:custom_id: theme-selection-helper-functions
:visibility: folded
:end:

#+begin_src emacs-lisp

  (defun mifi/print-custom-theme-name ()
    "Print the current loaded theme from the `theme-list' on the modeline."
    (interactive)
    (message (format "Custom theme is %S" loaded-theme)))

  ;; Quick Helper Functions
  (defun next-theme ()
    "Go to the next theme in the list."
    (interactive)
    (mifi/load-theme-from-selector 1))

  (defun previous-theme ()
    "Go to the next theme in the list."
    (interactive)
    (mifi/load-theme-from-selector -1))

  (defun which-theme ()
    "Go to the next theme in the list."
    (interactive)
    (mifi/print-custom-theme-name))

  (bind-keys
    ;; Go to NEXT theme
    ("M-RET =" . next-theme)
    ;; Go to PREVIOUS theme
    ("M-RET -" . previous-theme)
    ;; Message current theme
    ("M-RET _" . which-theme))

#+end_src

*** Theme Override Values
:properties:
:custom_id: theme-override-values
:visibility: folded
:end:

#+begin_src emacs-lisp

  (defun mifi/org-theme-override-values ()
    (defface org-block-begin-line
      '((t (:underline "#1D2C39" :foreground "SlateGray" :background "#1D2C39")))
      "Face used for the line delimiting the begin of source blocks.")

    (defface org-block
      '((t (:background "#242635" :extend t :font "Avenir Next")))
      "Face used for the source block background.")

    (defface org-block-end-line
      '((t (:overline "#1D2C39" :foreground "SlateGray" :background "#1D2C39")))
      "Face used for the line delimiting the end of source blocks.")

    (defface org-modern-horizontal-rule
      '((t (:strike-through "green" :weight bold)))
      "Face used for the Horizontal like (-----)"))

  (defun mifi/customize-modus-theme ()
    (when (featurep 'org)
      (mifi/org-font-setup))
    (setq modus-themes-common-palette-overrides
      '((bg-mode-line-active bg-blue-intense)
         (fg-mode-line-active fg-main)
         (border-mode-line-active blue-intense))))

  (add-hook 'after-init-hook 'mifi/customize-modus-theme)

  (defun mifi/customize-ef-theme ()
    (defface ef-themes-fixed-pitch
      '((t (:background "#242635" :extend t :font "Courier New")))
      "Face used for the source block background.")
    (when (featurep 'org)
      (mifi/org-font-setup))
    (setq ef-themes-common-palette-override
      '( (bg-mode-line bg-blue-intense)
         (fg-mode-line fg-main)
         (border-mode-line-active blue-intense))))
  ;;(add-hook 'org-load-hook 'mifi/customize-ef-theme)
  (add-hook 'after-init-hook 'mifi/customize-ef-theme)

#+end_src

*** Color Theming
:properties:
:custom_id: color-theming
:visibility: folded
:end:

Color Theming (or just theming) is a curated list of theming packages.
*Note:* If new themes are added in the ~theme-list~ custom variable then they must be included here along with any customizations.

#+begin_src emacs-lisp

  (add-to-list 'custom-theme-load-path (expand-file-name "Themes" custom-docs-directory))
  (add-to-list 'custom-theme-load-path (expand-file-name "lisp" emacs-config-directory))

  (mifi/org-theme-override-values)
  (use-package tron-legacy-theme :defer t :ensure t)
  (use-package ef-themes :init (mifi/customize-ef-theme) :defer t :ensure t)
  (use-package modus-themes :init (mifi/customize-modus-theme) :defer t :ensure t)
  (use-package material-theme :defer t :ensure t)
  (use-package color-theme-modern :defer t :ensure t)
  (use-package color-theme-sanityinc-tomorrow :defer t :ensure t)
  ;; Can't defer darktooth since we need the base theme to always load
  (use-package darktooth-theme :ensure t)
  (use-package zenburn-theme :defer t :ensure t)

#+end_src

*** Selected theme
:properties:
:custom_id: selected-theme
:visibility: folded
:end:

This includes the theme to use in both graphical and non-graphical.

#+begin_src emacs-lisp
  ;; (add-hook 'emacs-startup-hook #'(mifi/load-theme-from-selector))
  ;; (mifi/load-theme-from-selector)
  ;; For terminal mode we choose Material theme

  (defun mifi/load-terminal-theme ()
    (load-theme (intern default-terminal-theme) t))

  (unless (display-graphic-p)
    (add-hook 'after-init-hook 'mifi/load-terminal-theme)
    ;;else
    (progn
      (if (not after-init-time)
        (add-hook 'after-init-hook
          (lambda ()
            (unless theme-did-load
              (mifi/load-theme-from-selector))))
        ;; else
        (add-hook 'window-setup-hook
          (lambda ()
            (unless theme-did-load
              (mifi/load-theme-from-selector))))
        )))

  ;;; ^^^ ;;;
#+end_src

** Visual Fill
:properties:
:custom_id: visual-fill
:visibility: folded
:end:

We use [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] to center =org-mode= buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document. This is really a matter of personal preference so you can remove the block below if you don't like the behavior.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package visual-fill-column
    :ensure nil ;; Should be installed in the local lisp dir.
    :defer t
    :after org)

#+end_src
* Productivity
:properties:
:custom_id: productivity
:visibility: folded
:end:

Several productivity packages that I find very useful.

** Org Mode
:PROPERTIES:
:CUSTOM_ID: org-mode
:VISIBILITY: folded
:END:

<<Org Mode>> is one of the hallmark features of Emacs. It is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package [[https://orgmode.org/][Orgmode]].

The =mifi/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=. We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

*** Font setup
:properties:
:custom_id: font-setup
:visibility: folded
:end:

This function sets up the fonts faces that are used within org-mode.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; (use-package faces :ensure t)
  (defun mifi/org-font-setup ()
    "Setup org mode fonts."

    (font-lock-add-keywords
      'org-mode
      '(("^ *\\([-]\\) "
          (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    
    (set-face-attribute 'org-block nil
      :foreground 'unspecified
      :inherit 'fixed-pitch
      :font mono-spaced-font-family
      :height custom-default-mono-font-size)
    
    (set-face-attribute 'org-formula nil
      :inherit 'fixed-pitch)
    
    (set-face-attribute 'org-code nil
      :foreground 'unspecified
      :font mono-spaced-font-family
      :height custom-default-mono-font-size
      :inherit '(shadow fixed-pitch))

    (set-face-attribute 'org-verbatim nil
      :foreground 'unspecified
      :font mono-spaced-font-family
      :height custom-default-mono-font-size
      :inherit 'fixed-pitch)

    (set-face-attribute 'org-table nil
      :foreground 'unspecified
      :font mono-spaced-font-family
      :height custom-default-mono-font-size
      :inherit '(shadow fixed-pitch))
    
    (set-face-attribute 'org-verbatim nil
      :foreground 'unspecified
      :font mono-spaced-font-family
      :height custom-default-mono-font-size
      :inherit '(shadow fixed-pitch))
    
    (set-face-attribute 'org-special-keyword nil
      :inherit '(font-lock-comment-face fixed-pitch))
    
    (set-face-attribute 'org-meta-line nil
      :inherit '(font-lock-comment-face fixed-pitch))
    
    (set-face-attribute 'org-checkbox nil
      :foreground 'unspecified
      :font mono-spaced-font-family
      :height custom-default-mono-font-size
      :inherit 'fixed-pitch)
    
    (set-face-attribute 'line-number nil
      :foreground 'unspecified
      :font mono-spaced-font-family
      :height custom-default-mono-font-size
      :inherit 'fixed-pitch)
    
    (set-face-attribute 'line-number-current-line nil
      :foreground 'unspecified
      :font mono-spaced-font-family
      :height custom-default-mono-font-size
      :inherit 'fixed-pitch)

    (dolist (face '((org-level-1 . 1.50)
                     (org-level-2 . 1.25)
                     (org-level-3 . 1.15)
                     (org-level-4 . 1.05)
                     (org-level-5 . 0.95)
                     (org-level-6 . 0.90)
                     (org-level-7 . 0.90)
                     (org-level-8 . 0.90)))
      (set-face-attribute (car face) nil :font "Helvetica Neue" :weight 'regular
        :height (cdr face))))
#+end_src

*** Org Setup
:properties:
:custom_id: org-setup
:visibility: folded
:end:

This section contains the basic configuration for =org-mode= plus the configuration for Org agendas and capture templates.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/org-mode-visual-fill ()
    (interactive)
    (setq visual-fill-column-width custom-org-fill-column
      visual-fill-column-center-text enable-org-fill-column-centering)
    (visual-fill-column-mode 1))

  (defun mifi/toggle-org-centering ()
    (interactive)
    (setq-default enable-org-fill-column-centering
      (not enable-org-fill-column-centering))
    (org-mode-restart))

  (defun mifi/org-mode-setup ()
    (interactive)
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1)
    (mifi/org-mode-visual-fill)
    (font-lock-add-keywords nil
      '(("^_\\{5,\\}"    0 '(:foreground "green" :weight bold))))
    (setq org-ellipsis " ▾")
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    ;; (use-package org-habit)
    ;; (add-to-list 'org-modules 'org-habit)
    ;; (setq org-habit-graph-column 60)
    (setq org-refile-targets
      '(("Archive.org" :maxlevel . 1)
         ("Tasks.org" :maxlevel . 1))))

#+end_src

***** Setup org-agenda
:properties:
:custom_id: setup-org-agenda-files-list
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/set-org-agenda-directory ()
    "Sets the org-agenda directory based upon the customized variable and then
  sets the org-agenda-files list to all the files in that directory. The
  directory is relative to the working-files-directory
  (a.k.a user-emacs-directory)."
    (interactive)
    (let ((agenda-dir (format "%s/%s"
                        working-files-directory
                      org-agenda-dirname)))
      (make-directory agenda-dir t)
      (custom-set-variables
        '(org-directory agenda-dir)
        '(org-agenda-files (list org-directory)))))


  #+end_src
  
  #+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/org-setup-agenda ()
    "Function to setup basic org-agenda settings."
    (bind-key "C-c a" 'org-agenda org-mode-map)
    ;; (mifi/set-org-agenda-directory) ;; Where all the org-agenda files live    
    (setq org-agenda-custom-commands
      '(("d" "Dashboard"
          ((agenda "" ((org-deadline-warning-days 7)))
            (todo "NEXT"
              ((org-agenda-overriding-header "Next Tasks")))
            (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

         ("n" "Next Tasks"
           ((todo "NEXT"
              ((org-agenda-overriding-header "Next Tasks")))))

         ("W" "Work Tasks" tags-todo "+work-email")

         ;; Low-effort next actions
         ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
           ((org-agenda-overriding-header "Low Effort Tasks")
             (org-agenda-max-todos 20)
             (org-agenda-files org-agenda-files)))

         ("w" "Workflow Status"
           ((todo "WAIT"
              ((org-agenda-overriding-header "Waiting on External")
                (org-agenda-files org-agenda-files)))
             (todo "REVIEW"
               ((org-agenda-overriding-header "In Review")
                 (org-agenda-files org-agenda-files)))
             (todo "PLAN"
               ((org-agenda-overriding-header "In Planning")
                 (org-agenda-todo-list-sublevels nil)
                 (org-agenda-files org-agenda-files)))
             (todo "BACKLOG"
               ((org-agenda-overriding-header "Project Backlog")
                 (org-agenda-todo-list-sublevels nil)
                 (org-agenda-files org-agenda-files)))
             (todo "READY"
               ((org-agenda-overriding-header "Ready for Work")
                 (org-agenda-files org-agenda-files)))
             (todo "ACTIVE"
               ((org-agenda-overriding-header "Active Projects")
                 (org-agenda-files org-agenda-files)))
             (todo "COMPLETED"
               ((org-agenda-overriding-header "Completed Projects")
                 (org-agenda-files org-agenda-files)))
             (todo "CANC"
               ((org-agenda-overriding-header "Cancelled Projects")
                 (org-agenda-files org-agenda-files)))))))
    ) ;; mifi/org-setup-agenda

#+end_src

***** The capture-templates function
:properties:
:custom_id: the-capture-templates-function
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/org-setup-capture-templates ()
    (setq org-capture-templates
      `(("t" "Tasks / Projects")
         
         ("tt" "Task" entry (file+olp (expand-file-name "OrgFiles/Tasks.org" user-emacs-directory) "Inbox")
           "* TODO %?\n  %U\n  %a\n        %i" :empty-lines 1)

         ("j" "Journal Entries")
         ("jj" "Journal" entry
           (file+olp+datetree (expand-file-name "OrgFiles/Journal.org" user-emacs-directory))
           "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
           ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
           :clock-in :clock-resume
           :empty-lines 1)
         ("jm" "Meeting" entry
           (file+olp+datetree (expand-file-name "OrgFiles/Journal.org" user-emacs-directory))
           "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
           :clock-in :clock-resume
           :empty-lines 1)

         ("w" "Workflows")
         ("we" "Checking Email" entry (file+olp+datetree
                                        (expand-file-name "OrgFiles/Joural.org" user-emacs-directory))
           "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

         ("m" "Metrics Capture")
         ("mw" "Weight" table-line (file+headline
                                     (expand-file-name "OrgFiles/Metrics.org" user-emacs-directory)
                                     "Weight")
           "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t))))

#+end_src

***** Org-Todos
:properties:
:custom_id: org-todos
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/org-setup-todos ()
    "Setup the org TODO keywords and colors."
    (setq org-todo-keywords
      '((type
          "TODO(t)" "IN-PROGRESS(i)" "WAITING(w)" 
          "RESEARCH(r)" "SOMEDAY(-)" "READING(e)"
          "CONTACT(c)" "|" "DONE(d)" "CANCELLED(C@)")))

    (setq org-todo-keyword-faces
      '(("TODO" :inherit (region org-todo) :foreground "gray70" :weight bold)
         ("WAITING" :inherit (org-todo region) :foreground "red1" :weight bold)
         ("IN-PROGRESS" :inherit (org-todo region) :foreground "gold1" :weight bold)
         ("RESEARCH" :inherit (org-todo region) :foreground "OliveDrab3" :weight bold)
         ("SOMEDAY" :inherit (org-todo region) :foreground "MediumPurple2" :weight bold)
         ("READING" :inherit (org-todo region) :foreground "DeepSkyBlue1" :weight bold)
         ("CONTACT" :inherit (org-todo region) :foreground "orange1" :weight bold)
         ("DONE" :inherit (region org-todo) :foreground "green1"   :weight bold)
         ("CANCELLED" :inherit (region org-todo) :foreground "green4"   :weight bold))))

#+end_src

***** User customized faces
:properties:
:custom_id: user-customized-faces
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (custom-theme-set-faces
    'user
    '(org-block ((t (:inherit fixed-pitch))))
    '(org-code ((t (:inherit (shadow fixed-pitch)))))
    '(org-document-info ((t (:foreground "dark orange"))))
    '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
    '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
    '(org-link ((t (:foreground "royal blue" :underline t))))
    '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
    '(org-property-value ((t (:inherit fixed-pitch))) t)
    '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
    '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
    '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
    '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))

#+end_src

*** The main 'Org' package
:properties:
:custom_id: the-main-org-package
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package org
    :preface
    (defun mifi/org-capture ()
      (interactive)
      (org-capture nil "jj"))
    (mifi/org-theme-override-values)
    (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
    :commands (org-capture org-agenda)
    :ensure t
    :defer t
    :hook (org-mode . mifi/org-mode-setup)
    :custom
    (org-directory (concat working-files-directory "OrgFiles"))
    (org-default-notes-file (concat working-files-directory "OrgFiles/notes.org"))
    (org-startup-indented t)
    (org-pretty-entities t)
    (org-use-sub-superscripts "{}")
    (org-hide-emphasis-markers t)
    (org-startup-with-inline-images t)
    (org-image-actual-width '(300))
    (org-hide-emphasis-markers nil)
    :bind ( ("C-c o" . mifi/org-capture)
            :map org-mode-map
            ("C-c e" . org-edit-src-code)
            ("C--" . org-mark-ring-goto) )
    :config
    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)
    (setq org-tag-alist
      '((:startgroup)
         ;; Put mutually exclusive tags here
         (:endgroup)
         ("@errand" . ?E)
         ("@home" . ?H)
         ("@work" . ?W)
         ("agenda" . ?a)
         ("planning" . ?p)
         ("publish" . ?P)
         ("batch" . ?b)
         ("note" . ?n)
         ("idea" . ?i)))
    ;; Configure custom agenda views
    (mifi/org-setup-agenda)
    (mifi/org-setup-capture-templates)
    (mifi/org-font-setup)
    (mifi/org-setup-todos)
    (yas-global-mode t))

#+end_src

*** Export Code
:properties:
:custom_id: :properties:
:custom_id: export-codes
:visibility: folded
:end:

:visibility: folded
:end:

To execute or export code in =org-mode= code blocks, you'll need to set up =org-babel-load-languages= for each language you'd like to use. [[https://orgmode.org/worg/org-contrib/babel/languages.html][Babel]] documents all of the languages that you can use with =org-babel=.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (with-eval-after-load 'org
    (org-babel-do-load-languages
      'org-babel-load-languages
      (seq-filter
        (lambda (pair)
          (locate-library (concat "ob-" (symbol-name (car pair)))))
        '((emacs-lisp . t)
           (ditaa . t)
           (dot . t)
           (emacs-lisp . t)
           (gnuplot . t)
           (haskell . t)
           (tuareg . t)
           (latex . t)
           (ledger . t)
           (octave . t)
           (plantuml . t)
           (python . t)
           (ruby . t)
           (screen . nil)
           (sh . t) ;; obsolete
           (shell . t)
           (sql . t)
           (sqlite . t))))
    (push '("conf-unix" . conf-unix) org-src-lang-modes))

#+end_src

*** Structure Templates
:properties:
:custom_id: structure-templates
:visibility: folded
:end:

Org Mode's structure templates feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and then press =TAB=. For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block. You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language as it is known by Org Babel.

This snippet adds a hook to =org-mode= buffers so that =mifi/org-babel-tangle-config= gets executed each time such a buffer gets saved. This function checks to see if the file being saved is the Emacs.org file you're looking at right now, and if so, automatically exports the configuration here to the associated output files.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (with-eval-after-load 'org
    ;; This is needed as of Org 9.2
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python")))

#+end_src

*** Org Olivetti mode
:properties:
:custom_id: org-olivetti-mode
:visibility: folded
:end:

A simple Emacs minor mode for a nice writing environment.

- Set a desired text body width to automatically resize window margins to keep the text comfortably in the middle of the window.
-  Text body width can be the number of characters (an integer), a fraction of the window width (a float between 0.0 and 1.0), or nil which uses the value of fill-column +2.
- Interactively change body width with:
    - olivetti-shrink C-c { { { ...
    - olivetti-expand C-c } } } ...
    - olivetti-set-width C-c |
- If olivetti-body-width is an integer, the text body width will scale with use of text-scale-mode, whereas if a fraction (float) then the text body width will remain at that fraction.
- Change the way the text body margins look with option olivetti-style: use margins, fringes, or both for a fancy "page" look.
- Customize olivetti-fringe face to affect only Olivetti buffers.
- Optionally remember the state of visual-line-mode on entry and recall its state on exit.

Olivetti keeps everything it does buffer-local, so you can write prose in one buffer and code in another, side-by-side in the same frame.

#+begin_src emacs-lisp :tangle no

  (use-package olivetti)

#+end_src

*** Org Modern
:properties:
:custom_id: org-modern
:visibility: folded
:end:

This package implements a modern style for your Org buffers using font locking and text properties. The package styles headlines, keywords, tables and source blocks. The styling is configurable, you can enable, disable or modify the style of each syntax element individually via the org-modern customization group.

Note that org-modern is a full replacement for both org-superstar and org-bullets. You can easily disable styling of certain elements, e.g., org-modern-timestamp, if you only want to use a subset of org-modern.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package org-modern
    :when (display-graphic-p)
    :after org
    :defer t
    :ensure t
    :hook (org-mode . org-modern-mode)
    :config
    ;; Add frame borders and window dividers
    (modify-all-frames-parameters
      '((right-divider-width . 40)
         (internal-border-width . 40)))
    (dolist (face '(window-divider
                     window-divider-first-pixel
                     window-divider-last-pixel))
      (face-spec-reset-face face)
      (set-face-foreground face (face-attribute 'default :background nil)))
    (set-face-background 'fringe (face-attribute 'default :background nil))
    (setq
      ;;   ;; Edit settings
      ;;   org-auto-align-tags nil
      ;;   org-tags-column 0
      org-catch-invisible-edits 'show-and-error
      org-special-ctrl-a/e t
      org-insert-heading-respect-content t
      org-modern-star 'replace

      ;;   ;; Org styling, hide markup etc.
      org-hide-emphasis-markers nil
      org-pretty-entities t
      org-ellipsis "…"

      ;; Agenda styling
      org-agenda-tags-column 0
      org-agenda-block-separator ?─
      org-agenda-time-grid
      '((daily today require-timed)
         (800 1000 1200 1400 1600 1800 2000)
         " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
      org-agenda-current-time-string
      "◀── now ─────────────────────────────────────────────────"
      )
    (mifi/reset-if-spacious-padding-mode)
    (global-org-modern-mode))

#+end_src

** Org Journal
:properties:
:custom_id: org-journal
:visibility: folded
:end:

=org-journal= maintains a set of files, depending on the value of =org-journal-file-type=, a file represents a day, week, month or year. When  =org-journal-file-type= is set to ~'daily~, each file represent a day. In case  =org-journal-file-type= is set to 'weekly, a file represents a week, etc. Convenient bindings allow the creation of journal records in the current daily, weekly, monthly or yearly file and search within all records or specified time intervals. All records can be browsed and searched from the Emacs Calendar for convenience. All entries in a specified TODO state will be carried over to the next day, see =org-journal-carryover-items=. Optionally, the journal entry can be encrypted, so can the file, see =org-journal-enable-encryption= and =org-journal-encrypt-journal=, respectively.

Every journal entry must have a =CREATED= property when using yearly, monthly and weekly journal files. This property is added by =org-journal-new-entry= automatically.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (when (equal custom-note-system 'custom-note-system-org-journal)
    (use-package org-journal
      :ensure t
      :after org
      :preface
      (defun org-journal-file-header-func (time)
        "Custom function to create journal header."
        (concat (pcase org-journal-file-type
                  (`daily "#+TITLE: Daily Journal\n#+STARTUP: showeverything")
                  (`weekly "#+TITLE: Weekly Journal\n#+STARTUP: folded")
                  (`monthly "#+TITLE: Monthly Journal\n#+STARTUP: folded")
                  (`yearly "#+TITLE: Yearly Journal\n#+STARTUP: folded"))))
      :init
      (setq org-journal-prefix-key "C-c j ")
      (setq org-journal-dir (expand-file-name "journal" working-files-directory ))
      (setq org-journal-date-format "%A, %d %B %Y")
      (setq org-journal-file-header 'org-journal-file-header-func)  
      :bind (("C-c j n" . org-journal-new-entry)
              ("C-c j f" . find-file-other-window)
              ("C-c j s" . org-journal-schedule-view) )
      :config
      (message "=== Configured org-journal."))
  )
#+end_src

** Org Roam
:properties:
:custom_id: org-roam
:visibility: folded
:end:

Org Mode is known to be a great tool not just for writing and personal notes but also TODO lists, project planning, time tracking, and more. Once you start to become really invested in Org Mode you’ll eventually have to come up with a system for managing your Org files so that it’s easy to store and find the information you need.

Org Roam is an extension to Org Mode which solves a couple of the biggest problems that I’ve personally had when using Org for personal notes:

- How many Org files do I need?
- How do I decide where to put things in my Org files?

Org Roam solves these problems by making it easy to create topic-focused Org Files and link them together so that you can treat the information as nodes in a network rather than as hierarchical documents. You can think of it like a personal wiki!

*** Main org-roam configuration
:properties:
:custom_id: main-org-roam-configuration
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package emacsql :ensure t)

  (use-package org-roam
    :after (emacsql org)
    :when (equal custom-note-system 'custom-note-system-org-roam)
    :defer t
    :ensure t
    :demand t
    ;; :ensure ( :package "org-roam" :source "MELPA" :protocol https :inherit t :depth 1
    ;;           :fetcher github :repo "org-roam/org-roam" :files (:defaults "extensions/*"))
    :init
    (setq org-roam-v2-ack t)
    (which-key-add-key-based-replacements "C-c n" "org-roam")
    :custom
    (org-roam-directory (expand-file-name "RoamNotes" custom-docs-directory))
    (org-roam-completion-everywhere t)
    :bind (("C-c n l" . org-roam-buffer-toggle)
            ("C-c n f" . org-roam-node-find)
            ("C-c n i" . org-roam-node-insert)
            ("C-c n I" . org-roam-node-insert-immediate)
            ("C-c n p" . mifi/org-roam-find-project)
            ("C-c n t" . mifi/org-roam-capture-task)
            ("C-c n b" . mifi/org-roam-capture-inbox)
            :map org-mode-map
            ("C-M-i" . completion-at-point))
    :config
    (mifi/org-roam-set-which-key-replacements)
    (mifi/org-roam-refresh-agenda-list)
    (add-to-list 'org-after-todo-state-change-hook
      (lambda ()
        (when (equal org-state "DONE")
          (mifi/org-roam-copy-todo-to-today))))
    (org-roam-db-autosync-mode))

  (defun mifi/org-roam-set-which-key-replacements ()
    (interactive)
    (which-key-add-key-based-replacements
      "C-c n l" "toggle-buffer"
      "C-c n f" "find-node"
      "C-c n i" "insert-node"
      "C-c n I" "insert-node-immediate"
      "C-c n p" "find-project"
      "C-c n t" "capture-task"
      "C-c n b" "capture-inbox"))

  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (push arg args))
           (org-roam-capture-templates
             (list (append (car org-roam-capture-templates)
                     '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

  #+end_src

*** Org-roam dailies
:properties:
:custom_id: org-roam-dailies
:visibility: folded
:end:

#+begin_src emacs-lisp

  (when (equal custom-note-system 'custom-note-system-org-roam)
    (use-package org-roam-dailies
      :ensure t
      :after org-roam
      :init
      (which-key-add-key-based-replacements "C-c n d" "org-roam-dailies")
      :bind-keymap
      ("C-c n d" . org-roam-dailies-map)
      :bind (:map org-roam-dailies-map
              ("." . org-roam-dailies-goto-date)
              ("Y" . org-roam-dailies-capture-yesterday)
              ("T" . org-roam-dailies-capture-tomorrow))
      :config
      (which-key-add-key-based-replacements
        "C-c n d" "org-roam-dailies"
        "C-c n d ." "goto-date"
        "C-c n d Y" "capture-yesterday"
        "C-c n d T" "capture-tomorrow"
        "C-c n d n" "capture-today"
        "C-c n d d" "goto-today"
        "C-c n d t" "goto-tomorrow"
        "C-c n d y" "goto-yesterday")))

#+end_src

*** Org Agenda from Roam Notes
:properties:
:custom_id: org-agenda-from-roam-notes
:visibility: folded
:end:

One of the most useful features of Org Mode is the agenda view. You can actually use your Org Roam notes as the source for this view!

Typically you won’t want to pull in all of your Org Roam notes, so we’ll only use the notes with a specific tag like Project.

Here is a snippet that will find all the notes with a specific tag and then set your org-agenda-list with the corresponding note files.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; The buffer you put this code in must have lexical-binding set to t!
  ;; See the final configuration at the end for more details.

  (defun mifi/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun mifi/org-roam-list-notes-by-tag (tag-name)
      (mapcar #'org-roam-node-file
          (seq-filter
              (mifi/org-roam-filter-by-tag tag-name)
              (org-roam-node-list))))

  (defun mifi/org-roam-refresh-agenda-list ()
      (interactive)
      (setq org-agenda-files (mifi/org-roam-list-notes-by-tag "Project")))

  ;; Build the agenda list the first time for the session

#+end_src

*** Selecting from a list of notes
:properties:
:custom_id: selecting-from-a-list-of-notes
:visibility: folded
:end:

The org-roam-node-find function gives us the ability to filter the list of notes that get displayed for selection. We can define our own function that shows a selection list for notes that have a specific tag like Project which we talked about before. This can be useful to set up a keybinding to quickly select from a specific set of notes! One added benefit is that we can override the set of capture templates that get used when a new note gets created. This means that we can automatically create a new note with our project capture template if the note doesn’t already exist!

#+begin_src emacs-lisp
  ;;; ##########################################################################
  
  (defun mifi/org-roam-project-finalize-hook ()
      "Adds the captured project file to `org-agenda-files' if the
  capture was not aborted."
      ;; Remove the hook since it was added temporarily
      (remove-hook 'org-capture-after-finalize-hook #'mifi/org-roam-project-finalize-hook)

      ;; Add project file to the agenda list if the capture was confirmed
      (unless org-note-abort
          (with-current-buffer (org-capture-get :buffer)
              (add-to-list 'org-agenda-files (buffer-file-name)))))

  (defun mifi/org-roam-find-project ()
      (interactive)
      ;; Add the project file to the agenda after capture is finished
      (add-hook 'org-capture-after-finalize-hook #'mifi/org-roam-project-finalize-hook)

      ;; Select a project file to open, creating it if necessary
      (org-roam-node-find
          nil
          nil
          (mifi/org-roam-filter-by-tag "Project")
          :templates
          '(("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
                :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
                :unnarrowed t))))

  (global-set-key (kbd "C-c n p") #'mifi/org-roam-find-project)
#+end_src

*** Keep an inbox of notes and tasks
:properties:
:custom_id: keep-an-inbox-of-notes-and-tasks
:visibility: folded
:end:

If you want to quickly capture new notes and tasks with a single keybinding into a place that you can review later, we can use org-roam-capture- to capture to a single-specific file like Inbox.org!

Even though this file won’t have the timestamped filename, it will still be treated as a node in your Org Roam notes.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  
  (defun mifi/org-roam-capture-inbox ()
      (interactive)
      (org-roam-capture- :node (org-roam-node-create)
          :templates '(("i" "inbox" plain "* %?"
                           :if-new (file+head "Inbox.org" "#+title: Inbox\n")))))

#+end_src

*** Capture a task
:properties:
:custom_id: capture-a-task
:visibility: folded
:end:

If you’ve set up project note files like we mentioned earlier, you can set up a capture template that allows you to quickly capture tasks for any project.

Much like the example before, we can either select a project that exists or automatically create a project note when it doesn’t exist yet.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  
  (defun mifi/org-roam-capture-task ()
      (interactive)
      ;; Add the project file to the agenda after capture is finished
      (add-hook 'org-capture-after-finalize-hook #'mifi/org-roam-project-finalize-hook)

      ;; Capture the new task, creating the project file if necessary
      (org-roam-capture- :node (org-roam-node-read nil
                                   (mifi/org-roam-filter-by-tag "Project"))
          :templates '(("p" "project" plain "** TODO %?"
                           :if-new
                           (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                               "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                               ("Tasks"))))))
#+end_src

*** Org-roam Todo
:properties:
:custom_id: org-roam-todo
:visibility: folded
:end:

The following snippet sets up a hook for all Org task state changes and then copies the completed (DONE) entry to today’s note file

#+begin_src emacs-lisp
  ;;; ##########################################################################
  
  (defun mifi/org-roam-copy-todo-to-today ()
      (interactive)
      (let ((org-refile-keep t) ;; Set this to nil to delete the original!
               (org-roam-dailies-capture-templates
                   '(("t" "tasks" entry "%?"
                         :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" ("Tasks")))))
               (org-after-refile-insert-hook #'save-buffer)
               today-file pos)
          (save-window-excursion
              (org-roam-dailies--capture (current-time) t)
              (setq today-file (buffer-file-name))
              (setq pos (point)))

          ;; Only refile if the target file is different than the current file
          (unless (equal (file-truename today-file)
                      (file-truename (buffer-file-name)))
              (org-refile nil nil (list "Tasks" today-file nil pos)))))

#+end_src

** Denote
:properties:
:custom_id: denote
:visibility: folded
:end:

Denote aims to be a simple-to-use, focused-in-scope, and effective note-taking and file-naming tool for Emacs.

Denote is based on the idea that files should follow a predictable and descriptive file-naming scheme. The file name must offer a clear indication of what the contents are about, without reference to any other metadata. Denote basically streamlines the creation of such files or file names while providing facilities to link between them (where those files are editable).

Denote’s file-naming scheme is not limited to “notes”. It can be used for all types of file, including those that are not editable in Emacs, such as videos. Naming files in a consistent way makes their filtering and retrieval considerably easier. Denote provides relevant facilities to rename files, regardless of file type.

*** Denote Keymap
:properties:
:custom_id: denote-keymap
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/define-denote-keymap ()
    (interactive)
    ;; Denote DOES NOT define any key bindings.  This is for the user to
    ;; decide.
    ;; Just in case, unbind some org-roam keys so it doesn't get loaded
    ;; unintentionally. These are some that show up in the which-key menu:
    (unbind-key "C-c n f")
    (unbind-key "C-c n l")
    (unbind-key "C-c n p")
    (let ((map global-map))
      (define-key map (kbd "C-c n n") #'denote)
      (define-key map (kbd "C-c n c") #'denote-region) ; "contents" mnemonic
      (define-key map (kbd "C-c n N") #'denote-type)
      (define-key map (kbd "C-c n o") #'denote-open-or-create)
      (define-key map (kbd "C-c n d") #'denote-date)
      (define-key map (kbd "C-c n z") #'denote-signature) ; "zettelkasten" mnemonic
      (define-key map (kbd "C-c n s") #'denote-subdirectory)
      (define-key map (kbd "C-c n t") #'denote-template)
      ;; If you intend to use Denote with a variety of file types, it is
      ;; easier to bind the link-related commands to the `global-map', as
      ;; shown here.  Otherwise follow the same pattern for `org-mode-map',
      ;; `markdown-mode-map', and/or `text-mode-map'.
      (define-key map (kbd "C-c n i") #'denote-link) ; "insert" mnemonic
      (define-key map (kbd "C-c n I") #'denote-add-links)
      (define-key map (kbd "C-c n b") #'denote-backlinks)
      (define-key map (kbd "C-c n f f") #'denote-find-link)
      (define-key map (kbd "C-c n f b") #'denote-find-backlink)
      ;; Note that `denote-rename-file' can work from any context, not just
      ;; Dired bufffers.  That is why we bind it here to the `global-map'.
      (define-key map (kbd "C-c n r") #'denote-rename-file)
      (define-key map (kbd "C-c n R") #'denote-rename-file-using-front-matter))

    ;; Key bindings specifically for Dired.
    (let ((map dired-mode-map))
      (define-key map (kbd "C-c C-d C-i") #'denote-link-dired-marked-notes)
      (define-key map (kbd "C-c C-d C-r") #'denote-dired-rename-files)
      (define-key map (kbd "C-c C-d C-k") #'denote-dired-rename-marked-files-with-keywords)
      (define-key map (kbd "C-c C-d C-R") #'denote-dired-rename-marked-files-using-front-matter))

    (when (bound-and-true-p which-key-mode)
      (which-key-add-key-based-replacements "C-c n f" "denote-find")))

#+end_src

*** Denote Configuration
:properties:
:custom_id: denote-configuration
:visibility: folded
:end:

#+begin_src  emacs-lisp
  ;;; ##########################################################################

  (use-package denote
    :when (equal custom-note-system 'custom-note-system-denote)
    ;; :after which-key dired
    :ensure t
    :custom
    (denote-directory (expand-file-name "notes" user-emacs-directory))
    (denote-save-buffers nil)
    (denote-known-keywords '("Python" "OCaml" "Journal" "Wildlife" "Photography"))
    (denote-infer-keywords t)
    (denote-sort-keywords t)
    (denote-file-type nil) ; Org is the default, set others here
    (denote-prompts '(title keywords))
    (denote-excluded-directories-regexp nil)
    (denote-excluded-keywords-regexp nil)
    (denote-rename-confirmations '(rewrite-front-matter modify-file-name))
    (denote-date-prompt-use-org-read-date t)
    (denote-date-format nil) ; read doc string
    (denote-backlinks-show-context t)
    (denote-dired-directories
      (list denote-directory
        (thread-last denote-directory (expand-file-name "attachments"))
        (expand-file-name "books" user-emacs-directory)))
    :config
    ;; (add-hook 'find-file-hook #'denote-link-buttonize-buffer)
    (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)
    (denote-rename-buffer-mode 1)
    (mifi/define-denote-keymap) ;; Define the keymap for Denote.
    (with-eval-after-load 'org-capture
      (setq denote-org-capture-specifiers "%l\n%i\n%?")
      (add-to-list 'org-capture-templates
        '("n" "New note (with denote.el)" plain
           (file denote-last-path)
           #'denote-org-capture
           :no-save t
           :immediate-finish nil
           :kill-buffer t
           :jump-to-captured t)))

    (add-hook 'context-menu-functions #'denote-context-menu))

#+end_src

** Projectile
:properties:
:custom_id: projectile
:visibility: folded
:end:

[[https://projectile.mx/][Projectile]] is a project management library for Emacs which makes it a lot easier to navigate around code projects for various languages. Many packages integrate with Projectile so it's a good idea to have it installed even if you don't use its commands directly.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package projectile
    :when (equal custom-project-handler 'custom-project-projectile)
    :delight Proj
    :ensure t
    :config (projectile-mode)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    (when (file-directory-p custom-developer-root)
      (setq projectile-project-search-path '(custom-developer-root)))
    (setq projectile-switch-project-action #'projectile-dired))

  (when (equal completion-handler 'comphand-ivy)
    (use-package counsel-projectile
      :when (equal custom-project-handler 'custom-project-projectile)
      :ensure t
      :after projectile
      :config
      (setq projectile-completion-system 'ivy)
      (counsel-projectile-mode)))

#+end_src

** Project.el
:properties:
:custom_id: project-el
:visibility: folded
:end:

This is the default built-in project system. For those not needing the full-featured ~projectile~, this package is g
enerally enough.

#+;;#+INCLUDE: "org-incl/project.el" src emacs-lisp

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun project-find-go-module (dir)
    (when-let ((root (locate-dominating-file dir "go.mod")))
      (cons 'go-module root)))

  (use-package project
    :when (equal custom-project-handler 'custom-project-project-el)
    :config
    (setq project-vc-extra-root-markers '(".project.el" ".projectile" )))
    ;; (when (featurep 'go-mode
    ;; (cl-defmethod project-root ((project (head go-module)))
    ;;   (cdr project))
    ;; (add-hook 'project-find-functions #'project-find-go-module))

#+end_src

** Gnus
:properties:
:custom_id: gnus
:visibility: folded
:end:

#+begin_src emacs-lisp

  (use-package gnus
    :disabled
    :ensure nil
    :defer t
    :config
    (setq user-full-name '"MrCairo")
    (setq user-mail-address '"mr.cairo@invalidname.com")
    (setq gnus-select-method '(nntp "news.eternal-september.org")))

#+end_src

* Integrated Development Environment
:properties:
:custom_id: integrated-development-environment
:visibility: folded
:end:

I like to keep several different IDE-like packages since each has it's advantages and I like to switch between them on occasion.

- context-sensitive code completion
- jump to definitions
- find references
- view documentation
- virtual environment
- eldoc mode
- File Managers/Directory Trees
- Buffer Tabs
  
** Dashboard
:properties:
:custom_id: dashboard
:visibility: folded
:end:

Dashboard is an extensible Emacs startup screen showing you what’s most important.

*** Value of dashboard-startup-banner can be:
**** =nil= to display no banner
**** ='official= which displays the official emacs logo
**** ='logo= which displays an alternative emacs logo
**** =1, 2 or 3= which displays one of the text banners
**** ~"path/to/your/image.gif"~,
~"path/to/your/image.png"~ or
~"path/to/your/text.txt"~  which displays whatever gif/image/text you would prefer
**** a cons of '("path/to/your/image.png" . "path/to/your/text.txt")

*** Dashboard Setup
:properties:
:custom_id: dashboard-setup
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package dashboard
    :ensure t
    :defer t
    :custom
    (dashboard-items '( (recents   . 12)
                        (bookmarks . 5)
                        (projects  . 5)
                        (agenda    . 5)))
    (dashboard-center-content t)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)  
    (dashboard-footer-messages '("Greetings Program!"))
    (dashboard-banner-logo-title "Welcome to Emacs!")
    :commands dashboard-open
    :bind ("M-RET d" . dashboard-open)
    :config
    ;; (setq initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name)))
    (add-hook 'after-init-hook #'dashboard-insert-startupify-lists)
    (add-hook 'after-init-hook #'dashboard-initialize)
    (when (equal custom-project-handler 'custom-project-projectile)
      (setq dashboard-projects-backend 'projectile))
    (setq dashboard-startup-banner (expand-file-name "Emacs-modern-is-sexy-v1.png" user-emacs-directory))
    (dashboard-setup-startup-hook))

#+end_src

** Neotree
:properties:
:custom_id: neotree
:visibility: folded
:end:

A tree plugin like NerdTree for Vim

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package neotree
    :when enable-neotree
    :config
    (global-set-key [f8] 'neotree-toggle)
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow)))

#+end_src

** Centaur Tabs
:properties:
:custom_id: centaur-tabs
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; Enable tabs for each buffer

  (use-package centaur-tabs
    :when enable-centaur-tabs
    :custom
    ;; Set the style to rounded with icons (setq centaur-tabs-style "bar")
    (centaur-tabs-style "bar")
    (centaur-tabs-set-icons t)
    (centaur-tabs-set-modified-marker t)
    :bind (("C-c <" . centaur-tabs-backward)
            ("C-c >" . centaur-tabs-forward))
    :config ;; Enable centaur-tabs
    (centaur-tabs-mode t))

#+end_src

** Code Completion and Handling

*** EGlot
:properties:
:custom_id: eglot
:visibility: folded
:end:

<<<Eglot>>> is the Emacs client for the Language Server Protocol (LSP). Eglot provides infrastructure and a set of commands for enriching the source code editing capabilities of Emacs via LSP. Eglot itself is completely language-agnostic, but it can support any programming language for which there is a language server and an Emacs major mode.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Emacs Polyglot is the Emacs LSP client that stays out of your way:

  (defvar mifi/clangd-path (executable-find "clangd")
    "Clangd executable path.")

  (defun mifi/projectile-proj-find-function (dir)
    "Find the project `DIR' function for Projectile.
    Thanks @wyuenho on GitHub"
    (let ((root (projectile-project-root dir)))
      (and root (cons 'transient root))))

  (use-package track-changes
    :ensure t
    :defer t
    :config
    (unless theme-did-load
      (mifi/load-theme-from-selector)))

#+end_src

**** Eglot Setup
:properties:
:custom_id: eglot-setup
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; Consider doing an "M-x eglot-upgrade-eglot" to ensure that you have the most
  ;; current eglot (yes, even though it's a built in package).

  (use-package eglot
    :when (equal custom-ide 'custom-ide-eglot)
    :after lsp-mode
    :ensure nil
    :defer t
    :hook
    (lisp-mode . eglot-ensure)
    ;; (tuareg-mode . eglot-ensure)
    :config
    (flymake-mode 0)
    (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
    ;; Eldoc/Eglot will try to load/unload a theme which can cause issues with our
    ;; theme loading mechanism. Our theme could fail to load because of this.  So,
    ;; to get our themes loading properly, load it here if not already loaded.
    (unless theme-did-load
      (mifi/load-theme-from-selector))
    (add-to-list 'eglot-stay-out-of 'flymake)
    (if (featurep 'company) ;; Company should be loaded.
      (bind-keys :map eglot-mode-map
        ("<tab>" . company-indent-or-complete-common))
      (message "Eglot: Company was expected to be loaded but wasn't.")))

#+end_src

*** Language Server Protocol (lsp-mode)
:properties:
:custom_id: language-server-protocol-lsp-mode
:visibility: folded
:end:

Client for Language Server Protocol (v3.14). lsp-mode aims to provide IDE-like experience by providing optional integration with the most popular Emacs packages like company, flycheck and projectile.

❤ Community Driven
💎 Fully featured - supports all features in Language Server Protocol v3.14.
🚀 Fast - see performance section.
🌟 Flexible - choose between full-blown IDE with flashy UI or minimal distraction free.
⚙ Easy to configure - works out of the box and automatically upgrades if additional packages are present.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Language Server Protocol

  ;; (when (or (equal custom-ide 'custom-ide-lsp) (equal custom-ide 'custom-ide-eglot))
  ;;   (eval-when-compile (defvar lsp-enable-which-key-integration)))

  (use-package lsp-mode
    :when (or (equal custom-ide 'custom-ide-lsp) (equal custom-ide 'custom-ide-eglot))
    :commands (lsp lsp-deferred)
    :ensure t
    :hook (lsp-mode . mifi/lsp-mode-setup)
    :init
    (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
    :config
    (if (featurep 'company)
      (bind-keys :map lsp-mode-map
        ("<tab>" . company-indent-or-complete-common)))
    (mifi/define-rust-lsp-values)
    (lsp-enable-which-key-integration t))

#+end_src

**** LSP UI
:properties:
:custom_id: lsp-ui
:visibility: folded
:end:

This package contains all the higher level UI modules of lsp-mode, like flycheck support and code lenses. By default, lsp-mode automatically activates lsp-ui unless lsp-auto-configure is set to nil. You only have to put (use-package lsp-ui) in your config and the package will work out of the box.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package lsp-ui
    :when (or (equal custom-ide 'custom-ide-lsp) (equal custom-ide 'custom-ide-eglot))
    :after lsp
    :ensure t
    :custom
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-sideline-delay 0.5)
    (lsp-ui-sideline-ignore-duplicates t)
    (lsp-ui-peek-always-show t)
    (lsp-ui-doc-delay 3)
    (lsp-ui-doc-position 'bottom)
    ;;(lsp-ui-doc-position 'top)
    (lsp-ui-doc-alignment 'frame)
    (lsp-ui-doc-header nil)
    (lsp-ui-doc-show-with-cursor t)
    (lsp-ui-doc-include-signature t)
    (lsp-ui-doc-use-childframe t)
    :commands lsp-ui-mode
    :bind (:map lsp-ui-mode-map
            ("C-c l d" . lsp-ui-doc-focus-frame))
    :hook (lsp-mode . lsp-ui-mode))

#+end_src

**** LSP Treemacs integration
:properties:
:custom_id: lsp-treemacs-integration
:visibility: folded
:end:

Integration between lsp-mode and treemacs and implementation of treeview controls using treemacs as a tree renderer.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; To enable bidirectional synchronization of lsp workspace folders and
  ;;; treemacs projects set lsp-treemacs-sync-mode to 1.

  (use-package lsp-treemacs
    :when (or (equal custom-ide 'custom-ide-lsp) (equal custom-ide 'custom-ide-eglot))
    :after lsp treemacs
    :bind (:map prog-mode-map
            ("C-c t" . treemacs))
    :config
    (lsp-treemacs-sync-mode 1))

  (use-package lsp-ivy
    :when (and (or (equal custom-ide 'custom-ide-lsp) (equal custom-ide 'custom-ide-eglot))
            (equal completion-handler 'comphand-ivy))
    :after lsp ivy)
  
#+end_src

**** LSP mode hook function
:properties:
:custom_id: lsp-mode-hook-functions
:visibility: folded
:end:

This function is called from the lsp-mode-hook when enering or leaving LSP mode.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; LSP mode setup hook

  (defun mifi/lsp-mode-setup ()
    "Custom LSP setup function."
    (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
    (when (or (equal custom-ide 'custom-ide-lsp) (equal custom-ide 'custom-ide-eglot))
      (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
      (setq lsp-clangd-binary-path "/usr/bin/clangd")'
      (lsp-headerline-breadcrumb-mode)))

#+end_src

**** LSP configuration for Rust
:properties:
:custom_id: lsp-configuration-for-rust
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/define-rust-lsp-values ()
    (setq-default lsp-rust-analyzer-cargo-watch-command "clippy")
    (setq-default lsp-eldoc-render-all t)
    (setq-default lsp-idle-delay 0.6)
    ;; enable / disable the hints as you prefer:
    (setq-default lsp-inlay-hint-enable t)
    ;; These are optional configurations. See
    ;; https://emacs-lsp.github.io/lsp-mode/page/lsp-rust-analyzer/#lsp-rust-analyzer-display-chaining-hints
    ;; for a full list
    (setq-default lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial")
    (setq-default lsp-rust-analyzer-display-chaining-hints t)
    (setq-default lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil)
    (setq-default lsp-rust-analyzer-display-closure-return-type-hints t)
    (setq-default lsp-rust-analyzer-display-parameter-hints nil)
    (setq-default lsp-rust-analyzer-display-reborrow-hints nil))

#+end_src

*** LSP Bridge :deprecation_warning:
:properties:
:custom_id: lsp-bridge
:visibility: folded
:end:

*Note:* This is a stand-alone package. This doesn't require eglot/lsp-mode/elpy, etc.

The goal of lsp-bridge is use multi-thread technology to implement the fastest LSP client in the Emacs ecosystem.

Advantages of lsp-bridge:

+ Blazingly fast: Offload LSP request and data analysis to an external process, preventing Emacs from getting stuck due to delays or large data triggering garbage collection.

+ Remote Completion: Built-in support for remote server code completion, with various login methods such as passwords and public keys, supports tramp protocol and jump server

+ Out of the box: Ready to use immediately after installation, no additional configuration required, no need to tweak with completion frontend, completion backend and multi-backend mix

+ Multi-server fusion: A simple JSON is all you need to combine multiple LSP Servers into one file that provides services for example Python which offers code completion with Pyright and diagnostic and formatting capabilities with Ruff

+ Flexible Customization: Customizing LSP server options is as simple as using a JSON file, allowing different projects to have different JSON configurations with just a few lines of rules

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;;
  ;;; Make sure that the following are part of the Python environment:
  ;;; pip3 install epc orjson sexpdata six setuptools paramiko rapidfuzz watchdog
  ;;;
  (use-package lsp-bridge
    :disabled
    :when (equal custom-ide 'custom-ide-lsp-bridge)
    ;; :ensure ( :host github :repo "manateelazycat/lsp-bridge"
    ;;           :files (:defaults "*.el" "*.py" "acm" "core" "langserver"
    ;;                    "multiserver" "resources") :build (:not compile))
    :custom
    (lsp-bridge-python-lsp-server "pylsp")
    :config
    (global-lsp-bridge-mode))

#+end_src

*** ELPY                                                             :Python:
:properties:
:custom_id: elpy
:visibility: folded
:end:

Elpy is an Emacs package to bring powerful Python editing to Emacs. It combines and configures a number of other packages, both written in Emacs Lisp as well as Python. Elpy is fully documented at [[https://elpy.readthedocs.io/en/latest/index.html][read the docs]].

Once installed, Elpy will automatically provide code completion, syntax error highlighting and code hinting (in the modeline) for python files. Elpy offers a lot of features, but the following keybindings should be enough to get started:

C-c C-c evaluates the current python script (or region if something is selected) in an interactive python shell. The python shell is automatically displayed aside of your script. C-RET evaluates the current statement (current line plus the following nested lines). C-c C-z switches between your script and the interactive shell. C-c C-d displays documentation for the thing under cursor. The documentation will pop in a different buffer, that can be closed with q.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package elpy
    :when (equal custom-ide 'custom-ide-elpy)
    :after python which-key
    :ensure t
    :custom
    (elpy-rpc-python-command "python3")
    (display-fill-column-indicator-mode 1)
    (highlight-indentation-mode nil)
    :bind (:map python-mode-map
            ("C-c g a" . elpy-goto-assignment)
            ("C-c g o" . elpy-goto-definition-other-window)
            ("C-c g g" . elpy-goto-definition)
            ("C-c g ?" . elpy-doc))
    :config
    ;; (use-package flycheck
    ;;   :when (equal custom-ide 'custom-ide-elpy)
    ;;   :after elpy
    ;;   :defer t
    ;;   :delight "fc"
    ;;   ;;:ensure (:host github :repo "flycheck/flycheck")
    ;;   :hook (elpy-mode . flycheck-mode))
    (which-key-add-key-based-replacements
      "C-c g a" "goto-assignment"
      "C-c g o" "find-defitions-other-window"
      "C-c g g" "find-defitions"
      "C-c g ?" "eldoc-definition")
    (if (featurep 'company)
      (bind-keys :map elpy-mode-map
        ("<tab>" . company-indent-or-complete-common)))
    (elpy-enable))

  (use-package jedi
    :ensure t
    :after python elpy)

#+end_src

* Language Integration
:properties:
:custom_id: language-integration
:visibility: folded
:end:

** Language Support Packages
:properties:
:custom_id: language-support-packages
:visibility: folded
:end:

*** Flycheck
:properties:
:custom_id: flycheck
:visibility: folded
:end:

This is more support for a language rather than a langage itself

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package flycheck
    ;;:unless (equal custom-ide 'custom-ide-elpy)
    :ensure t
    :delight 'fc
    :defer t
    ;;:ensure (:host github :repo "flycheck/flycheck")
    :config
    (eval-after-load 'flycheck
      '(flycheck-package-setup))
    (global-flycheck-mode))

  (use-package flycheck-package
    :ensure t
    :after flycheck)

#+end_src

*** Tree-sitter
:properties:
:custom_id: tree-sitter
:visibility: folded
:end:

Tree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source file and efficiently update the syntax tree as the source file is edited. Tree-sitter aims to be:

- General enough to parse any programming language
- Fast enough to parse on every keystroke in a text editor
- Robust enough to provide useful results even in the presence of syntax errors
- Dependency-free so that the runtime library (which is written in pure C) can be embedded in any application

**** Tree-sitter-support functions
:properties:
:custom_id: tree-sitter-support-functions
:visibility: folded
:end:

Some functions that are used during the initialization of tree-sitter.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/tree-sitter-setup ()
    (tree-sitter-hl-mode t))

  (defun lsp-go-install-save-hooks ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))

#+end_src

**** The main Tree-sitter setup
:properties:
:custom_id: the-main-tree-sitter-setup
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package tree-sitter
    :defer t
    :after (:any python python-mode lisp-mode merlin-mode tuareg)
    :ensure t
    :config
    ;; Activate tree-sitter globally (minor mode registered on every buffer)
    (global-tree-sitter-mode)
    (cond
      ((equal custom-ide 'custom-ide-eglot)
        (add-hook 'go-mode-hook 'eglot-ensure))
      ((equal custom-ide 'custom-ide-lsp)
        (add-hook 'go-mode-hook 'lsp-deferred)))
    :hook
    (tree-sitter-after-on . mifi/tree-sitter-setup)
    (typescript-mode . lsp-deferred)
    ;; (c-mode . lsp-deferred)
    ;; (c++-mode . lsp-deferred)
    (before-save . lsp-go-install-save-hooks)
    (js2-mode . lsp-deferred))

  (use-package tree-sitter-langs
    :ensure t
    :after tree-sitter)

#+end_src

**** Treesit-auto
:properties:
:custom_id: treesit-auto
:visibility: folded
:end:

If a tree-sitter grammer is available and installed, use it instead of the corresponding default mode. Conversely, when a tree-sitter grammar is not available and a fallback major mode is available/specified, use it instead.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package treesit-auto
    :ensure t
    :demand t
    :config
    (global-treesit-auto-mode))

#+end_src

*** Magit
:properties:
:custom_id: magit
:visibility: folded
:end:

[[https://magit.vc/][Magit]] is the one of the best Git interface implementations . Common Git operations are easy to execute quickly using Magit's command panel system.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package transient :ensure t)
  (use-package magit
    :after transient
    :ensure t :defer t
    :commands magit-status)

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started

  (use-package forge :after magit :defer t :ensure t)
  (use-package treemacs-magit :defer t :after treemacs magit)

#+end_src

** Python
:properties:
:custom_id: python
:visibility: folded
:end:

<<<Python>>> is an interpreted, interactive, object-oriented programming language. It incorporates modules, exceptions, dynamic typing, very high level dynamic data types, and classes. It supports multiple programming paradigms beyond object-oriented programming, such as procedural and functional programming. Python combines remarkable power with very clear syntax. It has interfaces to many system calls and libraries, as well as to various window systems, and is extensible in C or C++. It is also usable as an extension language for applications that need a programmable interface. Finally, Python is portable: it runs on many Unix variants including Linux and macOS, and on Windows.

This is the Python setup for development under Emacs.

#+begin_src emacs-lisp

  (use-package mifi-setup-python
    :when enable-python
    :ensure nil)

#+end_src

*Important*

Before any work can begin in python, make sure that the right packages are installed.

#+begin_src shell :results output silent :tangle no

  pip3 install --upgrade pip
  pip3 install "python-lsp-server[all]"
  pip3 install debugpy

#+end_src

In addition to that, it is important that =autopep8=, which is a script, can reach python or python3. For my configuration, =autopep8= looks for python this like this:

    ~#!/Library/Frameworks/Python.framework/Versions/Current/bin/python3~

*Note:* If this python path doesn't exist, you will see the very annoying message:

     ~file-missing "Doing vfork" "No such file or directory"~

** OCaml
:properties:
:custom_id: ocaml
:visibility: folded
:end:

An industrial-strength functional programming language with an emphasis on expressiveness and safety

OCaml mixes power and pragmatism in a way that makes it ideal for building complex software systems. What makes OCaml special is that it occupies a sweet spot in programming language design. It provides a combination of efficiency, expressiveness, and practicality that is matched by no other language. That is in large part because OCaml is an elegant combination of language features that have been developed over the last 40 years. These include:

+ Generational garbage collection for automatic memory management.
+ First-class functions that can be passed around like ordinary values, as seen in JavaScript, Common Lisp, and C#.
+ Static type-checking to increase performance and reduce the number of runtime errors, as found in Java and C#.
+ Parametric polymorphism, which enables the construction of abstractions that work across different data types, similar to generics in Java and C# and templates in C++.
+ Good support for immutable programming, i.e., programming without making destructive updates to data structures. This is present in traditional functional languages like Scheme, and it's also found in distributed, big-data frameworks like Hadoop.
+ Type inference, so you don’t need to annotate every function parameter, return type, and variable. Instead, types are inferred based on how a value is used. Available in a limited form in C# with implicitly-typed local variables and in C++11 with its auto keyword.
+ Algebraic data types and pattern matching to define and manipulate complex data structures, also available in Scala and F#.

*** HOWTO Install OPAM if necessary
:properties:
:custom_id: howto-install-opam-if-necessary
:visibility: folded
:end:

The OCaml package manager manually. This will fetch the latest version.

#+begin_src bash

  bash -c "sh <(curl -fsSL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh) --version 2.2.0"

#+end_src

This is an easy way to install =opam= using ~brew~ but it may not be the most current. The shell script above is the best way to on non-windows systems.

#+begin_src emacs-lisp

  (use-package mifi-setup-ocaml
    :ensure nil
    :when enable-ocaml)
  
#+end_src

** JavaScript based languages
:properties:
:custom_id: javascript-based-languages
:visibility: folded
:end:

*** Typescript
:properties:
:custom_id: typescript
:visibility: folded
:end:

This is a basic configuration for the TypeScript language so that =.ts= files activate =typescript-ts-mode= when opened. We're also adding a hook to =typescript-mode-hook= to call =lsp-deferred= so that we activate =lsp-mode= to get LSP features every time we edit TypeScript code.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (when enable-ts
    (use-package typescript-ts-mode
      :ensure nil
      :defer t
      :mode "\\.ts\\'"
      :hook
      (typescript-ts-mode . lsp-deferred)
      (js2-mode . lsp-deferred)
      :config
      (setq typescript-indent-level 4)
      (cond
        ((equal debug-adapter 'debug-adapter-dap-mode)
        ;; (bind-keys :map typescript-mode-map
        ;;     ("C-c ." . dap-hydra/body))
        (dap-node-setup)))))

#+end_src

*** NodeJS
:properties:
:custom_id: notejs
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun mifi/load-js-file-hook ()
    (js2-mode)

    (when (equal debug-adapter 'debug-adapter-dap-mode)
      (dap-mode)
      (dap-firefox-setup))

    (highlight-indentation-mode nil)
    (dap-firefox-setup))

  (defun mifi/nvm-which ()
    (let ((output (shell-command-to-string "source ~/.nvm/nvm.sh; nvm which")))
      (cadr (split-string output "[\n]+" t))))

  (use-package nodejs-repl
    :defer t
    :config
    (setq nodejs-repl-command #'mifi/nvm-which))

#+end_src

*** JS2-Mode
:properties:
:custom_id: js2-mode
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package js2-mode
    ;;:after simple-httpd
    :hook (js-mode . js2-minor-mode)
    ;; :bind (:map js2-mode-map
    ;;         ("{" . paredit-open-curly)
    ;;         ("}" . paredit-close-curly-and-newline))
    :mode ("\\.js\\'" "\\.mjs\\'" "\\.json$")
    :custom (js2-highlight-level 3))

  (use-package skewer-mode
    :after js2-mode)

  (use-package ac-js2
    :after js2-mode skewer-mode
    :hook (js2-mode . ac-js2-mode))

#+end_src

** GameBoy Development
:properties:
:custom_id: gameboy-development
:visibility: folded
:end:

RGBDS is a compiler that has been around quite a long time (since 1997). It supports Z80 and the LR35902 assembler syntaxes that are used in the development of Game Boy and Game Boy color games.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (when enable-gb-dev
    (use-package z80-mode
      :ensure nil) ;; should have been installed in 'lisp' subdir.
      ;; :vc (:url "https://github.com/SuperDisk/z80-mode"))

    (use-package mwim
      :ensure t)
      ;; :vc (:url "https://github.com/alezost/mwim"))

    (use-package rgbds-mode
      :after mwim
      :ensure nil) ;; should have been installed in 'lisp' subdir.
      ;; :vc (:url "https://github.com/japanoise/rgbds-mode")))
    )

#+end_src

** Rust
:properties:
:custom_id: rust
:visibility: folded
:end:

Rust is blazingly fast and memory-efficient: with no runtime or garbage collector, it can power performance-critical services, run on embedded devices, and easily integrate with other languages.

Much of this configuration was taken from the [[https://robert.kra.hn/posts/rust-emacs-setup/][Robert Krahn]] web site.

*** Rust Prerequisites
:properties:
:custom_id: rust-prerequisites
:visibility: folded
:end:

1. Install Rust and Cargo
   
   #+begin_src shell
               
     curl https://sh.rustup.rs -sSf | sh

   #+end_src


2. Install the Rust analyzer 
   
#+begin_src shell
  #!/bin/bash

  git clone https://github.com/rust-analyzer/rust-analyzer.git -b release
  cd rust-analyzer
  cargo xtask install --server # will install rust-analyzer into $HOME/.cargo/bin

#+end_src

*** Rustic package configuration
:properties:
:custom_id: rust-package-configuration
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package rustic
    :bind (:map rustic-mode-map
            ("M-j" . lsp-ui-imenu)
            ("M-?" . lsp-find-references)
            ("C-c C-c l" . flycheck-list-errors)
            ("C-c C-c a" . lsp-execute-code-action)
            ("C-c C-c r" . lsp-rename)
            ("C-c C-c q" . lsp-workspace-restart)
            ("C-c C-c Q" . lsp-workspace-shutdown)
            ("C-c C-c s" . lsp-rust-analyzer-status))
    :hook
    (rustic-mode . rk/rustic-mode-hook)
    :ensure-system-package
    ( (rustc . "curl https://sh/rustup.rs -sSf | sh")
      (cargo . "curl https://sh/rustup.rs -sSf | sh")
      )
    :config
    ;; uncomment for less flashiness
    ;; (setq lsp-eldoc-hook nil)
    ;; (setq lsp-enable-symbol-highlighting nil)
    ;; (setq lsp-signature-auto-activate nil)

    ;; comment to disable rustfmt on save
    (setq rustic-format-on-save t))


  (defun rk/rustic-mode-hook ()
    ;; so that run C-c C-c C-r works without having to confirm, but don't try to
    ;; save rust buffers that are not file visiting. Once
    ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
    ;; no longer be necessary.
    (lsp-deferred)
    (when buffer-file-name
      (setq-local buffer-save-without-query t))
    (add-hook 'before-save-hook 'lsp-format-buffer nil t))

#+end_src

*** Rust-mode configuration
:properties:
:custom_id: rust-mode-configuration
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;; (use-package graphql-mode)
  (use-package rust-mode
    :disabled ;;; Older than rustic so don't use but 
    :defer t
    :init (setq rust-mode-treesitter-derive t)
    :hook
    (rust-mode . lsp-deferred)
    (rust-mode . (lambda () (setq indent-tabs-mode nil)
                   (prettify-symbols-mode)))
    :config
    (setq rust-format-on-save t))

  (use-package rust-playground :after rust-mode)

#+end_src

*** Cargo and Cargo.toml packages
:properties:
:custom_id: cargo-and-cargo-toml-packages
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; for Cargo.toml and other config files

  (use-package toml-mode :defer t :after rust-mode)


#+end_src

*** Cargo-mode configuration
:properties:
:custom_id: cargo-mode-configuration
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package cargo-mode
    :defer t
    :after rust-mode
    :ensure t)

#+end_src

** Golang
:properties:
:custom_id: golang
:visibility: folded
:end:

*Important!*

Make sure that =gopls= and =dlv= are installed. gopls is the Go! (or golang) language server - like LSP. =dlv= is the =golang= debugger.

#+begin_src shell

  brew install gopls
  go get golang.org/x/tools/cmd/guru
  brew install dlv

#+end_src

*** Main go-mode config
:properties:
:custom_id: main-go-mode-config
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (defun eglot-format-buffer-on-save ()
    (add-hook 'before-save-hook #'eglot-format-buffer -10 t))

  (use-package go-mode
    :ensure t
    :defer t
    :mode ("\\.go\\'" . go-mode)
    :custom
    (compile-command "go build -v && go test -v && go vet")
    :bind (:map go-mode-map
            ("C-c C-c" . 'compile))
    :config
    (eglot-format-buffer-on-save)
    (define-key (current-local-map) "\C-c\C-c" 'compile)
    (cond
      ((equal custom-ide 'custom-ide-eglot)
        (add-hook 'go-mode-hook 'eglot-ensure)
        (add-hook 'go-mode-hook #'elot-format-buffer-on-save))
      ((equal custom-ide 'custom-ide-lsp)
        (add-hook 'go-mode-hook 'lsp-deferred))))

#+end_src

*** go-eldoc config
:properties:
:custom_id: go-eldoc-config
:visibility: folded
:end:

=go-eldoc.el= provides eldoc for Go language. `go-eldoc.el' shows type information for variable, functions and current argument position of function.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package go-eldoc
    :after go-mode
    :hook (go-mode . go-eldoc-setup)
    :config
    (eglot-format-buffer-on-save)
    (set-face-attribute 'eldoc-highlight-function-argument nil
      :underline t :foreground "green"
      :weight 'bold))

#+end_src

*** go-guru config
:properties:
:custom_id: go-guru-config
:visibility: folded
:end:

Integration of the Go 'guru' analysis tool into Emacs.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package go-guru
    :after go-mode
    :hook (go-mode . go-guru-hl-identifier-mode))

#+end_src

** Other Languages
:properties:
:custom_id: other-languages
:visibility: folded
:end:

Lesser used or lesser known languages.

*** Swift
:properties:
:custom_id: swift
:visibility: folded
:end:

Swift is very popular for iOS and macOS development but server-side Swift, which is what this area focuses on, is not as commonly used which is why it appears here (under lesser used).

#+begin_src emacs-lisp :tangle no
  ;;; ##########################################################################

  (use-package swift-ts-mode
    :ensure t
    :defer t
    :mode ("\\.swift\\'" . swift-ts-mode))

  (use-package swift-helpful
    :defer t
    :after swift-mode
    :ensure t)
    ;; :vc ( :url "https://github.com/danielmartin/swift-helpful"
    ;; 	:main-file swift-helpful
    ;; 	:lisp-dir ("swift-info" "target")))

  (use-package swift-playground-mode
    :ensure nil ;; Should be in local 'lisp' dir.
    :defer t
    :after swift-mode
    :init
    (autoload 'swift-playground-global-mode "swift-playground-mode" nil t)
    (add-hook 'swift-mode-hook #'swift-playground-global-mode))
    ;; :vc (:url "https://gitlab.com/michael.sanders")

#+end_src

*** Lisp
:properties:
:custom_id: lisp
:visibility: folded
:end:

Standard included emacs-lisp.

#+begin_src emacs-lisp

  (use-package elisp-mode
    
    :defer t
    :mode ("\\.el\\'" . emacs-lisp-mode))

#+end_src

Lisp support is handled by SLIME which is the “Superior Lisp Interaction Mode for Emacs”. SLIME extends Emacs with support for interactive programming in Common Lisp. The features are centered around slime-mode, an Emacs minor-mode that complements the standard lisp-mode. While lisp-mode supports editing Lisp source files, slime-mode adds support for interacting with a running Common Lisp process for compilation, debugging, documentation lookup, and so on. Extensive documentation can be found [[https://slime.common-lisp.dev/doc/html/][at this link]].

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package slime
    :defer t
    :mode
    ("\\.lisp\\'" . slime-mode)
    :config
    (setq inferior-lisp-program "/opt/homebrew/bin/sbcl"))

#+end_src

** Godot Script Mode
:PROPERTIES:
:custom_id: godot-script-mode
:visibility: folded
:END:

This package adds support for the GDScript programming language from the Godot game engine in Emacs. It gives syntax highlighting and indentations.

#+begin_src emacs-lisp

  (use-package gdscript-mode
    :ensure t
    ;; :straight (gdscript-mode
    ;;             :type git
    ;;             :host github
    ;;             :repo "godotengine/emacs-gdscript-mode")
    :hook (gdscript-mode . eglot-ensure)
    :custom (gdscript-eglot-version 3))

#+end_src

#+begin_src emacs-lisp

  

#+end_src


** Debug Support
:properties:
:custom_id: debug-support
:visibility: folded
:end:

*** Debug Adapter Protocol
:properties:
:custom_id: debug-adapter-protocol
:visibility: folded
:end:

DAP-Mode is an Emacs client/library for Debug Adapter Protocol is a wire protocol for communication between client and Debug Server. It's similar to the LSP but provides integration with debug server.

The idea behind the Debug Adapter Protocol (DAP) is to abstract the way how the debugging support of development tools communicates with debuggers or runtimes into a protocol. Since it is unrealistic to assume that existing debuggers or runtimes adopt this protocol any time soon, we rather assume that an intermediary component - a so called Debug Adapter - adapts an existing debugger or runtime to the Debug Adapter Protocol.

The Debug Adapter Protocol makes it possible to implement a generic debugger for a development tool that can communicate with different debuggers via Debug Adapters. And Debug Adapters can be re-used across multiple development tools which significantly reduces the effort to support a new debugger in different tools.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;;; Debug Adapter Protocol
  (use-package dap-mode
    :when (equal debug-adapter 'debug-adapter-dap-mode)
    :ensure t
    :defer t
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    :commands (dap-debug dap-mode dap-ui-mode)
    :custom
    (dap-auto-configure-features '(sessions locals breakpoints expressions repl controls tooltip))
    :config
    ;; (require 'dap-lldb)
    ;; (require 'dap-gdb-lldb)
    ;; (define-dap-hydra)
    ;; (bind-keys :map prog-mode-map
    ;;   ("C-c ." . dap-hydra/body))
    (dap-ui-controls-mode)
    (dap-ui-mode 1))

#+end_src

**** DAP Python Templates                                       :Python:Rust:
:properties:
:custom_id: dap-python-templates
:visibility: folded
:end:

#+begin_src emacs-lisp :tangle no
  ;;; ##########################################################################

  (defun mifi/register-dap-python-templates ()
    ;; (with-eval-after-load 'dap-lldb
    ;;   (dap-register-debug-template
    ;;     "Rust::LLDB Run Configuration"
    ;;     (list :type "lldb"
    ;;       :request "launch"
    ;;       :name "LLDB::Run"
    ;;       :gdbpath "rust-lldb"
    ;;       :target nil
    ;;       :cwd nil)))
    (dap-register-debug-template "Python :: Run file from project directory"
      (list :type "python"
        :args ""
        :cwd nil
        :module nil
        :program nil
        :request "launch"))
      
    (dap-register-debug-template "Python :: Run file (buffer)"
      (list :type "python"
        :args ""
        :cwd nil
        :module nil
        :program nil
        :request "launch"
        :name "Python :: Run file (buffer)")))

#+end_src

**** DAP Package for OCaml
:properties:
:custom_id: dap-package-for-ocaml
:visibility: folded
:end:

#+begin_src emacs-lisp :tangle no
  ;;; ##########################################################################

  ;; For Emacs >= 30.0 it is possible to use the VC command like this:
  ;; :vc (:url "https://github.com/emacs-lsp/dap-mode"
  ;;      :main-file "dap-ocaml.el")
  ;;
  (use-package dap-ocaml
    :when enable-ocaml
    :after (:all dap-mode opam-emacs-setup)
    :ensure nil
    :ensure-system-package
    ((ocamllsp . "opam install earlybird --yes")))

  (use-package dap-codelldb
    :when enable-ocaml
    :after dap-mode
    :ensure nil
    :defer t)

#+end_src

**** DAP Package for Python :Python:
:properties:
:custom_id: dap-package-for-python
:visibility: folded
:end:

#+begin_src emacs-lisp :tangle no
  ;;; ##########################################################################
  ;;; DAP for Python

  (use-package dap-python
    :when enable-python
    :ensure nil
    ;; :vc (:url "https://github.com/emacs-lsp/dap-mode" :main-file dap-python)
    :when (equal debug-adapter 'debug-adapter-dap-mode)
    :after dap-mode
    :config
    (mifi/register-dap-python-templates)
    (setq dap-python-executable "python3") ;; Otherwise it looks for 'python' else error.
    (setq dap-python-debugger 'debugpy))

#+end_src

**** DAP Setup for Rust and Go :Rust:Go:
:properties:
:custom_id: dap-setup-for-rust-and-go
:visibility: folded
:end:

Something that is needed for Rust and Go debugging.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  (use-package dap-lldb
    :when (equal debug-adapter 'debug-adapter-dap-mode)
    :ensure nil
    :defer t
    :after dap-mode
    :custom
    (dap-lldb-debug-program "~/Developer/command-line-unix/llvm/lldb-build/bin/lldb-dap"))
    ;; :config
    ;; (dap-register-debug-template
    ;;   "Rust::LLDB Run Configuration"
    ;;   (list :type "lldb"
    ;;     :request "launch"
    ;;     :name "LLDB::Run"
    ;;     :gdbpath "rust-lldb"
    ;;     :target nil
    ;;     :cwd nil)))

  (use-package dap-gdb-lldb
    :when (equal debug-adapter 'debug-adapter-dap-mode)
    :ensure nil
    :defer t
    :after dap-lldb
    :config
    (dap-gdb-lldb-setup))

  (use-package dap-cpptools
    :when (equal debug-adapter 'debug-adapter-dap-mode)
    :ensure nil
    :defer t
    :after dap-mode)
  ;; :config
  ;; (dap-cpptools-setup))

#+end_src

**** DAP Hydra
:properties:
:custom_id: dap-hydra
:visibility: folded
:end:

Below are all the necessary functions and definitions for Hydra use under DAP.

***** DAP Hydra Debug Functions :Python:
:properties:
:custom_id: dap-hydra-debug-functions
:visibility: folded
:end:

#+begin_src emacs-lisp :tangle no
  ;;; ##########################################################################

  (defun mifi/dap-end-debug-session ()
    "End the debug session and delete project Python buffers."
    (interactive)
    (kill-matching-buffers "\*Python :: Run file [from|\(buffer]*" nil :NO-ASK)
    (kill-matching-buffers "\*Python: Current File*" nil :NO-ASK)
    (kill-matching-buffers "\*dap-ui-*" nil :NO-ASK)
    (dap-disconnect (dap--cur-session)))

  (defun mifi/dap-delete-all-debug-sessions ()
    "End the debug session and delete project Python buffers and all breakpoints."
    (interactive)
    (dap-breakpoint-delete-all)
    (mifi/dap-end-debug-session))

  (defun mifi/dap-begin-debug-session ()
    "Begin a debug session with several dap windows enabled."
    (interactive)
    (dap-ui-show-many-windows)
    (dap-debug))

#+end_src

***** DAP Hydra Definition Function
:properties:
:custom_id: dap-hydra-definition-functions
:visibility: folded
:end:

#+begin_src emacs-lisp :tangle no
  ;;; ##########################################################################

  (defun define-dap-hydra ()
    (defhydra dap-hydra (:color pink :hint nil :foreign-keys run)
      "
    ^Stepping^            ^Switch^                 ^Breakpoints^          ^Debug^                     ^Eval
    ^^^^^^^^-----------------------------------------------------------------------------------------------------------------
    _._: Next            _ss_: Session            _bb_: Toggle           _dd_: Debug                 _ee_: Eval
    _/_: Step in         _st_: Thread             _bd_: Delete           _dr_: Debug recent          _er_: Eval region
    _,_: Step out        _sf_: Stack frame        _ba_: Add              _dl_: Debug last            _es_: Eval thing at point
    _c_: Continue        _su_: Up stack frame     _bc_: Set condition    _de_: Edit debug template   _ea_: Add expression.
    _r_: Restart frame   _sd_: Down stack frame   _bh_: Set hit count    _ds_: Debug restart
    _Q_: Disconnect      _sl_: List locals        _bl_: Set log message  _dx_: end session
                         _sb_: List breakpoints                          _dX_: end all sessions
                         _sS_: List sessions
                         _sR_: Session Repl
  "
      ("n" dap-next)
      ("i" dap-step-in)
      ("o" dap-step-out)
      ("." dap-next)
      ("/" dap-step-in)
      ("," dap-step-out)
      ("c" dap-continue)
      ("r" dap-restart-frame)
      ("ss" dap-switch-session)
      ("st" dap-switch-thread)
      ("sf" dap-switch-stack-frame)
      ("su" dap-up-stack-frame)
      ("sd" dap-down-stack-frame)
      ("sl" dap-ui-locals)
      ("sb" dap-ui-breakpoints)
      ("sR" dap-ui-repl)
      ("sS" dap-ui-sessions)
      ("bb" dap-breakpoint-toggle)
      ("ba" dap-breakpoint-add)
      ("bd" dap-breakpoint-delete)
      ("bc" dap-breakpoint-condition)
      ("bh" dap-breakpoint-hit-condition)
      ("bl" dap-breakpoint-log-message)
      ("dd" dap-debug)
      ("dr" dap-debug-recent)
      ("ds" dap-debug-restart)
      ("dl" dap-debug-last)
      ("de" dap-debug-edit-template)
      ("ee" dap-eval)
      ("ea" dap-ui-expressions-add)
      ("er" dap-eval-region)
      ("es" dap-eval-thing-at-point)
      ("dx" mifi/dap-end-debug-session)
      ("dX" mifi/dap-delete-all-debug-sessions)
      ("x" nil "exit Hydra" :color yellow)
      ("q" mifi/dap-end-debug-session "quit" :color blue)
      ("Q" mifi/dap-delete-all-debug-sessions :color red)))

#+end_src

* Lastly
:properties:
:custom_id: lastly
:visibility: folded
:end:

** Ignore Line Number Mode
:properties:
:custom_id: ignore-line-number-mode
:visibility: folded
:end:

The following is a list of major mode-hooks variables that are set so that they don't follow the normal global line number mode. If there is any mode that doesn't appear here, more than likely it will have line numbers added. Just add the hook name here to make it so that major mode not have line numbers. This doesn't effect minor modes.

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; Ignore Line Numbers for the following modes:

  ;; Line #'s appear everywhere if global-display-line-numbers-mode is set
  ;; ... except for when in these modes
  (when (equal global-display-line-numbers-mode t)
    (dolist (mode '( dashboard-mode-hook
                     helpful-mode-hook
                     eshell-mode-hook
                     eww-mode-hook
                     help-mode-hook
                     org-mode-hook
                     shell-mode-hook
                     term-mode-hook
                     treemacs-mode-hook
                     vterm-mode-hook))
      (add-hook mode (lambda () (display-line-numbers-mode 0)))))

#+end_src

** Supress common warnings
:properties:
:custom_id: supress-common-warnings
:visibility: folded
:end:

#+begin_src emacs-lisp
  ;;; ##########################################################################
  ;; Supress common annoying warning.
  ;; These can still be found in the  *Warnings* buffer
  (setq warning-suppress-types '((package reinitialization)
                                  (package-initialize)
                                  (package)
                                  (use-package)
                                  (python-mode)))

#+end_src

** Lispy Footer
:properties:
:custom_id: lispy-footer
:visibility: folded
:end:

The standard =lisp= footer that should appear at the end of every =lisp= source file.

#+begin_src emacs-lisp
  ;;; ##########################################################################

  ;;; init.el ends here.

#+end_src

** OCaml special import
:properties:
:custom_id: ocaml-special-import
:visibility: folded
:end:

This is normally installed as part of the ocaml / Merlin setup. This is added here but commented out. The actual =require= is done in the OCaml Language configuration section

#+begin_src emacs-lisp

  ;; ## added by OPAM user-setup for emacs / base ## 56ab50dc8996d2bb95e7856a6eddb17b ## you can edit, but keep this line
  ;;-- This is already handled in the OCaml language config above...
  ;; (require 'opam-user-setup "~/.emacs.d/opam-user-setup.el")
  ;; ## end of OPAM user-setup addition for emacs / base ## keep this line

#+end_src



# Local Variables:
# jinx-local-words: "Elpaca Flycheck Treesit el init"
# End:
